function IM(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n]
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const o = Object.getOwnPropertyDescriptor(r, i)
          o &&
            Object.defineProperty(
              e,
              i,
              o.get ? o : { enumerable: !0, get: () => r[i] }
            )
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })
  )
}
;(function () {
  const t = document.createElement("link").relList
  if (t && t.supports && t.supports("modulepreload")) return
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i)
  new MutationObserver((i) => {
    for (const o of i)
      if (o.type === "childList")
        for (const a of o.addedNodes)
          a.tagName === "LINK" && a.rel === "modulepreload" && r(a)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(i) {
    const o = {}
    return (
      i.integrity && (o.integrity = i.integrity),
      i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (o.credentials = "include")
        : i.crossOrigin === "anonymous"
          ? (o.credentials = "omit")
          : (o.credentials = "same-origin"),
      o
    )
  }
  function r(i) {
    if (i.ep) return
    i.ep = !0
    const o = n(i)
    fetch(i.href, o)
  }
})()
var gu =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
      ? window
      : typeof global < "u"
        ? global
        : typeof self < "u"
          ? self
          : {}
function Pe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e
}
var BP = { exports: {} },
  ad = {},
  FP = { exports: {} },
  le = {}
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Kl = Symbol.for("react.element"),
  NM = Symbol.for("react.portal"),
  RM = Symbol.for("react.fragment"),
  LM = Symbol.for("react.strict_mode"),
  BM = Symbol.for("react.profiler"),
  FM = Symbol.for("react.provider"),
  VM = Symbol.for("react.context"),
  zM = Symbol.for("react.forward_ref"),
  UM = Symbol.for("react.suspense"),
  WM = Symbol.for("react.memo"),
  HM = Symbol.for("react.lazy"),
  lb = Symbol.iterator
function GM(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (lb && e[lb]) || e["@@iterator"]),
      typeof e == "function" ? e : null)
}
var VP = {
    isMounted: function () {
      return !1
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  zP = Object.assign,
  UP = {}
function Oa(e, t, n) {
  ;(this.props = e),
    (this.context = t),
    (this.refs = UP),
    (this.updater = n || VP)
}
Oa.prototype.isReactComponent = {}
Oa.prototype.setState = function (e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    )
  this.updater.enqueueSetState(this, e, t, "setState")
}
Oa.prototype.forceUpdate = function (e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate")
}
function WP() {}
WP.prototype = Oa.prototype
function Eg(e, t, n) {
  ;(this.props = e),
    (this.context = t),
    (this.refs = UP),
    (this.updater = n || VP)
}
var Cg = (Eg.prototype = new WP())
Cg.constructor = Eg
zP(Cg, Oa.prototype)
Cg.isPureReactComponent = !0
var ub = Array.isArray,
  HP = Object.prototype.hasOwnProperty,
  _g = { current: null },
  GP = { key: !0, ref: !0, __self: !0, __source: !0 }
function KP(e, t, n) {
  var r,
    i = {},
    o = null,
    a = null
  if (t != null)
    for (r in (t.ref !== void 0 && (a = t.ref),
    t.key !== void 0 && (o = "" + t.key),
    t))
      HP.call(t, r) && !GP.hasOwnProperty(r) && (i[r] = t[r])
  var s = arguments.length - 2
  if (s === 1) i.children = n
  else if (1 < s) {
    for (var l = Array(s), u = 0; u < s; u++) l[u] = arguments[u + 2]
    i.children = l
  }
  if (e && e.defaultProps)
    for (r in ((s = e.defaultProps), s)) i[r] === void 0 && (i[r] = s[r])
  return { $$typeof: Kl, type: e, key: o, ref: a, props: i, _owner: _g.current }
}
function KM(e, t) {
  return {
    $$typeof: Kl,
    type: e.type,
    key: t,
    ref: e.ref,
    props: e.props,
    _owner: e._owner
  }
}
function kg(e) {
  return typeof e == "object" && e !== null && e.$$typeof === Kl
}
function qM(e) {
  var t = { "=": "=0", ":": "=2" }
  return (
    "$" +
    e.replace(/[=:]/g, function (n) {
      return t[n]
    })
  )
}
var cb = /\/+/g
function Pp(e, t) {
  return typeof e == "object" && e !== null && e.key != null
    ? qM("" + e.key)
    : t.toString(36)
}
function sc(e, t, n, r, i) {
  var o = typeof e
  ;(o === "undefined" || o === "boolean") && (e = null)
  var a = !1
  if (e === null) a = !0
  else
    switch (o) {
      case "string":
      case "number":
        a = !0
        break
      case "object":
        switch (e.$$typeof) {
          case Kl:
          case NM:
            a = !0
        }
    }
  if (a)
    return (
      (a = e),
      (i = i(a)),
      (e = r === "" ? "." + Pp(a, 0) : r),
      ub(i)
        ? ((n = ""),
          e != null && (n = e.replace(cb, "$&/") + "/"),
          sc(i, t, n, "", function (u) {
            return u
          }))
        : i != null &&
          (kg(i) &&
            (i = KM(
              i,
              n +
                (!i.key || (a && a.key === i.key)
                  ? ""
                  : ("" + i.key).replace(cb, "$&/") + "/") +
                e
            )),
          t.push(i)),
      1
    )
  if (((a = 0), (r = r === "" ? "." : r + ":"), ub(e)))
    for (var s = 0; s < e.length; s++) {
      o = e[s]
      var l = r + Pp(o, s)
      a += sc(o, t, n, l, i)
    }
  else if (((l = GM(e)), typeof l == "function"))
    for (e = l.call(e), s = 0; !(o = e.next()).done; )
      (o = o.value), (l = r + Pp(o, s++)), (a += sc(o, t, n, l, i))
  else if (o === "object")
    throw (
      ((t = String(e)),
      Error(
        "Objects are not valid as a React child (found: " +
          (t === "[object Object]"
            ? "object with keys {" + Object.keys(e).join(", ") + "}"
            : t) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    )
  return a
}
function yu(e, t, n) {
  if (e == null) return e
  var r = [],
    i = 0
  return (
    sc(e, r, "", "", function (o) {
      return t.call(n, o, i++)
    }),
    r
  )
}
function XM(e) {
  if (e._status === -1) {
    var t = e._result
    ;(t = t()),
      t.then(
        function (n) {
          ;(e._status === 0 || e._status === -1) &&
            ((e._status = 1), (e._result = n))
        },
        function (n) {
          ;(e._status === 0 || e._status === -1) &&
            ((e._status = 2), (e._result = n))
        }
      ),
      e._status === -1 && ((e._status = 0), (e._result = t))
  }
  if (e._status === 1) return e._result.default
  throw e._result
}
var jt = { current: null },
  lc = { transition: null },
  YM = {
    ReactCurrentDispatcher: jt,
    ReactCurrentBatchConfig: lc,
    ReactCurrentOwner: _g
  }
le.Children = {
  map: yu,
  forEach: function (e, t, n) {
    yu(
      e,
      function () {
        t.apply(this, arguments)
      },
      n
    )
  },
  count: function (e) {
    var t = 0
    return (
      yu(e, function () {
        t++
      }),
      t
    )
  },
  toArray: function (e) {
    return (
      yu(e, function (t) {
        return t
      }) || []
    )
  },
  only: function (e) {
    if (!kg(e))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      )
    return e
  }
}
le.Component = Oa
le.Fragment = RM
le.Profiler = BM
le.PureComponent = Eg
le.StrictMode = LM
le.Suspense = UM
le.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = YM
le.cloneElement = function (e, t, n) {
  if (e == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        e +
        "."
    )
  var r = zP({}, e.props),
    i = e.key,
    o = e.ref,
    a = e._owner
  if (t != null) {
    if (
      (t.ref !== void 0 && ((o = t.ref), (a = _g.current)),
      t.key !== void 0 && (i = "" + t.key),
      e.type && e.type.defaultProps)
    )
      var s = e.type.defaultProps
    for (l in t)
      HP.call(t, l) &&
        !GP.hasOwnProperty(l) &&
        (r[l] = t[l] === void 0 && s !== void 0 ? s[l] : t[l])
  }
  var l = arguments.length - 2
  if (l === 1) r.children = n
  else if (1 < l) {
    s = Array(l)
    for (var u = 0; u < l; u++) s[u] = arguments[u + 2]
    r.children = s
  }
  return { $$typeof: Kl, type: e.type, key: i, ref: o, props: r, _owner: a }
}
le.createContext = function (e) {
  return (
    (e = {
      $$typeof: VM,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null
    }),
    (e.Provider = { $$typeof: FM, _context: e }),
    (e.Consumer = e)
  )
}
le.createElement = KP
le.createFactory = function (e) {
  var t = KP.bind(null, e)
  return (t.type = e), t
}
le.createRef = function () {
  return { current: null }
}
le.forwardRef = function (e) {
  return { $$typeof: zM, render: e }
}
le.isValidElement = kg
le.lazy = function (e) {
  return { $$typeof: HM, _payload: { _status: -1, _result: e }, _init: XM }
}
le.memo = function (e, t) {
  return { $$typeof: WM, type: e, compare: t === void 0 ? null : t }
}
le.startTransition = function (e) {
  var t = lc.transition
  lc.transition = {}
  try {
    e()
  } finally {
    lc.transition = t
  }
}
le.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.")
}
le.useCallback = function (e, t) {
  return jt.current.useCallback(e, t)
}
le.useContext = function (e) {
  return jt.current.useContext(e)
}
le.useDebugValue = function () {}
le.useDeferredValue = function (e) {
  return jt.current.useDeferredValue(e)
}
le.useEffect = function (e, t) {
  return jt.current.useEffect(e, t)
}
le.useId = function () {
  return jt.current.useId()
}
le.useImperativeHandle = function (e, t, n) {
  return jt.current.useImperativeHandle(e, t, n)
}
le.useInsertionEffect = function (e, t) {
  return jt.current.useInsertionEffect(e, t)
}
le.useLayoutEffect = function (e, t) {
  return jt.current.useLayoutEffect(e, t)
}
le.useMemo = function (e, t) {
  return jt.current.useMemo(e, t)
}
le.useReducer = function (e, t, n) {
  return jt.current.useReducer(e, t, n)
}
le.useRef = function (e) {
  return jt.current.useRef(e)
}
le.useState = function (e) {
  return jt.current.useState(e)
}
le.useSyncExternalStore = function (e, t, n) {
  return jt.current.useSyncExternalStore(e, t, n)
}
le.useTransition = function () {
  return jt.current.useTransition()
}
le.version = "18.2.0"
FP.exports = le
var P = FP.exports
const E = Pe(P),
  QM = IM({ __proto__: null, default: E }, [P])
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ZM = P,
  JM = Symbol.for("react.element"),
  e2 = Symbol.for("react.fragment"),
  t2 = Object.prototype.hasOwnProperty,
  n2 = ZM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  r2 = { key: !0, ref: !0, __self: !0, __source: !0 }
function qP(e, t, n) {
  var r,
    i = {},
    o = null,
    a = null
  n !== void 0 && (o = "" + n),
    t.key !== void 0 && (o = "" + t.key),
    t.ref !== void 0 && (a = t.ref)
  for (r in t) t2.call(t, r) && !r2.hasOwnProperty(r) && (i[r] = t[r])
  if (e && e.defaultProps)
    for (r in ((t = e.defaultProps), t)) i[r] === void 0 && (i[r] = t[r])
  return { $$typeof: JM, type: e, key: o, ref: a, props: i, _owner: n2.current }
}
ad.Fragment = e2
ad.jsx = qP
ad.jsxs = qP
BP.exports = ad
var j = BP.exports,
  Qh = {},
  XP = { exports: {} },
  en = {},
  YP = { exports: {} },
  QP = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function (e) {
  function t(k, I) {
    var V = k.length
    k.push(I)
    e: for (; 0 < V; ) {
      var U = (V - 1) >>> 1,
        H = k[U]
      if (0 < i(H, I)) (k[U] = I), (k[V] = H), (V = U)
      else break e
    }
  }
  function n(k) {
    return k.length === 0 ? null : k[0]
  }
  function r(k) {
    if (k.length === 0) return null
    var I = k[0],
      V = k.pop()
    if (V !== I) {
      k[0] = V
      e: for (var U = 0, H = k.length, ee = H >>> 1; U < ee; ) {
        var X = 2 * (U + 1) - 1,
          de = k[X],
          ue = X + 1,
          We = k[ue]
        if (0 > i(de, V))
          ue < H && 0 > i(We, de)
            ? ((k[U] = We), (k[ue] = V), (U = ue))
            : ((k[U] = de), (k[X] = V), (U = X))
        else if (ue < H && 0 > i(We, V)) (k[U] = We), (k[ue] = V), (U = ue)
        else break e
      }
    }
    return I
  }
  function i(k, I) {
    var V = k.sortIndex - I.sortIndex
    return V !== 0 ? V : k.id - I.id
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var o = performance
    e.unstable_now = function () {
      return o.now()
    }
  } else {
    var a = Date,
      s = a.now()
    e.unstable_now = function () {
      return a.now() - s
    }
  }
  var l = [],
    u = [],
    f = 1,
    c = null,
    d = 3,
    p = !1,
    h = !1,
    m = !1,
    b = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    v = typeof setImmediate < "u" ? setImmediate : null
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling)
  function y(k) {
    for (var I = n(u); I !== null; ) {
      if (I.callback === null) r(u)
      else if (I.startTime <= k) r(u), (I.sortIndex = I.expirationTime), t(l, I)
      else break
      I = n(u)
    }
  }
  function w(k) {
    if (((m = !1), y(k), !h))
      if (n(l) !== null) (h = !0), N(x)
      else {
        var I = n(u)
        I !== null && L(w, I.startTime - k)
      }
  }
  function x(k, I) {
    ;(h = !1), m && ((m = !1), g($), ($ = -1)), (p = !0)
    var V = d
    try {
      for (
        y(I), c = n(l);
        c !== null && (!(c.expirationTime > I) || (k && !T()));

      ) {
        var U = c.callback
        if (typeof U == "function") {
          ;(c.callback = null), (d = c.priorityLevel)
          var H = U(c.expirationTime <= I)
          ;(I = e.unstable_now()),
            typeof H == "function" ? (c.callback = H) : c === n(l) && r(l),
            y(I)
        } else r(l)
        c = n(l)
      }
      if (c !== null) var ee = !0
      else {
        var X = n(u)
        X !== null && L(w, X.startTime - I), (ee = !1)
      }
      return ee
    } finally {
      ;(c = null), (d = V), (p = !1)
    }
  }
  var S = !1,
    O = null,
    $ = -1,
    A = 5,
    C = -1
  function T() {
    return !(e.unstable_now() - C < A)
  }
  function _() {
    if (O !== null) {
      var k = e.unstable_now()
      C = k
      var I = !0
      try {
        I = O(!0, k)
      } finally {
        I ? R() : ((S = !1), (O = null))
      }
    } else S = !1
  }
  var R
  if (typeof v == "function")
    R = function () {
      v(_)
    }
  else if (typeof MessageChannel < "u") {
    var M = new MessageChannel(),
      D = M.port2
    ;(M.port1.onmessage = _),
      (R = function () {
        D.postMessage(null)
      })
  } else
    R = function () {
      b(_, 0)
    }
  function N(k) {
    ;(O = k), S || ((S = !0), R())
  }
  function L(k, I) {
    $ = b(function () {
      k(e.unstable_now())
    }, I)
  }
  ;(e.unstable_IdlePriority = 5),
    (e.unstable_ImmediatePriority = 1),
    (e.unstable_LowPriority = 4),
    (e.unstable_NormalPriority = 3),
    (e.unstable_Profiling = null),
    (e.unstable_UserBlockingPriority = 2),
    (e.unstable_cancelCallback = function (k) {
      k.callback = null
    }),
    (e.unstable_continueExecution = function () {
      h || p || ((h = !0), N(x))
    }),
    (e.unstable_forceFrameRate = function (k) {
      0 > k || 125 < k
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (A = 0 < k ? Math.floor(1e3 / k) : 5)
    }),
    (e.unstable_getCurrentPriorityLevel = function () {
      return d
    }),
    (e.unstable_getFirstCallbackNode = function () {
      return n(l)
    }),
    (e.unstable_next = function (k) {
      switch (d) {
        case 1:
        case 2:
        case 3:
          var I = 3
          break
        default:
          I = d
      }
      var V = d
      d = I
      try {
        return k()
      } finally {
        d = V
      }
    }),
    (e.unstable_pauseExecution = function () {}),
    (e.unstable_requestPaint = function () {}),
    (e.unstable_runWithPriority = function (k, I) {
      switch (k) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          k = 3
      }
      var V = d
      d = k
      try {
        return I()
      } finally {
        d = V
      }
    }),
    (e.unstable_scheduleCallback = function (k, I, V) {
      var U = e.unstable_now()
      switch (
        (typeof V == "object" && V !== null
          ? ((V = V.delay), (V = typeof V == "number" && 0 < V ? U + V : U))
          : (V = U),
        k)
      ) {
        case 1:
          var H = -1
          break
        case 2:
          H = 250
          break
        case 5:
          H = 1073741823
          break
        case 4:
          H = 1e4
          break
        default:
          H = 5e3
      }
      return (
        (H = V + H),
        (k = {
          id: f++,
          callback: I,
          priorityLevel: k,
          startTime: V,
          expirationTime: H,
          sortIndex: -1
        }),
        V > U
          ? ((k.sortIndex = V),
            t(u, k),
            n(l) === null &&
              k === n(u) &&
              (m ? (g($), ($ = -1)) : (m = !0), L(w, V - U)))
          : ((k.sortIndex = H), t(l, k), h || p || ((h = !0), N(x))),
        k
      )
    }),
    (e.unstable_shouldYield = T),
    (e.unstable_wrapCallback = function (k) {
      var I = d
      return function () {
        var V = d
        d = I
        try {
          return k.apply(this, arguments)
        } finally {
          d = V
        }
      }
    })
})(QP)
YP.exports = QP
var i2 = YP.exports
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ZP = P,
  Qt = i2
function z(e) {
  for (
    var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1;
    n < arguments.length;
    n++
  )
    t += "&args[]=" + encodeURIComponent(arguments[n])
  return (
    "Minified React error #" +
    e +
    "; visit " +
    t +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  )
}
var JP = new Set(),
  Bs = {}
function ro(e, t) {
  Xo(e, t), Xo(e + "Capture", t)
}
function Xo(e, t) {
  for (Bs[e] = t, e = 0; e < t.length; e++) JP.add(t[e])
}
var vr = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  Zh = Object.prototype.hasOwnProperty,
  o2 =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  fb = {},
  db = {}
function a2(e) {
  return Zh.call(db, e)
    ? !0
    : Zh.call(fb, e)
      ? !1
      : o2.test(e)
        ? (db[e] = !0)
        : ((fb[e] = !0), !1)
}
function s2(e, t, n, r) {
  if (n !== null && n.type === 0) return !1
  switch (typeof t) {
    case "function":
    case "symbol":
      return !0
    case "boolean":
      return r
        ? !1
        : n !== null
          ? !n.acceptsBooleans
          : ((e = e.toLowerCase().slice(0, 5)), e !== "data-" && e !== "aria-")
    default:
      return !1
  }
}
function l2(e, t, n, r) {
  if (t === null || typeof t > "u" || s2(e, t, n, r)) return !0
  if (r) return !1
  if (n !== null)
    switch (n.type) {
      case 3:
        return !t
      case 4:
        return t === !1
      case 5:
        return isNaN(t)
      case 6:
        return isNaN(t) || 1 > t
    }
  return !1
}
function Dt(e, t, n, r, i, o, a) {
  ;(this.acceptsBooleans = t === 2 || t === 3 || t === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = e),
    (this.type = t),
    (this.sanitizeURL = o),
    (this.removeEmptyString = a)
}
var xt = {}
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (e) {
    xt[e] = new Dt(e, 0, !1, e, null, !1, !1)
  })
;[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(function (e) {
  var t = e[0]
  xt[t] = new Dt(t, 1, !1, e[1], null, !1, !1)
})
;["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) {
  xt[e] = new Dt(e, 2, !1, e.toLowerCase(), null, !1, !1)
})
;[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach(function (e) {
  xt[e] = new Dt(e, 2, !1, e, null, !1, !1)
})
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (e) {
    xt[e] = new Dt(e, 3, !1, e.toLowerCase(), null, !1, !1)
  })
;["checked", "multiple", "muted", "selected"].forEach(function (e) {
  xt[e] = new Dt(e, 3, !0, e, null, !1, !1)
})
;["capture", "download"].forEach(function (e) {
  xt[e] = new Dt(e, 4, !1, e, null, !1, !1)
})
;["cols", "rows", "size", "span"].forEach(function (e) {
  xt[e] = new Dt(e, 6, !1, e, null, !1, !1)
})
;["rowSpan", "start"].forEach(function (e) {
  xt[e] = new Dt(e, 5, !1, e.toLowerCase(), null, !1, !1)
})
var Mg = /[\-:]([a-z])/g
function jg(e) {
  return e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace(Mg, jg)
    xt[t] = new Dt(t, 1, !1, e, null, !1, !1)
  })
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace(Mg, jg)
    xt[t] = new Dt(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
  })
;["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
  var t = e.replace(Mg, jg)
  xt[t] = new Dt(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
})
;["tabIndex", "crossOrigin"].forEach(function (e) {
  xt[e] = new Dt(e, 1, !1, e.toLowerCase(), null, !1, !1)
})
xt.xlinkHref = new Dt(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
)
;["src", "href", "action", "formAction"].forEach(function (e) {
  xt[e] = new Dt(e, 1, !1, e.toLowerCase(), null, !0, !0)
})
function Dg(e, t, n, r) {
  var i = xt.hasOwnProperty(t) ? xt[t] : null
  ;(i !== null
    ? i.type !== 0
    : r ||
      !(2 < t.length) ||
      (t[0] !== "o" && t[0] !== "O") ||
      (t[1] !== "n" && t[1] !== "N")) &&
    (l2(t, n, i, r) && (n = null),
    r || i === null
      ? a2(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n))
      : i.mustUseProperty
        ? (e[i.propertyName] = n === null ? (i.type === 3 ? !1 : "") : n)
        : ((t = i.attributeName),
          (r = i.attributeNamespace),
          n === null
            ? e.removeAttribute(t)
            : ((i = i.type),
              (n = i === 3 || (i === 4 && n === !0) ? "" : "" + n),
              r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
}
var Er = ZP.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  bu = Symbol.for("react.element"),
  bo = Symbol.for("react.portal"),
  xo = Symbol.for("react.fragment"),
  Ig = Symbol.for("react.strict_mode"),
  Jh = Symbol.for("react.profiler"),
  e$ = Symbol.for("react.provider"),
  t$ = Symbol.for("react.context"),
  Ng = Symbol.for("react.forward_ref"),
  em = Symbol.for("react.suspense"),
  tm = Symbol.for("react.suspense_list"),
  Rg = Symbol.for("react.memo"),
  zr = Symbol.for("react.lazy"),
  n$ = Symbol.for("react.offscreen"),
  pb = Symbol.iterator
function Wa(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (pb && e[pb]) || e["@@iterator"]),
      typeof e == "function" ? e : null)
}
var ze = Object.assign,
  $p
function hs(e) {
  if ($p === void 0)
    try {
      throw Error()
    } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/)
      $p = (t && t[1]) || ""
    }
  return (
    `
` +
    $p +
    e
  )
}
var Ap = !1
function Tp(e, t) {
  if (!e || Ap) return ""
  Ap = !0
  var n = Error.prepareStackTrace
  Error.prepareStackTrace = void 0
  try {
    if (t)
      if (
        ((t = function () {
          throw Error()
        }),
        Object.defineProperty(t.prototype, "props", {
          set: function () {
            throw Error()
          }
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(t, [])
        } catch (u) {
          var r = u
        }
        Reflect.construct(e, [], t)
      } else {
        try {
          t.call()
        } catch (u) {
          r = u
        }
        e.call(t.prototype)
      }
    else {
      try {
        throw Error()
      } catch (u) {
        r = u
      }
      e()
    }
  } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (
        var i = u.stack.split(`
`),
          o = r.stack.split(`
`),
          a = i.length - 1,
          s = o.length - 1;
        1 <= a && 0 <= s && i[a] !== o[s];

      )
        s--
      for (; 1 <= a && 0 <= s; a--, s--)
        if (i[a] !== o[s]) {
          if (a !== 1 || s !== 1)
            do
              if ((a--, s--, 0 > s || i[a] !== o[s])) {
                var l =
                  `
` + i[a].replace(" at new ", " at ")
                return (
                  e.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", e.displayName)),
                  l
                )
              }
            while (1 <= a && 0 <= s)
          break
        }
    }
  } finally {
    ;(Ap = !1), (Error.prepareStackTrace = n)
  }
  return (e = e ? e.displayName || e.name : "") ? hs(e) : ""
}
function u2(e) {
  switch (e.tag) {
    case 5:
      return hs(e.type)
    case 16:
      return hs("Lazy")
    case 13:
      return hs("Suspense")
    case 19:
      return hs("SuspenseList")
    case 0:
    case 2:
    case 15:
      return (e = Tp(e.type, !1)), e
    case 11:
      return (e = Tp(e.type.render, !1)), e
    case 1:
      return (e = Tp(e.type, !0)), e
    default:
      return ""
  }
}
function nm(e) {
  if (e == null) return null
  if (typeof e == "function") return e.displayName || e.name || null
  if (typeof e == "string") return e
  switch (e) {
    case xo:
      return "Fragment"
    case bo:
      return "Portal"
    case Jh:
      return "Profiler"
    case Ig:
      return "StrictMode"
    case em:
      return "Suspense"
    case tm:
      return "SuspenseList"
  }
  if (typeof e == "object")
    switch (e.$$typeof) {
      case t$:
        return (e.displayName || "Context") + ".Consumer"
      case e$:
        return (e._context.displayName || "Context") + ".Provider"
      case Ng:
        var t = e.render
        return (
          (e = e.displayName),
          e ||
            ((e = t.displayName || t.name || ""),
            (e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")),
          e
        )
      case Rg:
        return (
          (t = e.displayName || null), t !== null ? t : nm(e.type) || "Memo"
        )
      case zr:
        ;(t = e._payload), (e = e._init)
        try {
          return nm(e(t))
        } catch {}
    }
  return null
}
function c2(e) {
  var t = e.type
  switch (e.tag) {
    case 24:
      return "Cache"
    case 9:
      return (t.displayName || "Context") + ".Consumer"
    case 10:
      return (t._context.displayName || "Context") + ".Provider"
    case 18:
      return "DehydratedFragment"
    case 11:
      return (
        (e = t.render),
        (e = e.displayName || e.name || ""),
        t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")
      )
    case 7:
      return "Fragment"
    case 5:
      return t
    case 4:
      return "Portal"
    case 3:
      return "Root"
    case 6:
      return "Text"
    case 16:
      return nm(t)
    case 8:
      return t === Ig ? "StrictMode" : "Mode"
    case 22:
      return "Offscreen"
    case 12:
      return "Profiler"
    case 21:
      return "Scope"
    case 13:
      return "Suspense"
    case 19:
      return "SuspenseList"
    case 25:
      return "TracingMarker"
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == "function") return t.displayName || t.name || null
      if (typeof t == "string") return t
  }
  return null
}
function ui(e) {
  switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e
    case "object":
      return e
    default:
      return ""
  }
}
function r$(e) {
  var t = e.type
  return (
    (e = e.nodeName) &&
    e.toLowerCase() === "input" &&
    (t === "checkbox" || t === "radio")
  )
}
function f2(e) {
  var t = r$(e) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    r = "" + e[t]
  if (
    !e.hasOwnProperty(t) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var i = n.get,
      o = n.set
    return (
      Object.defineProperty(e, t, {
        configurable: !0,
        get: function () {
          return i.call(this)
        },
        set: function (a) {
          ;(r = "" + a), o.call(this, a)
        }
      }),
      Object.defineProperty(e, t, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r
        },
        setValue: function (a) {
          r = "" + a
        },
        stopTracking: function () {
          ;(e._valueTracker = null), delete e[t]
        }
      }
    )
  }
}
function xu(e) {
  e._valueTracker || (e._valueTracker = f2(e))
}
function i$(e) {
  if (!e) return !1
  var t = e._valueTracker
  if (!t) return !0
  var n = t.getValue(),
    r = ""
  return (
    e && (r = r$(e) ? (e.checked ? "true" : "false") : e.value),
    (e = r),
    e !== n ? (t.setValue(e), !0) : !1
  )
}
function Cc(e) {
  if (((e = e || (typeof document < "u" ? document : void 0)), typeof e > "u"))
    return null
  try {
    return e.activeElement || e.body
  } catch {
    return e.body
  }
}
function rm(e, t) {
  var n = t.checked
  return ze({}, t, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? e._wrapperState.initialChecked
  })
}
function hb(e, t) {
  var n = t.defaultValue == null ? "" : t.defaultValue,
    r = t.checked != null ? t.checked : t.defaultChecked
  ;(n = ui(t.value != null ? t.value : n)),
    (e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled:
        t.type === "checkbox" || t.type === "radio"
          ? t.checked != null
          : t.value != null
    })
}
function o$(e, t) {
  ;(t = t.checked), t != null && Dg(e, "checked", t, !1)
}
function im(e, t) {
  o$(e, t)
  var n = ui(t.value),
    r = t.type
  if (n != null)
    r === "number"
      ? ((n === 0 && e.value === "") || e.value != n) && (e.value = "" + n)
      : e.value !== "" + n && (e.value = "" + n)
  else if (r === "submit" || r === "reset") {
    e.removeAttribute("value")
    return
  }
  t.hasOwnProperty("value")
    ? om(e, t.type, n)
    : t.hasOwnProperty("defaultValue") && om(e, t.type, ui(t.defaultValue)),
    t.checked == null &&
      t.defaultChecked != null &&
      (e.defaultChecked = !!t.defaultChecked)
}
function mb(e, t, n) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
    var r = t.type
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (t.value !== void 0 && t.value !== null)
      )
    )
      return
    ;(t = "" + e._wrapperState.initialValue),
      n || t === e.value || (e.value = t),
      (e.defaultValue = t)
  }
  ;(n = e.name),
    n !== "" && (e.name = ""),
    (e.defaultChecked = !!e._wrapperState.initialChecked),
    n !== "" && (e.name = n)
}
function om(e, t, n) {
  ;(t !== "number" || Cc(e.ownerDocument) !== e) &&
    (n == null
      ? (e.defaultValue = "" + e._wrapperState.initialValue)
      : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
}
var ms = Array.isArray
function Lo(e, t, n, r) {
  if (((e = e.options), t)) {
    t = {}
    for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0
    for (n = 0; n < e.length; n++)
      (i = t.hasOwnProperty("$" + e[n].value)),
        e[n].selected !== i && (e[n].selected = i),
        i && r && (e[n].defaultSelected = !0)
  } else {
    for (n = "" + ui(n), t = null, i = 0; i < e.length; i++) {
      if (e[i].value === n) {
        ;(e[i].selected = !0), r && (e[i].defaultSelected = !0)
        return
      }
      t !== null || e[i].disabled || (t = e[i])
    }
    t !== null && (t.selected = !0)
  }
}
function am(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(z(91))
  return ze({}, t, {
    value: void 0,
    defaultValue: void 0,
    children: "" + e._wrapperState.initialValue
  })
}
function vb(e, t) {
  var n = t.value
  if (n == null) {
    if (((n = t.children), (t = t.defaultValue), n != null)) {
      if (t != null) throw Error(z(92))
      if (ms(n)) {
        if (1 < n.length) throw Error(z(93))
        n = n[0]
      }
      t = n
    }
    t == null && (t = ""), (n = t)
  }
  e._wrapperState = { initialValue: ui(n) }
}
function a$(e, t) {
  var n = ui(t.value),
    r = ui(t.defaultValue)
  n != null &&
    ((n = "" + n),
    n !== e.value && (e.value = n),
    t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
    r != null && (e.defaultValue = "" + r)
}
function gb(e) {
  var t = e.textContent
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t)
}
function s$(e) {
  switch (e) {
    case "svg":
      return "http://www.w3.org/2000/svg"
    case "math":
      return "http://www.w3.org/1998/Math/MathML"
    default:
      return "http://www.w3.org/1999/xhtml"
  }
}
function sm(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml"
    ? s$(t)
    : e === "http://www.w3.org/2000/svg" && t === "foreignObject"
      ? "http://www.w3.org/1999/xhtml"
      : e
}
var wu,
  l$ = (function (e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (t, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return e(t, n, r, i)
          })
        }
      : e
  })(function (e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e)
      e.innerHTML = t
    else {
      for (
        wu = wu || document.createElement("div"),
          wu.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
          t = wu.firstChild;
        e.firstChild;

      )
        e.removeChild(e.firstChild)
      for (; t.firstChild; ) e.appendChild(t.firstChild)
    }
  })
function Fs(e, t) {
  if (t) {
    var n = e.firstChild
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t
      return
    }
  }
  e.textContent = t
}
var ws = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  },
  d2 = ["Webkit", "ms", "Moz", "O"]
Object.keys(ws).forEach(function (e) {
  d2.forEach(function (t) {
    ;(t = t + e.charAt(0).toUpperCase() + e.substring(1)), (ws[t] = ws[e])
  })
})
function u$(e, t, n) {
  return t == null || typeof t == "boolean" || t === ""
    ? ""
    : n || typeof t != "number" || t === 0 || (ws.hasOwnProperty(e) && ws[e])
      ? ("" + t).trim()
      : t + "px"
}
function c$(e, t) {
  e = e.style
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        i = u$(n, t[n], r)
      n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : (e[n] = i)
    }
}
var p2 = ze(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  }
)
function lm(e, t) {
  if (t) {
    if (p2[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
      throw Error(z(137, e))
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(z(60))
      if (
        typeof t.dangerouslySetInnerHTML != "object" ||
        !("__html" in t.dangerouslySetInnerHTML)
      )
        throw Error(z(61))
    }
    if (t.style != null && typeof t.style != "object") throw Error(z(62))
  }
}
function um(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string"
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1
    default:
      return !0
  }
}
var cm = null
function Lg(e) {
  return (
    (e = e.target || e.srcElement || window),
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
  )
}
var fm = null,
  Bo = null,
  Fo = null
function yb(e) {
  if ((e = Yl(e))) {
    if (typeof fm != "function") throw Error(z(280))
    var t = e.stateNode
    t && ((t = fd(t)), fm(e.stateNode, e.type, t))
  }
}
function f$(e) {
  Bo ? (Fo ? Fo.push(e) : (Fo = [e])) : (Bo = e)
}
function d$() {
  if (Bo) {
    var e = Bo,
      t = Fo
    if (((Fo = Bo = null), yb(e), t)) for (e = 0; e < t.length; e++) yb(t[e])
  }
}
function p$(e, t) {
  return e(t)
}
function h$() {}
var Ep = !1
function m$(e, t, n) {
  if (Ep) return e(t, n)
  Ep = !0
  try {
    return p$(e, t, n)
  } finally {
    ;(Ep = !1), (Bo !== null || Fo !== null) && (h$(), d$())
  }
}
function Vs(e, t) {
  var n = e.stateNode
  if (n === null) return null
  var r = fd(n)
  if (r === null) return null
  n = r[t]
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      ;(r = !r.disabled) ||
        ((e = e.type),
        (r = !(
          e === "button" ||
          e === "input" ||
          e === "select" ||
          e === "textarea"
        ))),
        (e = !r)
      break e
    default:
      e = !1
  }
  if (e) return null
  if (n && typeof n != "function") throw Error(z(231, t, typeof n))
  return n
}
var dm = !1
if (vr)
  try {
    var Ha = {}
    Object.defineProperty(Ha, "passive", {
      get: function () {
        dm = !0
      }
    }),
      window.addEventListener("test", Ha, Ha),
      window.removeEventListener("test", Ha, Ha)
  } catch {
    dm = !1
  }
function h2(e, t, n, r, i, o, a, s, l) {
  var u = Array.prototype.slice.call(arguments, 3)
  try {
    t.apply(n, u)
  } catch (f) {
    this.onError(f)
  }
}
var Ss = !1,
  _c = null,
  kc = !1,
  pm = null,
  m2 = {
    onError: function (e) {
      ;(Ss = !0), (_c = e)
    }
  }
function v2(e, t, n, r, i, o, a, s, l) {
  ;(Ss = !1), (_c = null), h2.apply(m2, arguments)
}
function g2(e, t, n, r, i, o, a, s, l) {
  if ((v2.apply(this, arguments), Ss)) {
    if (Ss) {
      var u = _c
      ;(Ss = !1), (_c = null)
    } else throw Error(z(198))
    kc || ((kc = !0), (pm = u))
  }
}
function io(e) {
  var t = e,
    n = e
  if (e.alternate) for (; t.return; ) t = t.return
  else {
    e = t
    do (t = e), t.flags & 4098 && (n = t.return), (e = t.return)
    while (e)
  }
  return t.tag === 3 ? n : null
}
function v$(e) {
  if (e.tag === 13) {
    var t = e.memoizedState
    if (
      (t === null && ((e = e.alternate), e !== null && (t = e.memoizedState)),
      t !== null)
    )
      return t.dehydrated
  }
  return null
}
function bb(e) {
  if (io(e) !== e) throw Error(z(188))
}
function y2(e) {
  var t = e.alternate
  if (!t) {
    if (((t = io(e)), t === null)) throw Error(z(188))
    return t !== e ? null : e
  }
  for (var n = e, r = t; ; ) {
    var i = n.return
    if (i === null) break
    var o = i.alternate
    if (o === null) {
      if (((r = i.return), r !== null)) {
        n = r
        continue
      }
      break
    }
    if (i.child === o.child) {
      for (o = i.child; o; ) {
        if (o === n) return bb(i), e
        if (o === r) return bb(i), t
        o = o.sibling
      }
      throw Error(z(188))
    }
    if (n.return !== r.return) (n = i), (r = o)
    else {
      for (var a = !1, s = i.child; s; ) {
        if (s === n) {
          ;(a = !0), (n = i), (r = o)
          break
        }
        if (s === r) {
          ;(a = !0), (r = i), (n = o)
          break
        }
        s = s.sibling
      }
      if (!a) {
        for (s = o.child; s; ) {
          if (s === n) {
            ;(a = !0), (n = o), (r = i)
            break
          }
          if (s === r) {
            ;(a = !0), (r = o), (n = i)
            break
          }
          s = s.sibling
        }
        if (!a) throw Error(z(189))
      }
    }
    if (n.alternate !== r) throw Error(z(190))
  }
  if (n.tag !== 3) throw Error(z(188))
  return n.stateNode.current === n ? e : t
}
function g$(e) {
  return (e = y2(e)), e !== null ? y$(e) : null
}
function y$(e) {
  if (e.tag === 5 || e.tag === 6) return e
  for (e = e.child; e !== null; ) {
    var t = y$(e)
    if (t !== null) return t
    e = e.sibling
  }
  return null
}
var b$ = Qt.unstable_scheduleCallback,
  xb = Qt.unstable_cancelCallback,
  b2 = Qt.unstable_shouldYield,
  x2 = Qt.unstable_requestPaint,
  He = Qt.unstable_now,
  w2 = Qt.unstable_getCurrentPriorityLevel,
  Bg = Qt.unstable_ImmediatePriority,
  x$ = Qt.unstable_UserBlockingPriority,
  Mc = Qt.unstable_NormalPriority,
  S2 = Qt.unstable_LowPriority,
  w$ = Qt.unstable_IdlePriority,
  sd = null,
  Wn = null
function O2(e) {
  if (Wn && typeof Wn.onCommitFiberRoot == "function")
    try {
      Wn.onCommitFiberRoot(sd, e, void 0, (e.current.flags & 128) === 128)
    } catch {}
}
var kn = Math.clz32 ? Math.clz32 : A2,
  P2 = Math.log,
  $2 = Math.LN2
function A2(e) {
  return (e >>>= 0), e === 0 ? 32 : (31 - ((P2(e) / $2) | 0)) | 0
}
var Su = 64,
  Ou = 4194304
function vs(e) {
  switch (e & -e) {
    case 1:
      return 1
    case 2:
      return 2
    case 4:
      return 4
    case 8:
      return 8
    case 16:
      return 16
    case 32:
      return 32
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424
    case 134217728:
      return 134217728
    case 268435456:
      return 268435456
    case 536870912:
      return 536870912
    case 1073741824:
      return 1073741824
    default:
      return e
  }
}
function jc(e, t) {
  var n = e.pendingLanes
  if (n === 0) return 0
  var r = 0,
    i = e.suspendedLanes,
    o = e.pingedLanes,
    a = n & 268435455
  if (a !== 0) {
    var s = a & ~i
    s !== 0 ? (r = vs(s)) : ((o &= a), o !== 0 && (r = vs(o)))
  } else (a = n & ~i), a !== 0 ? (r = vs(a)) : o !== 0 && (r = vs(o))
  if (r === 0) return 0
  if (
    t !== 0 &&
    t !== r &&
    !(t & i) &&
    ((i = r & -r), (o = t & -t), i >= o || (i === 16 && (o & 4194240) !== 0))
  )
    return t
  if ((r & 4 && (r |= n & 16), (t = e.entangledLanes), t !== 0))
    for (e = e.entanglements, t &= r; 0 < t; )
      (n = 31 - kn(t)), (i = 1 << n), (r |= e[n]), (t &= ~i)
  return r
}
function T2(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1
    default:
      return -1
  }
}
function E2(e, t) {
  for (
    var n = e.suspendedLanes,
      r = e.pingedLanes,
      i = e.expirationTimes,
      o = e.pendingLanes;
    0 < o;

  ) {
    var a = 31 - kn(o),
      s = 1 << a,
      l = i[a]
    l === -1
      ? (!(s & n) || s & r) && (i[a] = T2(s, t))
      : l <= t && (e.expiredLanes |= s),
      (o &= ~s)
  }
}
function hm(e) {
  return (
    (e = e.pendingLanes & -1073741825),
    e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
  )
}
function S$() {
  var e = Su
  return (Su <<= 1), !(Su & 4194240) && (Su = 64), e
}
function Cp(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e)
  return t
}
function ql(e, t, n) {
  ;(e.pendingLanes |= t),
    t !== 536870912 && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
    (e = e.eventTimes),
    (t = 31 - kn(t)),
    (e[t] = n)
}
function C2(e, t) {
  var n = e.pendingLanes & ~t
  ;(e.pendingLanes = t),
    (e.suspendedLanes = 0),
    (e.pingedLanes = 0),
    (e.expiredLanes &= t),
    (e.mutableReadLanes &= t),
    (e.entangledLanes &= t),
    (t = e.entanglements)
  var r = e.eventTimes
  for (e = e.expirationTimes; 0 < n; ) {
    var i = 31 - kn(n),
      o = 1 << i
    ;(t[i] = 0), (r[i] = -1), (e[i] = -1), (n &= ~o)
  }
}
function Fg(e, t) {
  var n = (e.entangledLanes |= t)
  for (e = e.entanglements; n; ) {
    var r = 31 - kn(n),
      i = 1 << r
    ;(i & t) | (e[r] & t) && (e[r] |= t), (n &= ~i)
  }
}
var ge = 0
function O$(e) {
  return (e &= -e), 1 < e ? (4 < e ? (e & 268435455 ? 16 : 536870912) : 4) : 1
}
var P$,
  Vg,
  $$,
  A$,
  T$,
  mm = !1,
  Pu = [],
  Qr = null,
  Zr = null,
  Jr = null,
  zs = new Map(),
  Us = new Map(),
  Gr = [],
  _2 =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    )
function wb(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      Qr = null
      break
    case "dragenter":
    case "dragleave":
      Zr = null
      break
    case "mouseover":
    case "mouseout":
      Jr = null
      break
    case "pointerover":
    case "pointerout":
      zs.delete(t.pointerId)
      break
    case "gotpointercapture":
    case "lostpointercapture":
      Us.delete(t.pointerId)
  }
}
function Ga(e, t, n, r, i, o) {
  return e === null || e.nativeEvent !== o
    ? ((e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: o,
        targetContainers: [i]
      }),
      t !== null && ((t = Yl(t)), t !== null && Vg(t)),
      e)
    : ((e.eventSystemFlags |= r),
      (t = e.targetContainers),
      i !== null && t.indexOf(i) === -1 && t.push(i),
      e)
}
function k2(e, t, n, r, i) {
  switch (t) {
    case "focusin":
      return (Qr = Ga(Qr, e, t, n, r, i)), !0
    case "dragenter":
      return (Zr = Ga(Zr, e, t, n, r, i)), !0
    case "mouseover":
      return (Jr = Ga(Jr, e, t, n, r, i)), !0
    case "pointerover":
      var o = i.pointerId
      return zs.set(o, Ga(zs.get(o) || null, e, t, n, r, i)), !0
    case "gotpointercapture":
      return (
        (o = i.pointerId), Us.set(o, Ga(Us.get(o) || null, e, t, n, r, i)), !0
      )
  }
  return !1
}
function E$(e) {
  var t = Ni(e.target)
  if (t !== null) {
    var n = io(t)
    if (n !== null) {
      if (((t = n.tag), t === 13)) {
        if (((t = v$(n)), t !== null)) {
          ;(e.blockedOn = t),
            T$(e.priority, function () {
              $$(n)
            })
          return
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null
        return
      }
    }
  }
  e.blockedOn = null
}
function uc(e) {
  if (e.blockedOn !== null) return !1
  for (var t = e.targetContainers; 0 < t.length; ) {
    var n = vm(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent)
    if (n === null) {
      n = e.nativeEvent
      var r = new n.constructor(n.type, n)
      ;(cm = r), n.target.dispatchEvent(r), (cm = null)
    } else return (t = Yl(n)), t !== null && Vg(t), (e.blockedOn = n), !1
    t.shift()
  }
  return !0
}
function Sb(e, t, n) {
  uc(e) && n.delete(t)
}
function M2() {
  ;(mm = !1),
    Qr !== null && uc(Qr) && (Qr = null),
    Zr !== null && uc(Zr) && (Zr = null),
    Jr !== null && uc(Jr) && (Jr = null),
    zs.forEach(Sb),
    Us.forEach(Sb)
}
function Ka(e, t) {
  e.blockedOn === t &&
    ((e.blockedOn = null),
    mm ||
      ((mm = !0), Qt.unstable_scheduleCallback(Qt.unstable_NormalPriority, M2)))
}
function Ws(e) {
  function t(i) {
    return Ka(i, e)
  }
  if (0 < Pu.length) {
    Ka(Pu[0], e)
    for (var n = 1; n < Pu.length; n++) {
      var r = Pu[n]
      r.blockedOn === e && (r.blockedOn = null)
    }
  }
  for (
    Qr !== null && Ka(Qr, e),
      Zr !== null && Ka(Zr, e),
      Jr !== null && Ka(Jr, e),
      zs.forEach(t),
      Us.forEach(t),
      n = 0;
    n < Gr.length;
    n++
  )
    (r = Gr[n]), r.blockedOn === e && (r.blockedOn = null)
  for (; 0 < Gr.length && ((n = Gr[0]), n.blockedOn === null); )
    E$(n), n.blockedOn === null && Gr.shift()
}
var Vo = Er.ReactCurrentBatchConfig,
  Dc = !0
function j2(e, t, n, r) {
  var i = ge,
    o = Vo.transition
  Vo.transition = null
  try {
    ;(ge = 1), zg(e, t, n, r)
  } finally {
    ;(ge = i), (Vo.transition = o)
  }
}
function D2(e, t, n, r) {
  var i = ge,
    o = Vo.transition
  Vo.transition = null
  try {
    ;(ge = 4), zg(e, t, n, r)
  } finally {
    ;(ge = i), (Vo.transition = o)
  }
}
function zg(e, t, n, r) {
  if (Dc) {
    var i = vm(e, t, n, r)
    if (i === null) Bp(e, t, r, Ic, n), wb(e, r)
    else if (k2(i, e, t, n, r)) r.stopPropagation()
    else if ((wb(e, r), t & 4 && -1 < _2.indexOf(e))) {
      for (; i !== null; ) {
        var o = Yl(i)
        if (
          (o !== null && P$(o),
          (o = vm(e, t, n, r)),
          o === null && Bp(e, t, r, Ic, n),
          o === i)
        )
          break
        i = o
      }
      i !== null && r.stopPropagation()
    } else Bp(e, t, r, null, n)
  }
}
var Ic = null
function vm(e, t, n, r) {
  if (((Ic = null), (e = Lg(r)), (e = Ni(e)), e !== null))
    if (((t = io(e)), t === null)) e = null
    else if (((n = t.tag), n === 13)) {
      if (((e = v$(t)), e !== null)) return e
      e = null
    } else if (n === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated)
        return t.tag === 3 ? t.stateNode.containerInfo : null
      e = null
    } else t !== e && (e = null)
  return (Ic = e), null
}
function C$(e) {
  switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4
    case "message":
      switch (w2()) {
        case Bg:
          return 1
        case x$:
          return 4
        case Mc:
        case S2:
          return 16
        case w$:
          return 536870912
        default:
          return 16
      }
    default:
      return 16
  }
}
var qr = null,
  Ug = null,
  cc = null
function _$() {
  if (cc) return cc
  var e,
    t = Ug,
    n = t.length,
    r,
    i = "value" in qr ? qr.value : qr.textContent,
    o = i.length
  for (e = 0; e < n && t[e] === i[e]; e++);
  var a = n - e
  for (r = 1; r <= a && t[n - r] === i[o - r]; r++);
  return (cc = i.slice(e, 1 < r ? 1 - r : void 0))
}
function fc(e) {
  var t = e.keyCode
  return (
    "charCode" in e
      ? ((e = e.charCode), e === 0 && t === 13 && (e = 13))
      : (e = t),
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
  )
}
function $u() {
  return !0
}
function Ob() {
  return !1
}
function tn(e) {
  function t(n, r, i, o, a) {
    ;(this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = o),
      (this.target = a),
      (this.currentTarget = null)
    for (var s in e)
      e.hasOwnProperty(s) && ((n = e[s]), (this[s] = n ? n(o) : o[s]))
    return (
      (this.isDefaultPrevented = (
        o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1
      )
        ? $u
        : Ob),
      (this.isPropagationStopped = Ob),
      this
    )
  }
  return (
    ze(t.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0
        var n = this.nativeEvent
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = $u))
      },
      stopPropagation: function () {
        var n = this.nativeEvent
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = $u))
      },
      persist: function () {},
      isPersistent: $u
    }),
    t
  )
}
var Pa = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
      return e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  Wg = tn(Pa),
  Xl = ze({}, Pa, { view: 0, detail: 0 }),
  I2 = tn(Xl),
  _p,
  kp,
  qa,
  ld = ze({}, Xl, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Hg,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
      return e.relatedTarget === void 0
        ? e.fromElement === e.srcElement
          ? e.toElement
          : e.fromElement
        : e.relatedTarget
    },
    movementX: function (e) {
      return "movementX" in e
        ? e.movementX
        : (e !== qa &&
            (qa && e.type === "mousemove"
              ? ((_p = e.screenX - qa.screenX), (kp = e.screenY - qa.screenY))
              : (kp = _p = 0),
            (qa = e)),
          _p)
    },
    movementY: function (e) {
      return "movementY" in e ? e.movementY : kp
    }
  }),
  Pb = tn(ld),
  N2 = ze({}, ld, { dataTransfer: 0 }),
  R2 = tn(N2),
  L2 = ze({}, Xl, { relatedTarget: 0 }),
  Mp = tn(L2),
  B2 = ze({}, Pa, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  F2 = tn(B2),
  V2 = ze({}, Pa, {
    clipboardData: function (e) {
      return "clipboardData" in e ? e.clipboardData : window.clipboardData
    }
  }),
  z2 = tn(V2),
  U2 = ze({}, Pa, { data: 0 }),
  $b = tn(U2),
  W2 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  H2 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  G2 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }
function K2(e) {
  var t = this.nativeEvent
  return t.getModifierState ? t.getModifierState(e) : (e = G2[e]) ? !!t[e] : !1
}
function Hg() {
  return K2
}
var q2 = ze({}, Xl, {
    key: function (e) {
      if (e.key) {
        var t = W2[e.key] || e.key
        if (t !== "Unidentified") return t
      }
      return e.type === "keypress"
        ? ((e = fc(e)), e === 13 ? "Enter" : String.fromCharCode(e))
        : e.type === "keydown" || e.type === "keyup"
          ? H2[e.keyCode] || "Unidentified"
          : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Hg,
    charCode: function (e) {
      return e.type === "keypress" ? fc(e) : 0
    },
    keyCode: function (e) {
      return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0
    },
    which: function (e) {
      return e.type === "keypress"
        ? fc(e)
        : e.type === "keydown" || e.type === "keyup"
          ? e.keyCode
          : 0
    }
  }),
  X2 = tn(q2),
  Y2 = ze({}, ld, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  Ab = tn(Y2),
  Q2 = ze({}, Xl, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Hg
  }),
  Z2 = tn(Q2),
  J2 = ze({}, Pa, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  ej = tn(J2),
  tj = ze({}, ld, {
    deltaX: function (e) {
      return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
    },
    deltaY: function (e) {
      return "deltaY" in e
        ? e.deltaY
        : "wheelDeltaY" in e
          ? -e.wheelDeltaY
          : "wheelDelta" in e
            ? -e.wheelDelta
            : 0
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  nj = tn(tj),
  rj = [9, 13, 27, 32],
  Gg = vr && "CompositionEvent" in window,
  Os = null
vr && "documentMode" in document && (Os = document.documentMode)
var ij = vr && "TextEvent" in window && !Os,
  k$ = vr && (!Gg || (Os && 8 < Os && 11 >= Os)),
  Tb = " ",
  Eb = !1
function M$(e, t) {
  switch (e) {
    case "keyup":
      return rj.indexOf(t.keyCode) !== -1
    case "keydown":
      return t.keyCode !== 229
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0
    default:
      return !1
  }
}
function j$(e) {
  return (e = e.detail), typeof e == "object" && "data" in e ? e.data : null
}
var wo = !1
function oj(e, t) {
  switch (e) {
    case "compositionend":
      return j$(t)
    case "keypress":
      return t.which !== 32 ? null : ((Eb = !0), Tb)
    case "textInput":
      return (e = t.data), e === Tb && Eb ? null : e
    default:
      return null
  }
}
function aj(e, t) {
  if (wo)
    return e === "compositionend" || (!Gg && M$(e, t))
      ? ((e = _$()), (cc = Ug = qr = null), (wo = !1), e)
      : null
  switch (e) {
    case "paste":
      return null
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || (t.ctrlKey && t.altKey)) {
        if (t.char && 1 < t.char.length) return t.char
        if (t.which) return String.fromCharCode(t.which)
      }
      return null
    case "compositionend":
      return k$ && t.locale !== "ko" ? null : t.data
    default:
      return null
  }
}
var sj = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
}
function Cb(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return t === "input" ? !!sj[e.type] : t === "textarea"
}
function D$(e, t, n, r) {
  f$(r),
    (t = Nc(t, "onChange")),
    0 < t.length &&
      ((n = new Wg("onChange", "change", null, n, r)),
      e.push({ event: n, listeners: t }))
}
var Ps = null,
  Hs = null
function lj(e) {
  H$(e, 0)
}
function ud(e) {
  var t = Po(e)
  if (i$(t)) return e
}
function uj(e, t) {
  if (e === "change") return t
}
var I$ = !1
if (vr) {
  var jp
  if (vr) {
    var Dp = "oninput" in document
    if (!Dp) {
      var _b = document.createElement("div")
      _b.setAttribute("oninput", "return;"),
        (Dp = typeof _b.oninput == "function")
    }
    jp = Dp
  } else jp = !1
  I$ = jp && (!document.documentMode || 9 < document.documentMode)
}
function kb() {
  Ps && (Ps.detachEvent("onpropertychange", N$), (Hs = Ps = null))
}
function N$(e) {
  if (e.propertyName === "value" && ud(Hs)) {
    var t = []
    D$(t, Hs, e, Lg(e)), m$(lj, t)
  }
}
function cj(e, t, n) {
  e === "focusin"
    ? (kb(), (Ps = t), (Hs = n), Ps.attachEvent("onpropertychange", N$))
    : e === "focusout" && kb()
}
function fj(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown") return ud(Hs)
}
function dj(e, t) {
  if (e === "click") return ud(t)
}
function pj(e, t) {
  if (e === "input" || e === "change") return ud(t)
}
function hj(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t)
}
var Dn = typeof Object.is == "function" ? Object.is : hj
function Gs(e, t) {
  if (Dn(e, t)) return !0
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1
  var n = Object.keys(e),
    r = Object.keys(t)
  if (n.length !== r.length) return !1
  for (r = 0; r < n.length; r++) {
    var i = n[r]
    if (!Zh.call(t, i) || !Dn(e[i], t[i])) return !1
  }
  return !0
}
function Mb(e) {
  for (; e && e.firstChild; ) e = e.firstChild
  return e
}
function jb(e, t) {
  var n = Mb(e)
  e = 0
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = e + n.textContent.length), e <= t && r >= t))
        return { node: n, offset: t - e }
      e = r
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling
          break e
        }
        n = n.parentNode
      }
      n = void 0
    }
    n = Mb(n)
  }
}
function R$(e, t) {
  return e && t
    ? e === t
      ? !0
      : e && e.nodeType === 3
        ? !1
        : t && t.nodeType === 3
          ? R$(e, t.parentNode)
          : "contains" in e
            ? e.contains(t)
            : e.compareDocumentPosition
              ? !!(e.compareDocumentPosition(t) & 16)
              : !1
    : !1
}
function L$() {
  for (var e = window, t = Cc(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var n = typeof t.contentWindow.location.href == "string"
    } catch {
      n = !1
    }
    if (n) e = t.contentWindow
    else break
    t = Cc(e.document)
  }
  return t
}
function Kg(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase()
  return (
    t &&
    ((t === "input" &&
      (e.type === "text" ||
        e.type === "search" ||
        e.type === "tel" ||
        e.type === "url" ||
        e.type === "password")) ||
      t === "textarea" ||
      e.contentEditable === "true")
  )
}
function mj(e) {
  var t = L$(),
    n = e.focusedElem,
    r = e.selectionRange
  if (
    t !== n &&
    n &&
    n.ownerDocument &&
    R$(n.ownerDocument.documentElement, n)
  ) {
    if (r !== null && Kg(n)) {
      if (
        ((t = r.start),
        (e = r.end),
        e === void 0 && (e = t),
        "selectionStart" in n)
      )
        (n.selectionStart = t), (n.selectionEnd = Math.min(e, n.value.length))
      else if (
        ((e = ((t = n.ownerDocument || document) && t.defaultView) || window),
        e.getSelection)
      ) {
        e = e.getSelection()
        var i = n.textContent.length,
          o = Math.min(r.start, i)
        ;(r = r.end === void 0 ? o : Math.min(r.end, i)),
          !e.extend && o > r && ((i = r), (r = o), (o = i)),
          (i = jb(n, o))
        var a = jb(n, r)
        i &&
          a &&
          (e.rangeCount !== 1 ||
            e.anchorNode !== i.node ||
            e.anchorOffset !== i.offset ||
            e.focusNode !== a.node ||
            e.focusOffset !== a.offset) &&
          ((t = t.createRange()),
          t.setStart(i.node, i.offset),
          e.removeAllRanges(),
          o > r
            ? (e.addRange(t), e.extend(a.node, a.offset))
            : (t.setEnd(a.node, a.offset), e.addRange(t)))
      }
    }
    for (t = [], e = n; (e = e.parentNode); )
      e.nodeType === 1 &&
        t.push({ element: e, left: e.scrollLeft, top: e.scrollTop })
    for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)
      (e = t[n]), (e.element.scrollLeft = e.left), (e.element.scrollTop = e.top)
  }
}
var vj = vr && "documentMode" in document && 11 >= document.documentMode,
  So = null,
  gm = null,
  $s = null,
  ym = !1
function Db(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument
  ym ||
    So == null ||
    So !== Cc(r) ||
    ((r = So),
    "selectionStart" in r && Kg(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset
        })),
    ($s && Gs($s, r)) ||
      (($s = r),
      (r = Nc(gm, "onSelect")),
      0 < r.length &&
        ((t = new Wg("onSelect", "select", null, t, n)),
        e.push({ event: t, listeners: r }),
        (t.target = So))))
}
function Au(e, t) {
  var n = {}
  return (
    (n[e.toLowerCase()] = t.toLowerCase()),
    (n["Webkit" + e] = "webkit" + t),
    (n["Moz" + e] = "moz" + t),
    n
  )
}
var Oo = {
    animationend: Au("Animation", "AnimationEnd"),
    animationiteration: Au("Animation", "AnimationIteration"),
    animationstart: Au("Animation", "AnimationStart"),
    transitionend: Au("Transition", "TransitionEnd")
  },
  Ip = {},
  B$ = {}
vr &&
  ((B$ = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Oo.animationend.animation,
    delete Oo.animationiteration.animation,
    delete Oo.animationstart.animation),
  "TransitionEvent" in window || delete Oo.transitionend.transition)
function cd(e) {
  if (Ip[e]) return Ip[e]
  if (!Oo[e]) return e
  var t = Oo[e],
    n
  for (n in t) if (t.hasOwnProperty(n) && n in B$) return (Ip[e] = t[n])
  return e
}
var F$ = cd("animationend"),
  V$ = cd("animationiteration"),
  z$ = cd("animationstart"),
  U$ = cd("transitionend"),
  W$ = new Map(),
  Ib =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    )
function gi(e, t) {
  W$.set(e, t), ro(t, [e])
}
for (var Np = 0; Np < Ib.length; Np++) {
  var Rp = Ib[Np],
    gj = Rp.toLowerCase(),
    yj = Rp[0].toUpperCase() + Rp.slice(1)
  gi(gj, "on" + yj)
}
gi(F$, "onAnimationEnd")
gi(V$, "onAnimationIteration")
gi(z$, "onAnimationStart")
gi("dblclick", "onDoubleClick")
gi("focusin", "onFocus")
gi("focusout", "onBlur")
gi(U$, "onTransitionEnd")
Xo("onMouseEnter", ["mouseout", "mouseover"])
Xo("onMouseLeave", ["mouseout", "mouseover"])
Xo("onPointerEnter", ["pointerout", "pointerover"])
Xo("onPointerLeave", ["pointerout", "pointerover"])
ro(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
)
ro(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
)
ro("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"])
ro(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
)
ro(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
)
ro(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
)
var gs =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  bj = new Set("cancel close invalid load scroll toggle".split(" ").concat(gs))
function Nb(e, t, n) {
  var r = e.type || "unknown-event"
  ;(e.currentTarget = n), g2(r, t, void 0, e), (e.currentTarget = null)
}
function H$(e, t) {
  t = (t & 4) !== 0
  for (var n = 0; n < e.length; n++) {
    var r = e[n],
      i = r.event
    r = r.listeners
    e: {
      var o = void 0
      if (t)
        for (var a = r.length - 1; 0 <= a; a--) {
          var s = r[a],
            l = s.instance,
            u = s.currentTarget
          if (((s = s.listener), l !== o && i.isPropagationStopped())) break e
          Nb(i, s, u), (o = l)
        }
      else
        for (a = 0; a < r.length; a++) {
          if (
            ((s = r[a]),
            (l = s.instance),
            (u = s.currentTarget),
            (s = s.listener),
            l !== o && i.isPropagationStopped())
          )
            break e
          Nb(i, s, u), (o = l)
        }
    }
  }
  if (kc) throw ((e = pm), (kc = !1), (pm = null), e)
}
function Ee(e, t) {
  var n = t[Om]
  n === void 0 && (n = t[Om] = new Set())
  var r = e + "__bubble"
  n.has(r) || (G$(t, e, 2, !1), n.add(r))
}
function Lp(e, t, n) {
  var r = 0
  t && (r |= 4), G$(n, e, r, t)
}
var Tu = "_reactListening" + Math.random().toString(36).slice(2)
function Ks(e) {
  if (!e[Tu]) {
    ;(e[Tu] = !0),
      JP.forEach(function (n) {
        n !== "selectionchange" && (bj.has(n) || Lp(n, !1, e), Lp(n, !0, e))
      })
    var t = e.nodeType === 9 ? e : e.ownerDocument
    t === null || t[Tu] || ((t[Tu] = !0), Lp("selectionchange", !1, t))
  }
}
function G$(e, t, n, r) {
  switch (C$(t)) {
    case 1:
      var i = j2
      break
    case 4:
      i = D2
      break
    default:
      i = zg
  }
  ;(n = i.bind(null, t, n, e)),
    (i = void 0),
    !dm ||
      (t !== "touchstart" && t !== "touchmove" && t !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? e.addEventListener(t, n, { capture: !0, passive: i })
        : e.addEventListener(t, n, !0)
      : i !== void 0
        ? e.addEventListener(t, n, { passive: i })
        : e.addEventListener(t, n, !1)
}
function Bp(e, t, n, r, i) {
  var o = r
  if (!(t & 1) && !(t & 2) && r !== null)
    e: for (;;) {
      if (r === null) return
      var a = r.tag
      if (a === 3 || a === 4) {
        var s = r.stateNode.containerInfo
        if (s === i || (s.nodeType === 8 && s.parentNode === i)) break
        if (a === 4)
          for (a = r.return; a !== null; ) {
            var l = a.tag
            if (
              (l === 3 || l === 4) &&
              ((l = a.stateNode.containerInfo),
              l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return
            a = a.return
          }
        for (; s !== null; ) {
          if (((a = Ni(s)), a === null)) return
          if (((l = a.tag), l === 5 || l === 6)) {
            r = o = a
            continue e
          }
          s = s.parentNode
        }
      }
      r = r.return
    }
  m$(function () {
    var u = o,
      f = Lg(n),
      c = []
    e: {
      var d = W$.get(e)
      if (d !== void 0) {
        var p = Wg,
          h = e
        switch (e) {
          case "keypress":
            if (fc(n) === 0) break e
          case "keydown":
          case "keyup":
            p = X2
            break
          case "focusin":
            ;(h = "focus"), (p = Mp)
            break
          case "focusout":
            ;(h = "blur"), (p = Mp)
            break
          case "beforeblur":
          case "afterblur":
            p = Mp
            break
          case "click":
            if (n.button === 2) break e
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            p = Pb
            break
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            p = R2
            break
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            p = Z2
            break
          case F$:
          case V$:
          case z$:
            p = F2
            break
          case U$:
            p = ej
            break
          case "scroll":
            p = I2
            break
          case "wheel":
            p = nj
            break
          case "copy":
          case "cut":
          case "paste":
            p = z2
            break
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            p = Ab
        }
        var m = (t & 4) !== 0,
          b = !m && e === "scroll",
          g = m ? (d !== null ? d + "Capture" : null) : d
        m = []
        for (var v = u, y; v !== null; ) {
          y = v
          var w = y.stateNode
          if (
            (y.tag === 5 &&
              w !== null &&
              ((y = w),
              g !== null && ((w = Vs(v, g)), w != null && m.push(qs(v, w, y)))),
            b)
          )
            break
          v = v.return
        }
        0 < m.length &&
          ((d = new p(d, h, null, n, f)), c.push({ event: d, listeners: m }))
      }
    }
    if (!(t & 7)) {
      e: {
        if (
          ((d = e === "mouseover" || e === "pointerover"),
          (p = e === "mouseout" || e === "pointerout"),
          d &&
            n !== cm &&
            (h = n.relatedTarget || n.fromElement) &&
            (Ni(h) || h[gr]))
        )
          break e
        if (
          (p || d) &&
          ((d =
            f.window === f
              ? f
              : (d = f.ownerDocument)
                ? d.defaultView || d.parentWindow
                : window),
          p
            ? ((h = n.relatedTarget || n.toElement),
              (p = u),
              (h = h ? Ni(h) : null),
              h !== null &&
                ((b = io(h)), h !== b || (h.tag !== 5 && h.tag !== 6)) &&
                (h = null))
            : ((p = null), (h = u)),
          p !== h)
        ) {
          if (
            ((m = Pb),
            (w = "onMouseLeave"),
            (g = "onMouseEnter"),
            (v = "mouse"),
            (e === "pointerout" || e === "pointerover") &&
              ((m = Ab),
              (w = "onPointerLeave"),
              (g = "onPointerEnter"),
              (v = "pointer")),
            (b = p == null ? d : Po(p)),
            (y = h == null ? d : Po(h)),
            (d = new m(w, v + "leave", p, n, f)),
            (d.target = b),
            (d.relatedTarget = y),
            (w = null),
            Ni(f) === u &&
              ((m = new m(g, v + "enter", h, n, f)),
              (m.target = y),
              (m.relatedTarget = b),
              (w = m)),
            (b = w),
            p && h)
          )
            t: {
              for (m = p, g = h, v = 0, y = m; y; y = fo(y)) v++
              for (y = 0, w = g; w; w = fo(w)) y++
              for (; 0 < v - y; ) (m = fo(m)), v--
              for (; 0 < y - v; ) (g = fo(g)), y--
              for (; v--; ) {
                if (m === g || (g !== null && m === g.alternate)) break t
                ;(m = fo(m)), (g = fo(g))
              }
              m = null
            }
          else m = null
          p !== null && Rb(c, d, p, m, !1),
            h !== null && b !== null && Rb(c, b, h, m, !0)
        }
      }
      e: {
        if (
          ((d = u ? Po(u) : window),
          (p = d.nodeName && d.nodeName.toLowerCase()),
          p === "select" || (p === "input" && d.type === "file"))
        )
          var x = uj
        else if (Cb(d))
          if (I$) x = pj
          else {
            x = fj
            var S = cj
          }
        else
          (p = d.nodeName) &&
            p.toLowerCase() === "input" &&
            (d.type === "checkbox" || d.type === "radio") &&
            (x = dj)
        if (x && (x = x(e, u))) {
          D$(c, x, n, f)
          break e
        }
        S && S(e, d, u),
          e === "focusout" &&
            (S = d._wrapperState) &&
            S.controlled &&
            d.type === "number" &&
            om(d, "number", d.value)
      }
      switch (((S = u ? Po(u) : window), e)) {
        case "focusin":
          ;(Cb(S) || S.contentEditable === "true") &&
            ((So = S), (gm = u), ($s = null))
          break
        case "focusout":
          $s = gm = So = null
          break
        case "mousedown":
          ym = !0
          break
        case "contextmenu":
        case "mouseup":
        case "dragend":
          ;(ym = !1), Db(c, n, f)
          break
        case "selectionchange":
          if (vj) break
        case "keydown":
        case "keyup":
          Db(c, n, f)
      }
      var O
      if (Gg)
        e: {
          switch (e) {
            case "compositionstart":
              var $ = "onCompositionStart"
              break e
            case "compositionend":
              $ = "onCompositionEnd"
              break e
            case "compositionupdate":
              $ = "onCompositionUpdate"
              break e
          }
          $ = void 0
        }
      else
        wo
          ? M$(e, n) && ($ = "onCompositionEnd")
          : e === "keydown" && n.keyCode === 229 && ($ = "onCompositionStart")
      $ &&
        (k$ &&
          n.locale !== "ko" &&
          (wo || $ !== "onCompositionStart"
            ? $ === "onCompositionEnd" && wo && (O = _$())
            : ((qr = f),
              (Ug = "value" in qr ? qr.value : qr.textContent),
              (wo = !0))),
        (S = Nc(u, $)),
        0 < S.length &&
          (($ = new $b($, e, null, n, f)),
          c.push({ event: $, listeners: S }),
          O ? ($.data = O) : ((O = j$(n)), O !== null && ($.data = O)))),
        (O = ij ? oj(e, n) : aj(e, n)) &&
          ((u = Nc(u, "onBeforeInput")),
          0 < u.length &&
            ((f = new $b("onBeforeInput", "beforeinput", null, n, f)),
            c.push({ event: f, listeners: u }),
            (f.data = O)))
    }
    H$(c, t)
  })
}
function qs(e, t, n) {
  return { instance: e, listener: t, currentTarget: n }
}
function Nc(e, t) {
  for (var n = t + "Capture", r = []; e !== null; ) {
    var i = e,
      o = i.stateNode
    i.tag === 5 &&
      o !== null &&
      ((i = o),
      (o = Vs(e, n)),
      o != null && r.unshift(qs(e, o, i)),
      (o = Vs(e, t)),
      o != null && r.push(qs(e, o, i))),
      (e = e.return)
  }
  return r
}
function fo(e) {
  if (e === null) return null
  do e = e.return
  while (e && e.tag !== 5)
  return e || null
}
function Rb(e, t, n, r, i) {
  for (var o = t._reactName, a = []; n !== null && n !== r; ) {
    var s = n,
      l = s.alternate,
      u = s.stateNode
    if (l !== null && l === r) break
    s.tag === 5 &&
      u !== null &&
      ((s = u),
      i
        ? ((l = Vs(n, o)), l != null && a.unshift(qs(n, l, s)))
        : i || ((l = Vs(n, o)), l != null && a.push(qs(n, l, s)))),
      (n = n.return)
  }
  a.length !== 0 && e.push({ event: t, listeners: a })
}
var xj = /\r\n?/g,
  wj = /\u0000|\uFFFD/g
function Lb(e) {
  return (typeof e == "string" ? e : "" + e)
    .replace(
      xj,
      `
`
    )
    .replace(wj, "")
}
function Eu(e, t, n) {
  if (((t = Lb(t)), Lb(e) !== t && n)) throw Error(z(425))
}
function Rc() {}
var bm = null,
  xm = null
function wm(e, t) {
  return (
    e === "textarea" ||
    e === "noscript" ||
    typeof t.children == "string" ||
    typeof t.children == "number" ||
    (typeof t.dangerouslySetInnerHTML == "object" &&
      t.dangerouslySetInnerHTML !== null &&
      t.dangerouslySetInnerHTML.__html != null)
  )
}
var Sm = typeof setTimeout == "function" ? setTimeout : void 0,
  Sj = typeof clearTimeout == "function" ? clearTimeout : void 0,
  Bb = typeof Promise == "function" ? Promise : void 0,
  Oj =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof Bb < "u"
        ? function (e) {
            return Bb.resolve(null).then(e).catch(Pj)
          }
        : Sm
function Pj(e) {
  setTimeout(function () {
    throw e
  })
}
function Fp(e, t) {
  var n = t,
    r = 0
  do {
    var i = n.nextSibling
    if ((e.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === "/$")) {
        if (r === 0) {
          e.removeChild(i), Ws(t)
          return
        }
        r--
      } else (n !== "$" && n !== "$?" && n !== "$!") || r++
    n = i
  } while (n)
  Ws(t)
}
function ei(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType
    if (t === 1 || t === 3) break
    if (t === 8) {
      if (((t = e.data), t === "$" || t === "$!" || t === "$?")) break
      if (t === "/$") return null
    }
  }
  return e
}
function Fb(e) {
  e = e.previousSibling
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data
      if (n === "$" || n === "$!" || n === "$?") {
        if (t === 0) return e
        t--
      } else n === "/$" && t++
    }
    e = e.previousSibling
  }
  return null
}
var $a = Math.random().toString(36).slice(2),
  Vn = "__reactFiber$" + $a,
  Xs = "__reactProps$" + $a,
  gr = "__reactContainer$" + $a,
  Om = "__reactEvents$" + $a,
  $j = "__reactListeners$" + $a,
  Aj = "__reactHandles$" + $a
function Ni(e) {
  var t = e[Vn]
  if (t) return t
  for (var n = e.parentNode; n; ) {
    if ((t = n[gr] || n[Vn])) {
      if (
        ((n = t.alternate),
        t.child !== null || (n !== null && n.child !== null))
      )
        for (e = Fb(e); e !== null; ) {
          if ((n = e[Vn])) return n
          e = Fb(e)
        }
      return t
    }
    ;(e = n), (n = e.parentNode)
  }
  return null
}
function Yl(e) {
  return (
    (e = e[Vn] || e[gr]),
    !e || (e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3) ? null : e
  )
}
function Po(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode
  throw Error(z(33))
}
function fd(e) {
  return e[Xs] || null
}
var Pm = [],
  $o = -1
function yi(e) {
  return { current: e }
}
function ke(e) {
  0 > $o || ((e.current = Pm[$o]), (Pm[$o] = null), $o--)
}
function Ae(e, t) {
  $o++, (Pm[$o] = e.current), (e.current = t)
}
var ci = {},
  Tt = yi(ci),
  Bt = yi(!1),
  Yi = ci
function Yo(e, t) {
  var n = e.type.contextTypes
  if (!n) return ci
  var r = e.stateNode
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
    return r.__reactInternalMemoizedMaskedChildContext
  var i = {},
    o
  for (o in n) i[o] = t[o]
  return (
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = t),
      (e.__reactInternalMemoizedMaskedChildContext = i)),
    i
  )
}
function Ft(e) {
  return (e = e.childContextTypes), e != null
}
function Lc() {
  ke(Bt), ke(Tt)
}
function Vb(e, t, n) {
  if (Tt.current !== ci) throw Error(z(168))
  Ae(Tt, t), Ae(Bt, n)
}
function K$(e, t, n) {
  var r = e.stateNode
  if (((t = t.childContextTypes), typeof r.getChildContext != "function"))
    return n
  r = r.getChildContext()
  for (var i in r) if (!(i in t)) throw Error(z(108, c2(e) || "Unknown", i))
  return ze({}, n, r)
}
function Bc(e) {
  return (
    (e =
      ((e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext) || ci),
    (Yi = Tt.current),
    Ae(Tt, e),
    Ae(Bt, Bt.current),
    !0
  )
}
function zb(e, t, n) {
  var r = e.stateNode
  if (!r) throw Error(z(169))
  n
    ? ((e = K$(e, t, Yi)),
      (r.__reactInternalMemoizedMergedChildContext = e),
      ke(Bt),
      ke(Tt),
      Ae(Tt, e))
    : ke(Bt),
    Ae(Bt, n)
}
var or = null,
  dd = !1,
  Vp = !1
function q$(e) {
  or === null ? (or = [e]) : or.push(e)
}
function Tj(e) {
  ;(dd = !0), q$(e)
}
function bi() {
  if (!Vp && or !== null) {
    Vp = !0
    var e = 0,
      t = ge
    try {
      var n = or
      for (ge = 1; e < n.length; e++) {
        var r = n[e]
        do r = r(!0)
        while (r !== null)
      }
      ;(or = null), (dd = !1)
    } catch (i) {
      throw (or !== null && (or = or.slice(e + 1)), b$(Bg, bi), i)
    } finally {
      ;(ge = t), (Vp = !1)
    }
  }
  return null
}
var Ao = [],
  To = 0,
  Fc = null,
  Vc = 0,
  un = [],
  cn = 0,
  Qi = null,
  ar = 1,
  sr = ""
function Ci(e, t) {
  ;(Ao[To++] = Vc), (Ao[To++] = Fc), (Fc = e), (Vc = t)
}
function X$(e, t, n) {
  ;(un[cn++] = ar), (un[cn++] = sr), (un[cn++] = Qi), (Qi = e)
  var r = ar
  e = sr
  var i = 32 - kn(r) - 1
  ;(r &= ~(1 << i)), (n += 1)
  var o = 32 - kn(t) + i
  if (30 < o) {
    var a = i - (i % 5)
    ;(o = (r & ((1 << a) - 1)).toString(32)),
      (r >>= a),
      (i -= a),
      (ar = (1 << (32 - kn(t) + i)) | (n << i) | r),
      (sr = o + e)
  } else (ar = (1 << o) | (n << i) | r), (sr = e)
}
function qg(e) {
  e.return !== null && (Ci(e, 1), X$(e, 1, 0))
}
function Xg(e) {
  for (; e === Fc; )
    (Fc = Ao[--To]), (Ao[To] = null), (Vc = Ao[--To]), (Ao[To] = null)
  for (; e === Qi; )
    (Qi = un[--cn]),
      (un[cn] = null),
      (sr = un[--cn]),
      (un[cn] = null),
      (ar = un[--cn]),
      (un[cn] = null)
}
var Xt = null,
  qt = null,
  De = !1,
  En = null
function Y$(e, t) {
  var n = dn(5, null, null, 0)
  ;(n.elementType = "DELETED"),
    (n.stateNode = t),
    (n.return = e),
    (t = e.deletions),
    t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)
}
function Ub(e, t) {
  switch (e.tag) {
    case 5:
      var n = e.type
      return (
        (t =
          t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase()
            ? null
            : t),
        t !== null
          ? ((e.stateNode = t), (Xt = e), (qt = ei(t.firstChild)), !0)
          : !1
      )
    case 6:
      return (
        (t = e.pendingProps === "" || t.nodeType !== 3 ? null : t),
        t !== null ? ((e.stateNode = t), (Xt = e), (qt = null), !0) : !1
      )
    case 13:
      return (
        (t = t.nodeType !== 8 ? null : t),
        t !== null
          ? ((n = Qi !== null ? { id: ar, overflow: sr } : null),
            (e.memoizedState = {
              dehydrated: t,
              treeContext: n,
              retryLane: 1073741824
            }),
            (n = dn(18, null, null, 0)),
            (n.stateNode = t),
            (n.return = e),
            (e.child = n),
            (Xt = e),
            (qt = null),
            !0)
          : !1
      )
    default:
      return !1
  }
}
function $m(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0
}
function Am(e) {
  if (De) {
    var t = qt
    if (t) {
      var n = t
      if (!Ub(e, t)) {
        if ($m(e)) throw Error(z(418))
        t = ei(n.nextSibling)
        var r = Xt
        t && Ub(e, t)
          ? Y$(r, n)
          : ((e.flags = (e.flags & -4097) | 2), (De = !1), (Xt = e))
      }
    } else {
      if ($m(e)) throw Error(z(418))
      ;(e.flags = (e.flags & -4097) | 2), (De = !1), (Xt = e)
    }
  }
}
function Wb(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
    e = e.return
  Xt = e
}
function Cu(e) {
  if (e !== Xt) return !1
  if (!De) return Wb(e), (De = !0), !1
  var t
  if (
    ((t = e.tag !== 3) &&
      !(t = e.tag !== 5) &&
      ((t = e.type),
      (t = t !== "head" && t !== "body" && !wm(e.type, e.memoizedProps))),
    t && (t = qt))
  ) {
    if ($m(e)) throw (Q$(), Error(z(418)))
    for (; t; ) Y$(e, t), (t = ei(t.nextSibling))
  }
  if ((Wb(e), e.tag === 13)) {
    if (((e = e.memoizedState), (e = e !== null ? e.dehydrated : null), !e))
      throw Error(z(317))
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var n = e.data
          if (n === "/$") {
            if (t === 0) {
              qt = ei(e.nextSibling)
              break e
            }
            t--
          } else (n !== "$" && n !== "$!" && n !== "$?") || t++
        }
        e = e.nextSibling
      }
      qt = null
    }
  } else qt = Xt ? ei(e.stateNode.nextSibling) : null
  return !0
}
function Q$() {
  for (var e = qt; e; ) e = ei(e.nextSibling)
}
function Qo() {
  ;(qt = Xt = null), (De = !1)
}
function Yg(e) {
  En === null ? (En = [e]) : En.push(e)
}
var Ej = Er.ReactCurrentBatchConfig
function $n(e, t) {
  if (e && e.defaultProps) {
    ;(t = ze({}, t)), (e = e.defaultProps)
    for (var n in e) t[n] === void 0 && (t[n] = e[n])
    return t
  }
  return t
}
var zc = yi(null),
  Uc = null,
  Eo = null,
  Qg = null
function Zg() {
  Qg = Eo = Uc = null
}
function Jg(e) {
  var t = zc.current
  ke(zc), (e._currentValue = t)
}
function Tm(e, t, n) {
  for (; e !== null; ) {
    var r = e.alternate
    if (
      ((e.childLanes & t) !== t
        ? ((e.childLanes |= t), r !== null && (r.childLanes |= t))
        : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t),
      e === n)
    )
      break
    e = e.return
  }
}
function zo(e, t) {
  ;(Uc = e),
    (Qg = Eo = null),
    (e = e.dependencies),
    e !== null &&
      e.firstContext !== null &&
      (e.lanes & t && (Rt = !0), (e.firstContext = null))
}
function vn(e) {
  var t = e._currentValue
  if (Qg !== e)
    if (((e = { context: e, memoizedValue: t, next: null }), Eo === null)) {
      if (Uc === null) throw Error(z(308))
      ;(Eo = e), (Uc.dependencies = { lanes: 0, firstContext: e })
    } else Eo = Eo.next = e
  return t
}
var Ri = null
function ey(e) {
  Ri === null ? (Ri = [e]) : Ri.push(e)
}
function Z$(e, t, n, r) {
  var i = t.interleaved
  return (
    i === null ? ((n.next = n), ey(t)) : ((n.next = i.next), (i.next = n)),
    (t.interleaved = n),
    yr(e, r)
  )
}
function yr(e, t) {
  e.lanes |= t
  var n = e.alternate
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null; )
    (e.childLanes |= t),
      (n = e.alternate),
      n !== null && (n.childLanes |= t),
      (n = e),
      (e = e.return)
  return n.tag === 3 ? n.stateNode : null
}
var Ur = !1
function ty(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null
  }
}
function J$(e, t) {
  ;(e = e.updateQueue),
    t.updateQueue === e &&
      (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects
      })
}
function dr(e, t) {
  return {
    eventTime: e,
    lane: t,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  }
}
function ti(e, t, n) {
  var r = e.updateQueue
  if (r === null) return null
  if (((r = r.shared), fe & 2)) {
    var i = r.pending
    return (
      i === null ? (t.next = t) : ((t.next = i.next), (i.next = t)),
      (r.pending = t),
      yr(e, n)
    )
  }
  return (
    (i = r.interleaved),
    i === null ? ((t.next = t), ey(r)) : ((t.next = i.next), (i.next = t)),
    (r.interleaved = t),
    yr(e, n)
  )
}
function dc(e, t, n) {
  if (
    ((t = t.updateQueue), t !== null && ((t = t.shared), (n & 4194240) !== 0))
  ) {
    var r = t.lanes
    ;(r &= e.pendingLanes), (n |= r), (t.lanes = n), Fg(e, n)
  }
}
function Hb(e, t) {
  var n = e.updateQueue,
    r = e.alternate
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      o = null
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var a = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null
        }
        o === null ? (i = o = a) : (o = o.next = a), (n = n.next)
      } while (n !== null)
      o === null ? (i = o = t) : (o = o.next = t)
    } else i = o = t
    ;(n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: o,
      shared: r.shared,
      effects: r.effects
    }),
      (e.updateQueue = n)
    return
  }
  ;(e = n.lastBaseUpdate),
    e === null ? (n.firstBaseUpdate = t) : (e.next = t),
    (n.lastBaseUpdate = t)
}
function Wc(e, t, n, r) {
  var i = e.updateQueue
  Ur = !1
  var o = i.firstBaseUpdate,
    a = i.lastBaseUpdate,
    s = i.shared.pending
  if (s !== null) {
    i.shared.pending = null
    var l = s,
      u = l.next
    ;(l.next = null), a === null ? (o = u) : (a.next = u), (a = l)
    var f = e.alternate
    f !== null &&
      ((f = f.updateQueue),
      (s = f.lastBaseUpdate),
      s !== a &&
        (s === null ? (f.firstBaseUpdate = u) : (s.next = u),
        (f.lastBaseUpdate = l)))
  }
  if (o !== null) {
    var c = i.baseState
    ;(a = 0), (f = u = l = null), (s = o)
    do {
      var d = s.lane,
        p = s.eventTime
      if ((r & d) === d) {
        f !== null &&
          (f = f.next =
            {
              eventTime: p,
              lane: 0,
              tag: s.tag,
              payload: s.payload,
              callback: s.callback,
              next: null
            })
        e: {
          var h = e,
            m = s
          switch (((d = t), (p = n), m.tag)) {
            case 1:
              if (((h = m.payload), typeof h == "function")) {
                c = h.call(p, c, d)
                break e
              }
              c = h
              break e
            case 3:
              h.flags = (h.flags & -65537) | 128
            case 0:
              if (
                ((h = m.payload),
                (d = typeof h == "function" ? h.call(p, c, d) : h),
                d == null)
              )
                break e
              c = ze({}, c, d)
              break e
            case 2:
              Ur = !0
          }
        }
        s.callback !== null &&
          s.lane !== 0 &&
          ((e.flags |= 64),
          (d = i.effects),
          d === null ? (i.effects = [s]) : d.push(s))
      } else
        (p = {
          eventTime: p,
          lane: d,
          tag: s.tag,
          payload: s.payload,
          callback: s.callback,
          next: null
        }),
          f === null ? ((u = f = p), (l = c)) : (f = f.next = p),
          (a |= d)
      if (((s = s.next), s === null)) {
        if (((s = i.shared.pending), s === null)) break
        ;(d = s),
          (s = d.next),
          (d.next = null),
          (i.lastBaseUpdate = d),
          (i.shared.pending = null)
      }
    } while (!0)
    if (
      (f === null && (l = c),
      (i.baseState = l),
      (i.firstBaseUpdate = u),
      (i.lastBaseUpdate = f),
      (t = i.shared.interleaved),
      t !== null)
    ) {
      i = t
      do (a |= i.lane), (i = i.next)
      while (i !== t)
    } else o === null && (i.shared.lanes = 0)
    ;(Ji |= a), (e.lanes = a), (e.memoizedState = c)
  }
}
function Gb(e, t, n) {
  if (((e = t.effects), (t.effects = null), e !== null))
    for (t = 0; t < e.length; t++) {
      var r = e[t],
        i = r.callback
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != "function"))
          throw Error(z(191, i))
        i.call(r)
      }
    }
}
var eA = new ZP.Component().refs
function Em(e, t, n, r) {
  ;(t = e.memoizedState),
    (n = n(r, t)),
    (n = n == null ? t : ze({}, t, n)),
    (e.memoizedState = n),
    e.lanes === 0 && (e.updateQueue.baseState = n)
}
var pd = {
  isMounted: function (e) {
    return (e = e._reactInternals) ? io(e) === e : !1
  },
  enqueueSetState: function (e, t, n) {
    e = e._reactInternals
    var r = Mt(),
      i = ri(e),
      o = dr(r, i)
    ;(o.payload = t),
      n != null && (o.callback = n),
      (t = ti(e, o, i)),
      t !== null && (Mn(t, e, i, r), dc(t, e, i))
  },
  enqueueReplaceState: function (e, t, n) {
    e = e._reactInternals
    var r = Mt(),
      i = ri(e),
      o = dr(r, i)
    ;(o.tag = 1),
      (o.payload = t),
      n != null && (o.callback = n),
      (t = ti(e, o, i)),
      t !== null && (Mn(t, e, i, r), dc(t, e, i))
  },
  enqueueForceUpdate: function (e, t) {
    e = e._reactInternals
    var n = Mt(),
      r = ri(e),
      i = dr(n, r)
    ;(i.tag = 2),
      t != null && (i.callback = t),
      (t = ti(e, i, r)),
      t !== null && (Mn(t, e, r, n), dc(t, e, r))
  }
}
function Kb(e, t, n, r, i, o, a) {
  return (
    (e = e.stateNode),
    typeof e.shouldComponentUpdate == "function"
      ? e.shouldComponentUpdate(r, o, a)
      : t.prototype && t.prototype.isPureReactComponent
        ? !Gs(n, r) || !Gs(i, o)
        : !0
  )
}
function tA(e, t, n) {
  var r = !1,
    i = ci,
    o = t.contextType
  return (
    typeof o == "object" && o !== null
      ? (o = vn(o))
      : ((i = Ft(t) ? Yi : Tt.current),
        (r = t.contextTypes),
        (o = (r = r != null) ? Yo(e, i) : ci)),
    (t = new t(n, o)),
    (e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null),
    (t.updater = pd),
    (e.stateNode = t),
    (t._reactInternals = e),
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = i),
      (e.__reactInternalMemoizedMaskedChildContext = o)),
    t
  )
}
function qb(e, t, n, r) {
  ;(e = t.state),
    typeof t.componentWillReceiveProps == "function" &&
      t.componentWillReceiveProps(n, r),
    typeof t.UNSAFE_componentWillReceiveProps == "function" &&
      t.UNSAFE_componentWillReceiveProps(n, r),
    t.state !== e && pd.enqueueReplaceState(t, t.state, null)
}
function Cm(e, t, n, r) {
  var i = e.stateNode
  ;(i.props = n), (i.state = e.memoizedState), (i.refs = eA), ty(e)
  var o = t.contextType
  typeof o == "object" && o !== null
    ? (i.context = vn(o))
    : ((o = Ft(t) ? Yi : Tt.current), (i.context = Yo(e, o))),
    (i.state = e.memoizedState),
    (o = t.getDerivedStateFromProps),
    typeof o == "function" && (Em(e, t, o, n), (i.state = e.memoizedState)),
    typeof t.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((t = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      t !== i.state && pd.enqueueReplaceState(i, i.state, null),
      Wc(e, n, i, r),
      (i.state = e.memoizedState)),
    typeof i.componentDidMount == "function" && (e.flags |= 4194308)
}
function Xa(e, t, n) {
  if (
    ((e = n.ref), e !== null && typeof e != "function" && typeof e != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(z(309))
        var r = n.stateNode
      }
      if (!r) throw Error(z(147, e))
      var i = r,
        o = "" + e
      return t !== null &&
        t.ref !== null &&
        typeof t.ref == "function" &&
        t.ref._stringRef === o
        ? t.ref
        : ((t = function (a) {
            var s = i.refs
            s === eA && (s = i.refs = {}), a === null ? delete s[o] : (s[o] = a)
          }),
          (t._stringRef = o),
          t)
    }
    if (typeof e != "string") throw Error(z(284))
    if (!n._owner) throw Error(z(290, e))
  }
  return e
}
function _u(e, t) {
  throw (
    ((e = Object.prototype.toString.call(t)),
    Error(
      z(
        31,
        e === "[object Object]"
          ? "object with keys {" + Object.keys(t).join(", ") + "}"
          : e
      )
    ))
  )
}
function Xb(e) {
  var t = e._init
  return t(e._payload)
}
function nA(e) {
  function t(g, v) {
    if (e) {
      var y = g.deletions
      y === null ? ((g.deletions = [v]), (g.flags |= 16)) : y.push(v)
    }
  }
  function n(g, v) {
    if (!e) return null
    for (; v !== null; ) t(g, v), (v = v.sibling)
    return null
  }
  function r(g, v) {
    for (g = new Map(); v !== null; )
      v.key !== null ? g.set(v.key, v) : g.set(v.index, v), (v = v.sibling)
    return g
  }
  function i(g, v) {
    return (g = ii(g, v)), (g.index = 0), (g.sibling = null), g
  }
  function o(g, v, y) {
    return (
      (g.index = y),
      e
        ? ((y = g.alternate),
          y !== null
            ? ((y = y.index), y < v ? ((g.flags |= 2), v) : y)
            : ((g.flags |= 2), v))
        : ((g.flags |= 1048576), v)
    )
  }
  function a(g) {
    return e && g.alternate === null && (g.flags |= 2), g
  }
  function s(g, v, y, w) {
    return v === null || v.tag !== 6
      ? ((v = qp(y, g.mode, w)), (v.return = g), v)
      : ((v = i(v, y)), (v.return = g), v)
  }
  function l(g, v, y, w) {
    var x = y.type
    return x === xo
      ? f(g, v, y.props.children, w, y.key)
      : v !== null &&
          (v.elementType === x ||
            (typeof x == "object" &&
              x !== null &&
              x.$$typeof === zr &&
              Xb(x) === v.type))
        ? ((w = i(v, y.props)), (w.ref = Xa(g, v, y)), (w.return = g), w)
        : ((w = yc(y.type, y.key, y.props, null, g.mode, w)),
          (w.ref = Xa(g, v, y)),
          (w.return = g),
          w)
  }
  function u(g, v, y, w) {
    return v === null ||
      v.tag !== 4 ||
      v.stateNode.containerInfo !== y.containerInfo ||
      v.stateNode.implementation !== y.implementation
      ? ((v = Xp(y, g.mode, w)), (v.return = g), v)
      : ((v = i(v, y.children || [])), (v.return = g), v)
  }
  function f(g, v, y, w, x) {
    return v === null || v.tag !== 7
      ? ((v = Hi(y, g.mode, w, x)), (v.return = g), v)
      : ((v = i(v, y)), (v.return = g), v)
  }
  function c(g, v, y) {
    if ((typeof v == "string" && v !== "") || typeof v == "number")
      return (v = qp("" + v, g.mode, y)), (v.return = g), v
    if (typeof v == "object" && v !== null) {
      switch (v.$$typeof) {
        case bu:
          return (
            (y = yc(v.type, v.key, v.props, null, g.mode, y)),
            (y.ref = Xa(g, null, v)),
            (y.return = g),
            y
          )
        case bo:
          return (v = Xp(v, g.mode, y)), (v.return = g), v
        case zr:
          var w = v._init
          return c(g, w(v._payload), y)
      }
      if (ms(v) || Wa(v)) return (v = Hi(v, g.mode, y, null)), (v.return = g), v
      _u(g, v)
    }
    return null
  }
  function d(g, v, y, w) {
    var x = v !== null ? v.key : null
    if ((typeof y == "string" && y !== "") || typeof y == "number")
      return x !== null ? null : s(g, v, "" + y, w)
    if (typeof y == "object" && y !== null) {
      switch (y.$$typeof) {
        case bu:
          return y.key === x ? l(g, v, y, w) : null
        case bo:
          return y.key === x ? u(g, v, y, w) : null
        case zr:
          return (x = y._init), d(g, v, x(y._payload), w)
      }
      if (ms(y) || Wa(y)) return x !== null ? null : f(g, v, y, w, null)
      _u(g, y)
    }
    return null
  }
  function p(g, v, y, w, x) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return (g = g.get(y) || null), s(v, g, "" + w, x)
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case bu:
          return (g = g.get(w.key === null ? y : w.key) || null), l(v, g, w, x)
        case bo:
          return (g = g.get(w.key === null ? y : w.key) || null), u(v, g, w, x)
        case zr:
          var S = w._init
          return p(g, v, y, S(w._payload), x)
      }
      if (ms(w) || Wa(w)) return (g = g.get(y) || null), f(v, g, w, x, null)
      _u(v, w)
    }
    return null
  }
  function h(g, v, y, w) {
    for (
      var x = null, S = null, O = v, $ = (v = 0), A = null;
      O !== null && $ < y.length;
      $++
    ) {
      O.index > $ ? ((A = O), (O = null)) : (A = O.sibling)
      var C = d(g, O, y[$], w)
      if (C === null) {
        O === null && (O = A)
        break
      }
      e && O && C.alternate === null && t(g, O),
        (v = o(C, v, $)),
        S === null ? (x = C) : (S.sibling = C),
        (S = C),
        (O = A)
    }
    if ($ === y.length) return n(g, O), De && Ci(g, $), x
    if (O === null) {
      for (; $ < y.length; $++)
        (O = c(g, y[$], w)),
          O !== null &&
            ((v = o(O, v, $)), S === null ? (x = O) : (S.sibling = O), (S = O))
      return De && Ci(g, $), x
    }
    for (O = r(g, O); $ < y.length; $++)
      (A = p(O, g, $, y[$], w)),
        A !== null &&
          (e && A.alternate !== null && O.delete(A.key === null ? $ : A.key),
          (v = o(A, v, $)),
          S === null ? (x = A) : (S.sibling = A),
          (S = A))
    return (
      e &&
        O.forEach(function (T) {
          return t(g, T)
        }),
      De && Ci(g, $),
      x
    )
  }
  function m(g, v, y, w) {
    var x = Wa(y)
    if (typeof x != "function") throw Error(z(150))
    if (((y = x.call(y)), y == null)) throw Error(z(151))
    for (
      var S = (x = null), O = v, $ = (v = 0), A = null, C = y.next();
      O !== null && !C.done;
      $++, C = y.next()
    ) {
      O.index > $ ? ((A = O), (O = null)) : (A = O.sibling)
      var T = d(g, O, C.value, w)
      if (T === null) {
        O === null && (O = A)
        break
      }
      e && O && T.alternate === null && t(g, O),
        (v = o(T, v, $)),
        S === null ? (x = T) : (S.sibling = T),
        (S = T),
        (O = A)
    }
    if (C.done) return n(g, O), De && Ci(g, $), x
    if (O === null) {
      for (; !C.done; $++, C = y.next())
        (C = c(g, C.value, w)),
          C !== null &&
            ((v = o(C, v, $)), S === null ? (x = C) : (S.sibling = C), (S = C))
      return De && Ci(g, $), x
    }
    for (O = r(g, O); !C.done; $++, C = y.next())
      (C = p(O, g, $, C.value, w)),
        C !== null &&
          (e && C.alternate !== null && O.delete(C.key === null ? $ : C.key),
          (v = o(C, v, $)),
          S === null ? (x = C) : (S.sibling = C),
          (S = C))
    return (
      e &&
        O.forEach(function (_) {
          return t(g, _)
        }),
      De && Ci(g, $),
      x
    )
  }
  function b(g, v, y, w) {
    if (
      (typeof y == "object" &&
        y !== null &&
        y.type === xo &&
        y.key === null &&
        (y = y.props.children),
      typeof y == "object" && y !== null)
    ) {
      switch (y.$$typeof) {
        case bu:
          e: {
            for (var x = y.key, S = v; S !== null; ) {
              if (S.key === x) {
                if (((x = y.type), x === xo)) {
                  if (S.tag === 7) {
                    n(g, S.sibling),
                      (v = i(S, y.props.children)),
                      (v.return = g),
                      (g = v)
                    break e
                  }
                } else if (
                  S.elementType === x ||
                  (typeof x == "object" &&
                    x !== null &&
                    x.$$typeof === zr &&
                    Xb(x) === S.type)
                ) {
                  n(g, S.sibling),
                    (v = i(S, y.props)),
                    (v.ref = Xa(g, S, y)),
                    (v.return = g),
                    (g = v)
                  break e
                }
                n(g, S)
                break
              } else t(g, S)
              S = S.sibling
            }
            y.type === xo
              ? ((v = Hi(y.props.children, g.mode, w, y.key)),
                (v.return = g),
                (g = v))
              : ((w = yc(y.type, y.key, y.props, null, g.mode, w)),
                (w.ref = Xa(g, v, y)),
                (w.return = g),
                (g = w))
          }
          return a(g)
        case bo:
          e: {
            for (S = y.key; v !== null; ) {
              if (v.key === S)
                if (
                  v.tag === 4 &&
                  v.stateNode.containerInfo === y.containerInfo &&
                  v.stateNode.implementation === y.implementation
                ) {
                  n(g, v.sibling),
                    (v = i(v, y.children || [])),
                    (v.return = g),
                    (g = v)
                  break e
                } else {
                  n(g, v)
                  break
                }
              else t(g, v)
              v = v.sibling
            }
            ;(v = Xp(y, g.mode, w)), (v.return = g), (g = v)
          }
          return a(g)
        case zr:
          return (S = y._init), b(g, v, S(y._payload), w)
      }
      if (ms(y)) return h(g, v, y, w)
      if (Wa(y)) return m(g, v, y, w)
      _u(g, y)
    }
    return (typeof y == "string" && y !== "") || typeof y == "number"
      ? ((y = "" + y),
        v !== null && v.tag === 6
          ? (n(g, v.sibling), (v = i(v, y)), (v.return = g), (g = v))
          : (n(g, v), (v = qp(y, g.mode, w)), (v.return = g), (g = v)),
        a(g))
      : n(g, v)
  }
  return b
}
var Zo = nA(!0),
  rA = nA(!1),
  Ql = {},
  Hn = yi(Ql),
  Ys = yi(Ql),
  Qs = yi(Ql)
function Li(e) {
  if (e === Ql) throw Error(z(174))
  return e
}
function ny(e, t) {
  switch ((Ae(Qs, t), Ae(Ys, e), Ae(Hn, Ql), (e = t.nodeType), e)) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : sm(null, "")
      break
    default:
      ;(e = e === 8 ? t.parentNode : t),
        (t = e.namespaceURI || null),
        (e = e.tagName),
        (t = sm(t, e))
  }
  ke(Hn), Ae(Hn, t)
}
function Jo() {
  ke(Hn), ke(Ys), ke(Qs)
}
function iA(e) {
  Li(Qs.current)
  var t = Li(Hn.current),
    n = sm(t, e.type)
  t !== n && (Ae(Ys, e), Ae(Hn, n))
}
function ry(e) {
  Ys.current === e && (ke(Hn), ke(Ys))
}
var Le = yi(0)
function Hc(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var n = t.memoizedState
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return t
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t
    } else if (t.child !== null) {
      ;(t.child.return = t), (t = t.child)
      continue
    }
    if (t === e) break
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null
      t = t.return
    }
    ;(t.sibling.return = t.return), (t = t.sibling)
  }
  return null
}
var zp = []
function iy() {
  for (var e = 0; e < zp.length; e++) zp[e]._workInProgressVersionPrimary = null
  zp.length = 0
}
var pc = Er.ReactCurrentDispatcher,
  Up = Er.ReactCurrentBatchConfig,
  Zi = 0,
  Ve = null,
  nt = null,
  ut = null,
  Gc = !1,
  As = !1,
  Zs = 0,
  Cj = 0
function wt() {
  throw Error(z(321))
}
function oy(e, t) {
  if (t === null) return !1
  for (var n = 0; n < t.length && n < e.length; n++)
    if (!Dn(e[n], t[n])) return !1
  return !0
}
function ay(e, t, n, r, i, o) {
  if (
    ((Zi = o),
    (Ve = t),
    (t.memoizedState = null),
    (t.updateQueue = null),
    (t.lanes = 0),
    (pc.current = e === null || e.memoizedState === null ? jj : Dj),
    (e = n(r, i)),
    As)
  ) {
    o = 0
    do {
      if (((As = !1), (Zs = 0), 25 <= o)) throw Error(z(301))
      ;(o += 1),
        (ut = nt = null),
        (t.updateQueue = null),
        (pc.current = Ij),
        (e = n(r, i))
    } while (As)
  }
  if (
    ((pc.current = Kc),
    (t = nt !== null && nt.next !== null),
    (Zi = 0),
    (ut = nt = Ve = null),
    (Gc = !1),
    t)
  )
    throw Error(z(300))
  return e
}
function sy() {
  var e = Zs !== 0
  return (Zs = 0), e
}
function Fn() {
  var e = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  }
  return ut === null ? (Ve.memoizedState = ut = e) : (ut = ut.next = e), ut
}
function gn() {
  if (nt === null) {
    var e = Ve.alternate
    e = e !== null ? e.memoizedState : null
  } else e = nt.next
  var t = ut === null ? Ve.memoizedState : ut.next
  if (t !== null) (ut = t), (nt = e)
  else {
    if (e === null) throw Error(z(310))
    ;(nt = e),
      (e = {
        memoizedState: nt.memoizedState,
        baseState: nt.baseState,
        baseQueue: nt.baseQueue,
        queue: nt.queue,
        next: null
      }),
      ut === null ? (Ve.memoizedState = ut = e) : (ut = ut.next = e)
  }
  return ut
}
function Js(e, t) {
  return typeof t == "function" ? t(e) : t
}
function Wp(e) {
  var t = gn(),
    n = t.queue
  if (n === null) throw Error(z(311))
  n.lastRenderedReducer = e
  var r = nt,
    i = r.baseQueue,
    o = n.pending
  if (o !== null) {
    if (i !== null) {
      var a = i.next
      ;(i.next = o.next), (o.next = a)
    }
    ;(r.baseQueue = i = o), (n.pending = null)
  }
  if (i !== null) {
    ;(o = i.next), (r = r.baseState)
    var s = (a = null),
      l = null,
      u = o
    do {
      var f = u.lane
      if ((Zi & f) === f)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: u.action,
              hasEagerState: u.hasEagerState,
              eagerState: u.eagerState,
              next: null
            }),
          (r = u.hasEagerState ? u.eagerState : e(r, u.action))
      else {
        var c = {
          lane: f,
          action: u.action,
          hasEagerState: u.hasEagerState,
          eagerState: u.eagerState,
          next: null
        }
        l === null ? ((s = l = c), (a = r)) : (l = l.next = c),
          (Ve.lanes |= f),
          (Ji |= f)
      }
      u = u.next
    } while (u !== null && u !== o)
    l === null ? (a = r) : (l.next = s),
      Dn(r, t.memoizedState) || (Rt = !0),
      (t.memoizedState = r),
      (t.baseState = a),
      (t.baseQueue = l),
      (n.lastRenderedState = r)
  }
  if (((e = n.interleaved), e !== null)) {
    i = e
    do (o = i.lane), (Ve.lanes |= o), (Ji |= o), (i = i.next)
    while (i !== e)
  } else i === null && (n.lanes = 0)
  return [t.memoizedState, n.dispatch]
}
function Hp(e) {
  var t = gn(),
    n = t.queue
  if (n === null) throw Error(z(311))
  n.lastRenderedReducer = e
  var r = n.dispatch,
    i = n.pending,
    o = t.memoizedState
  if (i !== null) {
    n.pending = null
    var a = (i = i.next)
    do (o = e(o, a.action)), (a = a.next)
    while (a !== i)
    Dn(o, t.memoizedState) || (Rt = !0),
      (t.memoizedState = o),
      t.baseQueue === null && (t.baseState = o),
      (n.lastRenderedState = o)
  }
  return [o, r]
}
function oA() {}
function aA(e, t) {
  var n = Ve,
    r = gn(),
    i = t(),
    o = !Dn(r.memoizedState, i)
  if (
    (o && ((r.memoizedState = i), (Rt = !0)),
    (r = r.queue),
    ly(uA.bind(null, n, r, e), [e]),
    r.getSnapshot !== t || o || (ut !== null && ut.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      el(9, lA.bind(null, n, r, i, t), void 0, null),
      ft === null)
    )
      throw Error(z(349))
    Zi & 30 || sA(n, t, i)
  }
  return i
}
function sA(e, t, n) {
  ;(e.flags |= 16384),
    (e = { getSnapshot: t, value: n }),
    (t = Ve.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (Ve.updateQueue = t),
        (t.stores = [e]))
      : ((n = t.stores), n === null ? (t.stores = [e]) : n.push(e))
}
function lA(e, t, n, r) {
  ;(t.value = n), (t.getSnapshot = r), cA(t) && fA(e)
}
function uA(e, t, n) {
  return n(function () {
    cA(t) && fA(e)
  })
}
function cA(e) {
  var t = e.getSnapshot
  e = e.value
  try {
    var n = t()
    return !Dn(e, n)
  } catch {
    return !0
  }
}
function fA(e) {
  var t = yr(e, 1)
  t !== null && Mn(t, e, 1, -1)
}
function Yb(e) {
  var t = Fn()
  return (
    typeof e == "function" && (e = e()),
    (t.memoizedState = t.baseState = e),
    (e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Js,
      lastRenderedState: e
    }),
    (t.queue = e),
    (e = e.dispatch = Mj.bind(null, Ve, e)),
    [t.memoizedState, e]
  )
}
function el(e, t, n, r) {
  return (
    (e = { tag: e, create: t, destroy: n, deps: r, next: null }),
    (t = Ve.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (Ve.updateQueue = t),
        (t.lastEffect = e.next = e))
      : ((n = t.lastEffect),
        n === null
          ? (t.lastEffect = e.next = e)
          : ((r = n.next), (n.next = e), (e.next = r), (t.lastEffect = e))),
    e
  )
}
function dA() {
  return gn().memoizedState
}
function hc(e, t, n, r) {
  var i = Fn()
  ;(Ve.flags |= e),
    (i.memoizedState = el(1 | t, n, void 0, r === void 0 ? null : r))
}
function hd(e, t, n, r) {
  var i = gn()
  r = r === void 0 ? null : r
  var o = void 0
  if (nt !== null) {
    var a = nt.memoizedState
    if (((o = a.destroy), r !== null && oy(r, a.deps))) {
      i.memoizedState = el(t, n, o, r)
      return
    }
  }
  ;(Ve.flags |= e), (i.memoizedState = el(1 | t, n, o, r))
}
function Qb(e, t) {
  return hc(8390656, 8, e, t)
}
function ly(e, t) {
  return hd(2048, 8, e, t)
}
function pA(e, t) {
  return hd(4, 2, e, t)
}
function hA(e, t) {
  return hd(4, 4, e, t)
}
function mA(e, t) {
  if (typeof t == "function")
    return (
      (e = e()),
      t(e),
      function () {
        t(null)
      }
    )
  if (t != null)
    return (
      (e = e()),
      (t.current = e),
      function () {
        t.current = null
      }
    )
}
function vA(e, t, n) {
  return (
    (n = n != null ? n.concat([e]) : null), hd(4, 4, mA.bind(null, t, e), n)
  )
}
function uy() {}
function gA(e, t) {
  var n = gn()
  t = t === void 0 ? null : t
  var r = n.memoizedState
  return r !== null && t !== null && oy(t, r[1])
    ? r[0]
    : ((n.memoizedState = [e, t]), e)
}
function yA(e, t) {
  var n = gn()
  t = t === void 0 ? null : t
  var r = n.memoizedState
  return r !== null && t !== null && oy(t, r[1])
    ? r[0]
    : ((e = e()), (n.memoizedState = [e, t]), e)
}
function bA(e, t, n) {
  return Zi & 21
    ? (Dn(n, t) || ((n = S$()), (Ve.lanes |= n), (Ji |= n), (e.baseState = !0)),
      t)
    : (e.baseState && ((e.baseState = !1), (Rt = !0)), (e.memoizedState = n))
}
function _j(e, t) {
  var n = ge
  ;(ge = n !== 0 && 4 > n ? n : 4), e(!0)
  var r = Up.transition
  Up.transition = {}
  try {
    e(!1), t()
  } finally {
    ;(ge = n), (Up.transition = r)
  }
}
function xA() {
  return gn().memoizedState
}
function kj(e, t, n) {
  var r = ri(e)
  if (
    ((n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }),
    wA(e))
  )
    SA(t, n)
  else if (((n = Z$(e, t, n, r)), n !== null)) {
    var i = Mt()
    Mn(n, e, r, i), OA(n, t, r)
  }
}
function Mj(e, t, n) {
  var r = ri(e),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }
  if (wA(e)) SA(t, i)
  else {
    var o = e.alternate
    if (
      e.lanes === 0 &&
      (o === null || o.lanes === 0) &&
      ((o = t.lastRenderedReducer), o !== null)
    )
      try {
        var a = t.lastRenderedState,
          s = o(a, n)
        if (((i.hasEagerState = !0), (i.eagerState = s), Dn(s, a))) {
          var l = t.interleaved
          l === null
            ? ((i.next = i), ey(t))
            : ((i.next = l.next), (l.next = i)),
            (t.interleaved = i)
          return
        }
      } catch {
      } finally {
      }
    ;(n = Z$(e, t, i, r)),
      n !== null && ((i = Mt()), Mn(n, e, r, i), OA(n, t, r))
  }
}
function wA(e) {
  var t = e.alternate
  return e === Ve || (t !== null && t === Ve)
}
function SA(e, t) {
  As = Gc = !0
  var n = e.pending
  n === null ? (t.next = t) : ((t.next = n.next), (n.next = t)), (e.pending = t)
}
function OA(e, t, n) {
  if (n & 4194240) {
    var r = t.lanes
    ;(r &= e.pendingLanes), (n |= r), (t.lanes = n), Fg(e, n)
  }
}
var Kc = {
    readContext: vn,
    useCallback: wt,
    useContext: wt,
    useEffect: wt,
    useImperativeHandle: wt,
    useInsertionEffect: wt,
    useLayoutEffect: wt,
    useMemo: wt,
    useReducer: wt,
    useRef: wt,
    useState: wt,
    useDebugValue: wt,
    useDeferredValue: wt,
    useTransition: wt,
    useMutableSource: wt,
    useSyncExternalStore: wt,
    useId: wt,
    unstable_isNewReconciler: !1
  },
  jj = {
    readContext: vn,
    useCallback: function (e, t) {
      return (Fn().memoizedState = [e, t === void 0 ? null : t]), e
    },
    useContext: vn,
    useEffect: Qb,
    useImperativeHandle: function (e, t, n) {
      return (
        (n = n != null ? n.concat([e]) : null),
        hc(4194308, 4, mA.bind(null, t, e), n)
      )
    },
    useLayoutEffect: function (e, t) {
      return hc(4194308, 4, e, t)
    },
    useInsertionEffect: function (e, t) {
      return hc(4, 2, e, t)
    },
    useMemo: function (e, t) {
      var n = Fn()
      return (
        (t = t === void 0 ? null : t), (e = e()), (n.memoizedState = [e, t]), e
      )
    },
    useReducer: function (e, t, n) {
      var r = Fn()
      return (
        (t = n !== void 0 ? n(t) : t),
        (r.memoizedState = r.baseState = t),
        (e = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: e,
          lastRenderedState: t
        }),
        (r.queue = e),
        (e = e.dispatch = kj.bind(null, Ve, e)),
        [r.memoizedState, e]
      )
    },
    useRef: function (e) {
      var t = Fn()
      return (e = { current: e }), (t.memoizedState = e)
    },
    useState: Yb,
    useDebugValue: uy,
    useDeferredValue: function (e) {
      return (Fn().memoizedState = e)
    },
    useTransition: function () {
      var e = Yb(!1),
        t = e[0]
      return (e = _j.bind(null, e[1])), (Fn().memoizedState = e), [t, e]
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (e, t, n) {
      var r = Ve,
        i = Fn()
      if (De) {
        if (n === void 0) throw Error(z(407))
        n = n()
      } else {
        if (((n = t()), ft === null)) throw Error(z(349))
        Zi & 30 || sA(r, t, n)
      }
      i.memoizedState = n
      var o = { value: n, getSnapshot: t }
      return (
        (i.queue = o),
        Qb(uA.bind(null, r, o, e), [e]),
        (r.flags |= 2048),
        el(9, lA.bind(null, r, o, n, t), void 0, null),
        n
      )
    },
    useId: function () {
      var e = Fn(),
        t = ft.identifierPrefix
      if (De) {
        var n = sr,
          r = ar
        ;(n = (r & ~(1 << (32 - kn(r) - 1))).toString(32) + n),
          (t = ":" + t + "R" + n),
          (n = Zs++),
          0 < n && (t += "H" + n.toString(32)),
          (t += ":")
      } else (n = Cj++), (t = ":" + t + "r" + n.toString(32) + ":")
      return (e.memoizedState = t)
    },
    unstable_isNewReconciler: !1
  },
  Dj = {
    readContext: vn,
    useCallback: gA,
    useContext: vn,
    useEffect: ly,
    useImperativeHandle: vA,
    useInsertionEffect: pA,
    useLayoutEffect: hA,
    useMemo: yA,
    useReducer: Wp,
    useRef: dA,
    useState: function () {
      return Wp(Js)
    },
    useDebugValue: uy,
    useDeferredValue: function (e) {
      var t = gn()
      return bA(t, nt.memoizedState, e)
    },
    useTransition: function () {
      var e = Wp(Js)[0],
        t = gn().memoizedState
      return [e, t]
    },
    useMutableSource: oA,
    useSyncExternalStore: aA,
    useId: xA,
    unstable_isNewReconciler: !1
  },
  Ij = {
    readContext: vn,
    useCallback: gA,
    useContext: vn,
    useEffect: ly,
    useImperativeHandle: vA,
    useInsertionEffect: pA,
    useLayoutEffect: hA,
    useMemo: yA,
    useReducer: Hp,
    useRef: dA,
    useState: function () {
      return Hp(Js)
    },
    useDebugValue: uy,
    useDeferredValue: function (e) {
      var t = gn()
      return nt === null ? (t.memoizedState = e) : bA(t, nt.memoizedState, e)
    },
    useTransition: function () {
      var e = Hp(Js)[0],
        t = gn().memoizedState
      return [e, t]
    },
    useMutableSource: oA,
    useSyncExternalStore: aA,
    useId: xA,
    unstable_isNewReconciler: !1
  }
function ea(e, t) {
  try {
    var n = "",
      r = t
    do (n += u2(r)), (r = r.return)
    while (r)
    var i = n
  } catch (o) {
    i =
      `
Error generating stack: ` +
      o.message +
      `
` +
      o.stack
  }
  return { value: e, source: t, stack: i, digest: null }
}
function Gp(e, t, n) {
  return { value: e, source: null, stack: n ?? null, digest: t ?? null }
}
function _m(e, t) {
  try {
    console.error(t.value)
  } catch (n) {
    setTimeout(function () {
      throw n
    })
  }
}
var Nj = typeof WeakMap == "function" ? WeakMap : Map
function PA(e, t, n) {
  ;(n = dr(-1, n)), (n.tag = 3), (n.payload = { element: null })
  var r = t.value
  return (
    (n.callback = function () {
      Xc || ((Xc = !0), (Fm = r)), _m(e, t)
    }),
    n
  )
}
function $A(e, t, n) {
  ;(n = dr(-1, n)), (n.tag = 3)
  var r = e.type.getDerivedStateFromError
  if (typeof r == "function") {
    var i = t.value
    ;(n.payload = function () {
      return r(i)
    }),
      (n.callback = function () {
        _m(e, t)
      })
  }
  var o = e.stateNode
  return (
    o !== null &&
      typeof o.componentDidCatch == "function" &&
      (n.callback = function () {
        _m(e, t),
          typeof r != "function" &&
            (ni === null ? (ni = new Set([this])) : ni.add(this))
        var a = t.stack
        this.componentDidCatch(t.value, { componentStack: a !== null ? a : "" })
      }),
    n
  )
}
function Zb(e, t, n) {
  var r = e.pingCache
  if (r === null) {
    r = e.pingCache = new Nj()
    var i = new Set()
    r.set(t, i)
  } else (i = r.get(t)), i === void 0 && ((i = new Set()), r.set(t, i))
  i.has(n) || (i.add(n), (e = Yj.bind(null, e, t, n)), t.then(e, e))
}
function Jb(e) {
  do {
    var t
    if (
      ((t = e.tag === 13) &&
        ((t = e.memoizedState), (t = t !== null ? t.dehydrated !== null : !0)),
      t)
    )
      return e
    e = e.return
  } while (e !== null)
  return null
}
function e1(e, t, n, r, i) {
  return e.mode & 1
    ? ((e.flags |= 65536), (e.lanes = i), e)
    : (e === t
        ? (e.flags |= 65536)
        : ((e.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((t = dr(-1, 1)), (t.tag = 2), ti(n, t, 1))),
          (n.lanes |= 1)),
      e)
}
var Rj = Er.ReactCurrentOwner,
  Rt = !1
function _t(e, t, n, r) {
  t.child = e === null ? rA(t, null, n, r) : Zo(t, e.child, n, r)
}
function t1(e, t, n, r, i) {
  n = n.render
  var o = t.ref
  return (
    zo(t, i),
    (r = ay(e, t, n, r, o, i)),
    (n = sy()),
    e !== null && !Rt
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~i),
        br(e, t, i))
      : (De && n && qg(t), (t.flags |= 1), _t(e, t, r, i), t.child)
  )
}
function n1(e, t, n, r, i) {
  if (e === null) {
    var o = n.type
    return typeof o == "function" &&
      !gy(o) &&
      o.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((t.tag = 15), (t.type = o), AA(e, t, o, r, i))
      : ((e = yc(n.type, null, r, t, t.mode, i)),
        (e.ref = t.ref),
        (e.return = t),
        (t.child = e))
  }
  if (((o = e.child), !(e.lanes & i))) {
    var a = o.memoizedProps
    if (
      ((n = n.compare), (n = n !== null ? n : Gs), n(a, r) && e.ref === t.ref)
    )
      return br(e, t, i)
  }
  return (
    (t.flags |= 1),
    (e = ii(o, r)),
    (e.ref = t.ref),
    (e.return = t),
    (t.child = e)
  )
}
function AA(e, t, n, r, i) {
  if (e !== null) {
    var o = e.memoizedProps
    if (Gs(o, r) && e.ref === t.ref)
      if (((Rt = !1), (t.pendingProps = r = o), (e.lanes & i) !== 0))
        e.flags & 131072 && (Rt = !0)
      else return (t.lanes = e.lanes), br(e, t, i)
  }
  return km(e, t, n, r, i)
}
function TA(e, t, n) {
  var r = t.pendingProps,
    i = r.children,
    o = e !== null ? e.memoizedState : null
  if (r.mode === "hidden")
    if (!(t.mode & 1))
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        Ae(_o, Ht),
        (Ht |= n)
    else {
      if (!(n & 1073741824))
        return (
          (e = o !== null ? o.baseLanes | n : n),
          (t.lanes = t.childLanes = 1073741824),
          (t.memoizedState = {
            baseLanes: e,
            cachePool: null,
            transitions: null
          }),
          (t.updateQueue = null),
          Ae(_o, Ht),
          (Ht |= e),
          null
        )
      ;(t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = o !== null ? o.baseLanes : n),
        Ae(_o, Ht),
        (Ht |= r)
    }
  else
    o !== null ? ((r = o.baseLanes | n), (t.memoizedState = null)) : (r = n),
      Ae(_o, Ht),
      (Ht |= r)
  return _t(e, t, i, n), t.child
}
function EA(e, t) {
  var n = t.ref
  ;((e === null && n !== null) || (e !== null && e.ref !== n)) &&
    ((t.flags |= 512), (t.flags |= 2097152))
}
function km(e, t, n, r, i) {
  var o = Ft(n) ? Yi : Tt.current
  return (
    (o = Yo(t, o)),
    zo(t, i),
    (n = ay(e, t, n, r, o, i)),
    (r = sy()),
    e !== null && !Rt
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~i),
        br(e, t, i))
      : (De && r && qg(t), (t.flags |= 1), _t(e, t, n, i), t.child)
  )
}
function r1(e, t, n, r, i) {
  if (Ft(n)) {
    var o = !0
    Bc(t)
  } else o = !1
  if ((zo(t, i), t.stateNode === null))
    mc(e, t), tA(t, n, r), Cm(t, n, r, i), (r = !0)
  else if (e === null) {
    var a = t.stateNode,
      s = t.memoizedProps
    a.props = s
    var l = a.context,
      u = n.contextType
    typeof u == "object" && u !== null
      ? (u = vn(u))
      : ((u = Ft(n) ? Yi : Tt.current), (u = Yo(t, u)))
    var f = n.getDerivedStateFromProps,
      c =
        typeof f == "function" || typeof a.getSnapshotBeforeUpdate == "function"
    c ||
      (typeof a.UNSAFE_componentWillReceiveProps != "function" &&
        typeof a.componentWillReceiveProps != "function") ||
      ((s !== r || l !== u) && qb(t, a, r, u)),
      (Ur = !1)
    var d = t.memoizedState
    ;(a.state = d),
      Wc(t, r, a, i),
      (l = t.memoizedState),
      s !== r || d !== l || Bt.current || Ur
        ? (typeof f == "function" && (Em(t, n, f, r), (l = t.memoizedState)),
          (s = Ur || Kb(t, n, s, r, d, l, u))
            ? (c ||
                (typeof a.UNSAFE_componentWillMount != "function" &&
                  typeof a.componentWillMount != "function") ||
                (typeof a.componentWillMount == "function" &&
                  a.componentWillMount(),
                typeof a.UNSAFE_componentWillMount == "function" &&
                  a.UNSAFE_componentWillMount()),
              typeof a.componentDidMount == "function" && (t.flags |= 4194308))
            : (typeof a.componentDidMount == "function" && (t.flags |= 4194308),
              (t.memoizedProps = r),
              (t.memoizedState = l)),
          (a.props = r),
          (a.state = l),
          (a.context = u),
          (r = s))
        : (typeof a.componentDidMount == "function" && (t.flags |= 4194308),
          (r = !1))
  } else {
    ;(a = t.stateNode),
      J$(e, t),
      (s = t.memoizedProps),
      (u = t.type === t.elementType ? s : $n(t.type, s)),
      (a.props = u),
      (c = t.pendingProps),
      (d = a.context),
      (l = n.contextType),
      typeof l == "object" && l !== null
        ? (l = vn(l))
        : ((l = Ft(n) ? Yi : Tt.current), (l = Yo(t, l)))
    var p = n.getDerivedStateFromProps
    ;(f =
      typeof p == "function" ||
      typeof a.getSnapshotBeforeUpdate == "function") ||
      (typeof a.UNSAFE_componentWillReceiveProps != "function" &&
        typeof a.componentWillReceiveProps != "function") ||
      ((s !== c || d !== l) && qb(t, a, r, l)),
      (Ur = !1),
      (d = t.memoizedState),
      (a.state = d),
      Wc(t, r, a, i)
    var h = t.memoizedState
    s !== c || d !== h || Bt.current || Ur
      ? (typeof p == "function" && (Em(t, n, p, r), (h = t.memoizedState)),
        (u = Ur || Kb(t, n, u, r, d, h, l) || !1)
          ? (f ||
              (typeof a.UNSAFE_componentWillUpdate != "function" &&
                typeof a.componentWillUpdate != "function") ||
              (typeof a.componentWillUpdate == "function" &&
                a.componentWillUpdate(r, h, l),
              typeof a.UNSAFE_componentWillUpdate == "function" &&
                a.UNSAFE_componentWillUpdate(r, h, l)),
            typeof a.componentDidUpdate == "function" && (t.flags |= 4),
            typeof a.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024))
          : (typeof a.componentDidUpdate != "function" ||
              (s === e.memoizedProps && d === e.memoizedState) ||
              (t.flags |= 4),
            typeof a.getSnapshotBeforeUpdate != "function" ||
              (s === e.memoizedProps && d === e.memoizedState) ||
              (t.flags |= 1024),
            (t.memoizedProps = r),
            (t.memoizedState = h)),
        (a.props = r),
        (a.state = h),
        (a.context = l),
        (r = u))
      : (typeof a.componentDidUpdate != "function" ||
          (s === e.memoizedProps && d === e.memoizedState) ||
          (t.flags |= 4),
        typeof a.getSnapshotBeforeUpdate != "function" ||
          (s === e.memoizedProps && d === e.memoizedState) ||
          (t.flags |= 1024),
        (r = !1))
  }
  return Mm(e, t, n, r, o, i)
}
function Mm(e, t, n, r, i, o) {
  EA(e, t)
  var a = (t.flags & 128) !== 0
  if (!r && !a) return i && zb(t, n, !1), br(e, t, o)
  ;(r = t.stateNode), (Rj.current = t)
  var s =
    a && typeof n.getDerivedStateFromError != "function" ? null : r.render()
  return (
    (t.flags |= 1),
    e !== null && a
      ? ((t.child = Zo(t, e.child, null, o)), (t.child = Zo(t, null, s, o)))
      : _t(e, t, s, o),
    (t.memoizedState = r.state),
    i && zb(t, n, !0),
    t.child
  )
}
function CA(e) {
  var t = e.stateNode
  t.pendingContext
    ? Vb(e, t.pendingContext, t.pendingContext !== t.context)
    : t.context && Vb(e, t.context, !1),
    ny(e, t.containerInfo)
}
function i1(e, t, n, r, i) {
  return Qo(), Yg(i), (t.flags |= 256), _t(e, t, n, r), t.child
}
var jm = { dehydrated: null, treeContext: null, retryLane: 0 }
function Dm(e) {
  return { baseLanes: e, cachePool: null, transitions: null }
}
function _A(e, t, n) {
  var r = t.pendingProps,
    i = Le.current,
    o = !1,
    a = (t.flags & 128) !== 0,
    s
  if (
    ((s = a) ||
      (s = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0),
    s
      ? ((o = !0), (t.flags &= -129))
      : (e === null || e.memoizedState !== null) && (i |= 1),
    Ae(Le, i & 1),
    e === null)
  )
    return (
      Am(t),
      (e = t.memoizedState),
      e !== null && ((e = e.dehydrated), e !== null)
        ? (t.mode & 1
            ? e.data === "$!"
              ? (t.lanes = 8)
              : (t.lanes = 1073741824)
            : (t.lanes = 1),
          null)
        : ((a = r.children),
          (e = r.fallback),
          o
            ? ((r = t.mode),
              (o = t.child),
              (a = { mode: "hidden", children: a }),
              !(r & 1) && o !== null
                ? ((o.childLanes = 0), (o.pendingProps = a))
                : (o = gd(a, r, 0, null)),
              (e = Hi(e, r, n, null)),
              (o.return = t),
              (e.return = t),
              (o.sibling = e),
              (t.child = o),
              (t.child.memoizedState = Dm(n)),
              (t.memoizedState = jm),
              e)
            : cy(t, a))
    )
  if (((i = e.memoizedState), i !== null && ((s = i.dehydrated), s !== null)))
    return Lj(e, t, a, r, s, i, n)
  if (o) {
    ;(o = r.fallback), (a = t.mode), (i = e.child), (s = i.sibling)
    var l = { mode: "hidden", children: r.children }
    return (
      !(a & 1) && t.child !== i
        ? ((r = t.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (t.deletions = null))
        : ((r = ii(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      s !== null ? (o = ii(s, o)) : ((o = Hi(o, a, n, null)), (o.flags |= 2)),
      (o.return = t),
      (r.return = t),
      (r.sibling = o),
      (t.child = r),
      (r = o),
      (o = t.child),
      (a = e.child.memoizedState),
      (a =
        a === null
          ? Dm(n)
          : {
              baseLanes: a.baseLanes | n,
              cachePool: null,
              transitions: a.transitions
            }),
      (o.memoizedState = a),
      (o.childLanes = e.childLanes & ~n),
      (t.memoizedState = jm),
      r
    )
  }
  return (
    (o = e.child),
    (e = o.sibling),
    (r = ii(o, { mode: "visible", children: r.children })),
    !(t.mode & 1) && (r.lanes = n),
    (r.return = t),
    (r.sibling = null),
    e !== null &&
      ((n = t.deletions),
      n === null ? ((t.deletions = [e]), (t.flags |= 16)) : n.push(e)),
    (t.child = r),
    (t.memoizedState = null),
    r
  )
}
function cy(e, t) {
  return (
    (t = gd({ mode: "visible", children: t }, e.mode, 0, null)),
    (t.return = e),
    (e.child = t)
  )
}
function ku(e, t, n, r) {
  return (
    r !== null && Yg(r),
    Zo(t, e.child, null, n),
    (e = cy(t, t.pendingProps.children)),
    (e.flags |= 2),
    (t.memoizedState = null),
    e
  )
}
function Lj(e, t, n, r, i, o, a) {
  if (n)
    return t.flags & 256
      ? ((t.flags &= -257), (r = Gp(Error(z(422)))), ku(e, t, a, r))
      : t.memoizedState !== null
        ? ((t.child = e.child), (t.flags |= 128), null)
        : ((o = r.fallback),
          (i = t.mode),
          (r = gd({ mode: "visible", children: r.children }, i, 0, null)),
          (o = Hi(o, i, a, null)),
          (o.flags |= 2),
          (r.return = t),
          (o.return = t),
          (r.sibling = o),
          (t.child = r),
          t.mode & 1 && Zo(t, e.child, null, a),
          (t.child.memoizedState = Dm(a)),
          (t.memoizedState = jm),
          o)
  if (!(t.mode & 1)) return ku(e, t, a, null)
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var s = r.dgst
    return (r = s), (o = Error(z(419))), (r = Gp(o, r, void 0)), ku(e, t, a, r)
  }
  if (((s = (a & e.childLanes) !== 0), Rt || s)) {
    if (((r = ft), r !== null)) {
      switch (a & -a) {
        case 4:
          i = 2
          break
        case 16:
          i = 8
          break
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32
          break
        case 536870912:
          i = 268435456
          break
        default:
          i = 0
      }
      ;(i = i & (r.suspendedLanes | a) ? 0 : i),
        i !== 0 &&
          i !== o.retryLane &&
          ((o.retryLane = i), yr(e, i), Mn(r, e, i, -1))
    }
    return vy(), (r = Gp(Error(z(421)))), ku(e, t, a, r)
  }
  return i.data === "$?"
    ? ((t.flags |= 128),
      (t.child = e.child),
      (t = Qj.bind(null, e)),
      (i._reactRetry = t),
      null)
    : ((e = o.treeContext),
      (qt = ei(i.nextSibling)),
      (Xt = t),
      (De = !0),
      (En = null),
      e !== null &&
        ((un[cn++] = ar),
        (un[cn++] = sr),
        (un[cn++] = Qi),
        (ar = e.id),
        (sr = e.overflow),
        (Qi = t)),
      (t = cy(t, r.children)),
      (t.flags |= 4096),
      t)
}
function o1(e, t, n) {
  e.lanes |= t
  var r = e.alternate
  r !== null && (r.lanes |= t), Tm(e.return, t, n)
}
function Kp(e, t, n, r, i) {
  var o = e.memoizedState
  o === null
    ? (e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i
      })
    : ((o.isBackwards = t),
      (o.rendering = null),
      (o.renderingStartTime = 0),
      (o.last = r),
      (o.tail = n),
      (o.tailMode = i))
}
function kA(e, t, n) {
  var r = t.pendingProps,
    i = r.revealOrder,
    o = r.tail
  if ((_t(e, t, r.children, n), (r = Le.current), r & 2))
    (r = (r & 1) | 2), (t.flags |= 128)
  else {
    if (e !== null && e.flags & 128)
      e: for (e = t.child; e !== null; ) {
        if (e.tag === 13) e.memoizedState !== null && o1(e, n, t)
        else if (e.tag === 19) o1(e, n, t)
        else if (e.child !== null) {
          ;(e.child.return = e), (e = e.child)
          continue
        }
        if (e === t) break e
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) break e
          e = e.return
        }
        ;(e.sibling.return = e.return), (e = e.sibling)
      }
    r &= 1
  }
  if ((Ae(Le, r), !(t.mode & 1))) t.memoizedState = null
  else
    switch (i) {
      case "forwards":
        for (n = t.child, i = null; n !== null; )
          (e = n.alternate),
            e !== null && Hc(e) === null && (i = n),
            (n = n.sibling)
        ;(n = i),
          n === null
            ? ((i = t.child), (t.child = null))
            : ((i = n.sibling), (n.sibling = null)),
          Kp(t, !1, i, n, o)
        break
      case "backwards":
        for (n = null, i = t.child, t.child = null; i !== null; ) {
          if (((e = i.alternate), e !== null && Hc(e) === null)) {
            t.child = i
            break
          }
          ;(e = i.sibling), (i.sibling = n), (n = i), (i = e)
        }
        Kp(t, !0, n, null, o)
        break
      case "together":
        Kp(t, !1, null, null, void 0)
        break
      default:
        t.memoizedState = null
    }
  return t.child
}
function mc(e, t) {
  !(t.mode & 1) &&
    e !== null &&
    ((e.alternate = null), (t.alternate = null), (t.flags |= 2))
}
function br(e, t, n) {
  if (
    (e !== null && (t.dependencies = e.dependencies),
    (Ji |= t.lanes),
    !(n & t.childLanes))
  )
    return null
  if (e !== null && t.child !== e.child) throw Error(z(153))
  if (t.child !== null) {
    for (
      e = t.child, n = ii(e, e.pendingProps), t.child = n, n.return = t;
      e.sibling !== null;

    )
      (e = e.sibling), (n = n.sibling = ii(e, e.pendingProps)), (n.return = t)
    n.sibling = null
  }
  return t.child
}
function Bj(e, t, n) {
  switch (t.tag) {
    case 3:
      CA(t), Qo()
      break
    case 5:
      iA(t)
      break
    case 1:
      Ft(t.type) && Bc(t)
      break
    case 4:
      ny(t, t.stateNode.containerInfo)
      break
    case 10:
      var r = t.type._context,
        i = t.memoizedProps.value
      Ae(zc, r._currentValue), (r._currentValue = i)
      break
    case 13:
      if (((r = t.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (Ae(Le, Le.current & 1), (t.flags |= 128), null)
          : n & t.child.childLanes
            ? _A(e, t, n)
            : (Ae(Le, Le.current & 1),
              (e = br(e, t, n)),
              e !== null ? e.sibling : null)
      Ae(Le, Le.current & 1)
      break
    case 19:
      if (((r = (n & t.childLanes) !== 0), e.flags & 128)) {
        if (r) return kA(e, t, n)
        t.flags |= 128
      }
      if (
        ((i = t.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        Ae(Le, Le.current),
        r)
      )
        break
      return null
    case 22:
    case 23:
      return (t.lanes = 0), TA(e, t, n)
  }
  return br(e, t, n)
}
var MA, Im, jA, DA
MA = function (e, t) {
  for (var n = t.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode)
    else if (n.tag !== 4 && n.child !== null) {
      ;(n.child.return = n), (n = n.child)
      continue
    }
    if (n === t) break
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === t) return
      n = n.return
    }
    ;(n.sibling.return = n.return), (n = n.sibling)
  }
}
Im = function () {}
jA = function (e, t, n, r) {
  var i = e.memoizedProps
  if (i !== r) {
    ;(e = t.stateNode), Li(Hn.current)
    var o = null
    switch (n) {
      case "input":
        ;(i = rm(e, i)), (r = rm(e, r)), (o = [])
        break
      case "select":
        ;(i = ze({}, i, { value: void 0 })),
          (r = ze({}, r, { value: void 0 })),
          (o = [])
        break
      case "textarea":
        ;(i = am(e, i)), (r = am(e, r)), (o = [])
        break
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (e.onclick = Rc)
    }
    lm(n, r)
    var a
    n = null
    for (u in i)
      if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null)
        if (u === "style") {
          var s = i[u]
          for (a in s) s.hasOwnProperty(a) && (n || (n = {}), (n[a] = ""))
        } else
          u !== "dangerouslySetInnerHTML" &&
            u !== "children" &&
            u !== "suppressContentEditableWarning" &&
            u !== "suppressHydrationWarning" &&
            u !== "autoFocus" &&
            (Bs.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null))
    for (u in r) {
      var l = r[u]
      if (
        ((s = i != null ? i[u] : void 0),
        r.hasOwnProperty(u) && l !== s && (l != null || s != null))
      )
        if (u === "style")
          if (s) {
            for (a in s)
              !s.hasOwnProperty(a) ||
                (l && l.hasOwnProperty(a)) ||
                (n || (n = {}), (n[a] = ""))
            for (a in l)
              l.hasOwnProperty(a) &&
                s[a] !== l[a] &&
                (n || (n = {}), (n[a] = l[a]))
          } else n || (o || (o = []), o.push(u, n)), (n = l)
        else
          u === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (s = s ? s.__html : void 0),
              l != null && s !== l && (o = o || []).push(u, l))
            : u === "children"
              ? (typeof l != "string" && typeof l != "number") ||
                (o = o || []).push(u, "" + l)
              : u !== "suppressContentEditableWarning" &&
                u !== "suppressHydrationWarning" &&
                (Bs.hasOwnProperty(u)
                  ? (l != null && u === "onScroll" && Ee("scroll", e),
                    o || s === l || (o = []))
                  : (o = o || []).push(u, l))
    }
    n && (o = o || []).push("style", n)
    var u = o
    ;(t.updateQueue = u) && (t.flags |= 4)
  }
}
DA = function (e, t, n, r) {
  n !== r && (t.flags |= 4)
}
function Ya(e, t) {
  if (!De)
    switch (e.tailMode) {
      case "hidden":
        t = e.tail
        for (var n = null; t !== null; )
          t.alternate !== null && (n = t), (t = t.sibling)
        n === null ? (e.tail = null) : (n.sibling = null)
        break
      case "collapsed":
        n = e.tail
        for (var r = null; n !== null; )
          n.alternate !== null && (r = n), (n = n.sibling)
        r === null
          ? t || e.tail === null
            ? (e.tail = null)
            : (e.tail.sibling = null)
          : (r.sibling = null)
    }
}
function St(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
    n = 0,
    r = 0
  if (t)
    for (var i = e.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = e),
        (i = i.sibling)
  else
    for (i = e.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = e),
        (i = i.sibling)
  return (e.subtreeFlags |= r), (e.childLanes = n), t
}
function Fj(e, t, n) {
  var r = t.pendingProps
  switch ((Xg(t), t.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return St(t), null
    case 1:
      return Ft(t.type) && Lc(), St(t), null
    case 3:
      return (
        (r = t.stateNode),
        Jo(),
        ke(Bt),
        ke(Tt),
        iy(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (e === null || e.child === null) &&
          (Cu(t)
            ? (t.flags |= 4)
            : e === null ||
              (e.memoizedState.isDehydrated && !(t.flags & 256)) ||
              ((t.flags |= 1024), En !== null && (Um(En), (En = null)))),
        Im(e, t),
        St(t),
        null
      )
    case 5:
      ry(t)
      var i = Li(Qs.current)
      if (((n = t.type), e !== null && t.stateNode != null))
        jA(e, t, n, r, i),
          e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152))
      else {
        if (!r) {
          if (t.stateNode === null) throw Error(z(166))
          return St(t), null
        }
        if (((e = Li(Hn.current)), Cu(t))) {
          ;(r = t.stateNode), (n = t.type)
          var o = t.memoizedProps
          switch (((r[Vn] = t), (r[Xs] = o), (e = (t.mode & 1) !== 0), n)) {
            case "dialog":
              Ee("cancel", r), Ee("close", r)
              break
            case "iframe":
            case "object":
            case "embed":
              Ee("load", r)
              break
            case "video":
            case "audio":
              for (i = 0; i < gs.length; i++) Ee(gs[i], r)
              break
            case "source":
              Ee("error", r)
              break
            case "img":
            case "image":
            case "link":
              Ee("error", r), Ee("load", r)
              break
            case "details":
              Ee("toggle", r)
              break
            case "input":
              hb(r, o), Ee("invalid", r)
              break
            case "select":
              ;(r._wrapperState = { wasMultiple: !!o.multiple }),
                Ee("invalid", r)
              break
            case "textarea":
              vb(r, o), Ee("invalid", r)
          }
          lm(n, o), (i = null)
          for (var a in o)
            if (o.hasOwnProperty(a)) {
              var s = o[a]
              a === "children"
                ? typeof s == "string"
                  ? r.textContent !== s &&
                    (o.suppressHydrationWarning !== !0 &&
                      Eu(r.textContent, s, e),
                    (i = ["children", s]))
                  : typeof s == "number" &&
                    r.textContent !== "" + s &&
                    (o.suppressHydrationWarning !== !0 &&
                      Eu(r.textContent, s, e),
                    (i = ["children", "" + s]))
                : Bs.hasOwnProperty(a) &&
                  s != null &&
                  a === "onScroll" &&
                  Ee("scroll", r)
            }
          switch (n) {
            case "input":
              xu(r), mb(r, o, !0)
              break
            case "textarea":
              xu(r), gb(r)
              break
            case "select":
            case "option":
              break
            default:
              typeof o.onClick == "function" && (r.onclick = Rc)
          }
          ;(r = i), (t.updateQueue = r), r !== null && (t.flags |= 4)
        } else {
          ;(a = i.nodeType === 9 ? i : i.ownerDocument),
            e === "http://www.w3.org/1999/xhtml" && (e = s$(n)),
            e === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((e = a.createElement("div")),
                  (e.innerHTML = "<script></script>"),
                  (e = e.removeChild(e.firstChild)))
                : typeof r.is == "string"
                  ? (e = a.createElement(n, { is: r.is }))
                  : ((e = a.createElement(n)),
                    n === "select" &&
                      ((a = e),
                      r.multiple
                        ? (a.multiple = !0)
                        : r.size && (a.size = r.size)))
              : (e = a.createElementNS(e, n)),
            (e[Vn] = t),
            (e[Xs] = r),
            MA(e, t, !1, !1),
            (t.stateNode = e)
          e: {
            switch (((a = um(n, r)), n)) {
              case "dialog":
                Ee("cancel", e), Ee("close", e), (i = r)
                break
              case "iframe":
              case "object":
              case "embed":
                Ee("load", e), (i = r)
                break
              case "video":
              case "audio":
                for (i = 0; i < gs.length; i++) Ee(gs[i], e)
                i = r
                break
              case "source":
                Ee("error", e), (i = r)
                break
              case "img":
              case "image":
              case "link":
                Ee("error", e), Ee("load", e), (i = r)
                break
              case "details":
                Ee("toggle", e), (i = r)
                break
              case "input":
                hb(e, r), (i = rm(e, r)), Ee("invalid", e)
                break
              case "option":
                i = r
                break
              case "select":
                ;(e._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = ze({}, r, { value: void 0 })),
                  Ee("invalid", e)
                break
              case "textarea":
                vb(e, r), (i = am(e, r)), Ee("invalid", e)
                break
              default:
                i = r
            }
            lm(n, i), (s = i)
            for (o in s)
              if (s.hasOwnProperty(o)) {
                var l = s[o]
                o === "style"
                  ? c$(e, l)
                  : o === "dangerouslySetInnerHTML"
                    ? ((l = l ? l.__html : void 0), l != null && l$(e, l))
                    : o === "children"
                      ? typeof l == "string"
                        ? (n !== "textarea" || l !== "") && Fs(e, l)
                        : typeof l == "number" && Fs(e, "" + l)
                      : o !== "suppressContentEditableWarning" &&
                        o !== "suppressHydrationWarning" &&
                        o !== "autoFocus" &&
                        (Bs.hasOwnProperty(o)
                          ? l != null && o === "onScroll" && Ee("scroll", e)
                          : l != null && Dg(e, o, l, a))
              }
            switch (n) {
              case "input":
                xu(e), mb(e, r, !1)
                break
              case "textarea":
                xu(e), gb(e)
                break
              case "option":
                r.value != null && e.setAttribute("value", "" + ui(r.value))
                break
              case "select":
                ;(e.multiple = !!r.multiple),
                  (o = r.value),
                  o != null
                    ? Lo(e, !!r.multiple, o, !1)
                    : r.defaultValue != null &&
                      Lo(e, !!r.multiple, r.defaultValue, !0)
                break
              default:
                typeof i.onClick == "function" && (e.onclick = Rc)
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus
                break e
              case "img":
                r = !0
                break e
              default:
                r = !1
            }
          }
          r && (t.flags |= 4)
        }
        t.ref !== null && ((t.flags |= 512), (t.flags |= 2097152))
      }
      return St(t), null
    case 6:
      if (e && t.stateNode != null) DA(e, t, e.memoizedProps, r)
      else {
        if (typeof r != "string" && t.stateNode === null) throw Error(z(166))
        if (((n = Li(Qs.current)), Li(Hn.current), Cu(t))) {
          if (
            ((r = t.stateNode),
            (n = t.memoizedProps),
            (r[Vn] = t),
            (o = r.nodeValue !== n) && ((e = Xt), e !== null))
          )
            switch (e.tag) {
              case 3:
                Eu(r.nodeValue, n, (e.mode & 1) !== 0)
                break
              case 5:
                e.memoizedProps.suppressHydrationWarning !== !0 &&
                  Eu(r.nodeValue, n, (e.mode & 1) !== 0)
            }
          o && (t.flags |= 4)
        } else
          (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[Vn] = t),
            (t.stateNode = r)
      }
      return St(t), null
    case 13:
      if (
        (ke(Le),
        (r = t.memoizedState),
        e === null ||
          (e.memoizedState !== null && e.memoizedState.dehydrated !== null))
      ) {
        if (De && qt !== null && t.mode & 1 && !(t.flags & 128))
          Q$(), Qo(), (t.flags |= 98560), (o = !1)
        else if (((o = Cu(t)), r !== null && r.dehydrated !== null)) {
          if (e === null) {
            if (!o) throw Error(z(318))
            if (
              ((o = t.memoizedState),
              (o = o !== null ? o.dehydrated : null),
              !o)
            )
              throw Error(z(317))
            o[Vn] = t
          } else
            Qo(), !(t.flags & 128) && (t.memoizedState = null), (t.flags |= 4)
          St(t), (o = !1)
        } else En !== null && (Um(En), (En = null)), (o = !0)
        if (!o) return t.flags & 65536 ? t : null
      }
      return t.flags & 128
        ? ((t.lanes = n), t)
        : ((r = r !== null),
          r !== (e !== null && e.memoizedState !== null) &&
            r &&
            ((t.child.flags |= 8192),
            t.mode & 1 &&
              (e === null || Le.current & 1 ? rt === 0 && (rt = 3) : vy())),
          t.updateQueue !== null && (t.flags |= 4),
          St(t),
          null)
    case 4:
      return (
        Jo(), Im(e, t), e === null && Ks(t.stateNode.containerInfo), St(t), null
      )
    case 10:
      return Jg(t.type._context), St(t), null
    case 17:
      return Ft(t.type) && Lc(), St(t), null
    case 19:
      if ((ke(Le), (o = t.memoizedState), o === null)) return St(t), null
      if (((r = (t.flags & 128) !== 0), (a = o.rendering), a === null))
        if (r) Ya(o, !1)
        else {
          if (rt !== 0 || (e !== null && e.flags & 128))
            for (e = t.child; e !== null; ) {
              if (((a = Hc(e)), a !== null)) {
                for (
                  t.flags |= 128,
                    Ya(o, !1),
                    r = a.updateQueue,
                    r !== null && ((t.updateQueue = r), (t.flags |= 4)),
                    t.subtreeFlags = 0,
                    r = n,
                    n = t.child;
                  n !== null;

                )
                  (o = n),
                    (e = r),
                    (o.flags &= 14680066),
                    (a = o.alternate),
                    a === null
                      ? ((o.childLanes = 0),
                        (o.lanes = e),
                        (o.child = null),
                        (o.subtreeFlags = 0),
                        (o.memoizedProps = null),
                        (o.memoizedState = null),
                        (o.updateQueue = null),
                        (o.dependencies = null),
                        (o.stateNode = null))
                      : ((o.childLanes = a.childLanes),
                        (o.lanes = a.lanes),
                        (o.child = a.child),
                        (o.subtreeFlags = 0),
                        (o.deletions = null),
                        (o.memoizedProps = a.memoizedProps),
                        (o.memoizedState = a.memoizedState),
                        (o.updateQueue = a.updateQueue),
                        (o.type = a.type),
                        (e = a.dependencies),
                        (o.dependencies =
                          e === null
                            ? null
                            : {
                                lanes: e.lanes,
                                firstContext: e.firstContext
                              })),
                    (n = n.sibling)
                return Ae(Le, (Le.current & 1) | 2), t.child
              }
              e = e.sibling
            }
          o.tail !== null &&
            He() > ta &&
            ((t.flags |= 128), (r = !0), Ya(o, !1), (t.lanes = 4194304))
        }
      else {
        if (!r)
          if (((e = Hc(a)), e !== null)) {
            if (
              ((t.flags |= 128),
              (r = !0),
              (n = e.updateQueue),
              n !== null && ((t.updateQueue = n), (t.flags |= 4)),
              Ya(o, !0),
              o.tail === null && o.tailMode === "hidden" && !a.alternate && !De)
            )
              return St(t), null
          } else
            2 * He() - o.renderingStartTime > ta &&
              n !== 1073741824 &&
              ((t.flags |= 128), (r = !0), Ya(o, !1), (t.lanes = 4194304))
        o.isBackwards
          ? ((a.sibling = t.child), (t.child = a))
          : ((n = o.last),
            n !== null ? (n.sibling = a) : (t.child = a),
            (o.last = a))
      }
      return o.tail !== null
        ? ((t = o.tail),
          (o.rendering = t),
          (o.tail = t.sibling),
          (o.renderingStartTime = He()),
          (t.sibling = null),
          (n = Le.current),
          Ae(Le, r ? (n & 1) | 2 : n & 1),
          t)
        : (St(t), null)
    case 22:
    case 23:
      return (
        my(),
        (r = t.memoizedState !== null),
        e !== null && (e.memoizedState !== null) !== r && (t.flags |= 8192),
        r && t.mode & 1
          ? Ht & 1073741824 && (St(t), t.subtreeFlags & 6 && (t.flags |= 8192))
          : St(t),
        null
      )
    case 24:
      return null
    case 25:
      return null
  }
  throw Error(z(156, t.tag))
}
function Vj(e, t) {
  switch ((Xg(t), t.tag)) {
    case 1:
      return (
        Ft(t.type) && Lc(),
        (e = t.flags),
        e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 3:
      return (
        Jo(),
        ke(Bt),
        ke(Tt),
        iy(),
        (e = t.flags),
        e & 65536 && !(e & 128) ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 5:
      return ry(t), null
    case 13:
      if (
        (ke(Le), (e = t.memoizedState), e !== null && e.dehydrated !== null)
      ) {
        if (t.alternate === null) throw Error(z(340))
        Qo()
      }
      return (
        (e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      )
    case 19:
      return ke(Le), null
    case 4:
      return Jo(), null
    case 10:
      return Jg(t.type._context), null
    case 22:
    case 23:
      return my(), null
    case 24:
      return null
    default:
      return null
  }
}
var Mu = !1,
  $t = !1,
  zj = typeof WeakSet == "function" ? WeakSet : Set,
  K = null
function Co(e, t) {
  var n = e.ref
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null)
      } catch (r) {
        Ue(e, t, r)
      }
    else n.current = null
}
function Nm(e, t, n) {
  try {
    n()
  } catch (r) {
    Ue(e, t, r)
  }
}
var a1 = !1
function Uj(e, t) {
  if (((bm = Dc), (e = L$()), Kg(e))) {
    if ("selectionStart" in e)
      var n = { start: e.selectionStart, end: e.selectionEnd }
    else
      e: {
        n = ((n = e.ownerDocument) && n.defaultView) || window
        var r = n.getSelection && n.getSelection()
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode
          var i = r.anchorOffset,
            o = r.focusNode
          r = r.focusOffset
          try {
            n.nodeType, o.nodeType
          } catch {
            n = null
            break e
          }
          var a = 0,
            s = -1,
            l = -1,
            u = 0,
            f = 0,
            c = e,
            d = null
          t: for (;;) {
            for (
              var p;
              c !== n || (i !== 0 && c.nodeType !== 3) || (s = a + i),
                c !== o || (r !== 0 && c.nodeType !== 3) || (l = a + r),
                c.nodeType === 3 && (a += c.nodeValue.length),
                (p = c.firstChild) !== null;

            )
              (d = c), (c = p)
            for (;;) {
              if (c === e) break t
              if (
                (d === n && ++u === i && (s = a),
                d === o && ++f === r && (l = a),
                (p = c.nextSibling) !== null)
              )
                break
              ;(c = d), (d = c.parentNode)
            }
            c = p
          }
          n = s === -1 || l === -1 ? null : { start: s, end: l }
        } else n = null
      }
    n = n || { start: 0, end: 0 }
  } else n = null
  for (xm = { focusedElem: e, selectionRange: n }, Dc = !1, K = t; K !== null; )
    if (((t = K), (e = t.child), (t.subtreeFlags & 1028) !== 0 && e !== null))
      (e.return = t), (K = e)
    else
      for (; K !== null; ) {
        t = K
        try {
          var h = t.alternate
          if (t.flags & 1024)
            switch (t.tag) {
              case 0:
              case 11:
              case 15:
                break
              case 1:
                if (h !== null) {
                  var m = h.memoizedProps,
                    b = h.memoizedState,
                    g = t.stateNode,
                    v = g.getSnapshotBeforeUpdate(
                      t.elementType === t.type ? m : $n(t.type, m),
                      b
                    )
                  g.__reactInternalSnapshotBeforeUpdate = v
                }
                break
              case 3:
                var y = t.stateNode.containerInfo
                y.nodeType === 1
                  ? (y.textContent = "")
                  : y.nodeType === 9 &&
                    y.documentElement &&
                    y.removeChild(y.documentElement)
                break
              case 5:
              case 6:
              case 4:
              case 17:
                break
              default:
                throw Error(z(163))
            }
        } catch (w) {
          Ue(t, t.return, w)
        }
        if (((e = t.sibling), e !== null)) {
          ;(e.return = t.return), (K = e)
          break
        }
        K = t.return
      }
  return (h = a1), (a1 = !1), h
}
function Ts(e, t, n) {
  var r = t.updateQueue
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next)
    do {
      if ((i.tag & e) === e) {
        var o = i.destroy
        ;(i.destroy = void 0), o !== void 0 && Nm(t, n, o)
      }
      i = i.next
    } while (i !== r)
  }
}
function md(e, t) {
  if (
    ((t = t.updateQueue), (t = t !== null ? t.lastEffect : null), t !== null)
  ) {
    var n = (t = t.next)
    do {
      if ((n.tag & e) === e) {
        var r = n.create
        n.destroy = r()
      }
      n = n.next
    } while (n !== t)
  }
}
function Rm(e) {
  var t = e.ref
  if (t !== null) {
    var n = e.stateNode
    switch (e.tag) {
      case 5:
        e = n
        break
      default:
        e = n
    }
    typeof t == "function" ? t(e) : (t.current = e)
  }
}
function IA(e) {
  var t = e.alternate
  t !== null && ((e.alternate = null), IA(t)),
    (e.child = null),
    (e.deletions = null),
    (e.sibling = null),
    e.tag === 5 &&
      ((t = e.stateNode),
      t !== null &&
        (delete t[Vn], delete t[Xs], delete t[Om], delete t[$j], delete t[Aj])),
    (e.stateNode = null),
    (e.return = null),
    (e.dependencies = null),
    (e.memoizedProps = null),
    (e.memoizedState = null),
    (e.pendingProps = null),
    (e.stateNode = null),
    (e.updateQueue = null)
}
function NA(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4
}
function s1(e) {
  e: for (;;) {
    for (; e.sibling === null; ) {
      if (e.return === null || NA(e.return)) return null
      e = e.return
    }
    for (
      e.sibling.return = e.return, e = e.sibling;
      e.tag !== 5 && e.tag !== 6 && e.tag !== 18;

    ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e
      ;(e.child.return = e), (e = e.child)
    }
    if (!(e.flags & 2)) return e.stateNode
  }
}
function Lm(e, t, n) {
  var r = e.tag
  if (r === 5 || r === 6)
    (e = e.stateNode),
      t
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(e, t)
          : n.insertBefore(e, t)
        : (n.nodeType === 8
            ? ((t = n.parentNode), t.insertBefore(e, n))
            : ((t = n), t.appendChild(e)),
          (n = n._reactRootContainer),
          n != null || t.onclick !== null || (t.onclick = Rc))
  else if (r !== 4 && ((e = e.child), e !== null))
    for (Lm(e, t, n), e = e.sibling; e !== null; ) Lm(e, t, n), (e = e.sibling)
}
function Bm(e, t, n) {
  var r = e.tag
  if (r === 5 || r === 6)
    (e = e.stateNode), t ? n.insertBefore(e, t) : n.appendChild(e)
  else if (r !== 4 && ((e = e.child), e !== null))
    for (Bm(e, t, n), e = e.sibling; e !== null; ) Bm(e, t, n), (e = e.sibling)
}
var gt = null,
  An = !1
function Dr(e, t, n) {
  for (n = n.child; n !== null; ) RA(e, t, n), (n = n.sibling)
}
function RA(e, t, n) {
  if (Wn && typeof Wn.onCommitFiberUnmount == "function")
    try {
      Wn.onCommitFiberUnmount(sd, n)
    } catch {}
  switch (n.tag) {
    case 5:
      $t || Co(n, t)
    case 6:
      var r = gt,
        i = An
      ;(gt = null),
        Dr(e, t, n),
        (gt = r),
        (An = i),
        gt !== null &&
          (An
            ? ((e = gt),
              (n = n.stateNode),
              e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n))
            : gt.removeChild(n.stateNode))
      break
    case 18:
      gt !== null &&
        (An
          ? ((e = gt),
            (n = n.stateNode),
            e.nodeType === 8
              ? Fp(e.parentNode, n)
              : e.nodeType === 1 && Fp(e, n),
            Ws(e))
          : Fp(gt, n.stateNode))
      break
    case 4:
      ;(r = gt),
        (i = An),
        (gt = n.stateNode.containerInfo),
        (An = !0),
        Dr(e, t, n),
        (gt = r),
        (An = i)
      break
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !$t &&
        ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next
        do {
          var o = i,
            a = o.destroy
          ;(o = o.tag),
            a !== void 0 && (o & 2 || o & 4) && Nm(n, t, a),
            (i = i.next)
        } while (i !== r)
      }
      Dr(e, t, n)
      break
    case 1:
      if (
        !$t &&
        (Co(n, t),
        (r = n.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          ;(r.props = n.memoizedProps),
            (r.state = n.memoizedState),
            r.componentWillUnmount()
        } catch (s) {
          Ue(n, t, s)
        }
      Dr(e, t, n)
      break
    case 21:
      Dr(e, t, n)
      break
    case 22:
      n.mode & 1
        ? (($t = (r = $t) || n.memoizedState !== null), Dr(e, t, n), ($t = r))
        : Dr(e, t, n)
      break
    default:
      Dr(e, t, n)
  }
}
function l1(e) {
  var t = e.updateQueue
  if (t !== null) {
    e.updateQueue = null
    var n = e.stateNode
    n === null && (n = e.stateNode = new zj()),
      t.forEach(function (r) {
        var i = Zj.bind(null, e, r)
        n.has(r) || (n.add(r), r.then(i, i))
      })
  }
}
function On(e, t) {
  var n = t.deletions
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r]
      try {
        var o = e,
          a = t,
          s = a
        e: for (; s !== null; ) {
          switch (s.tag) {
            case 5:
              ;(gt = s.stateNode), (An = !1)
              break e
            case 3:
              ;(gt = s.stateNode.containerInfo), (An = !0)
              break e
            case 4:
              ;(gt = s.stateNode.containerInfo), (An = !0)
              break e
          }
          s = s.return
        }
        if (gt === null) throw Error(z(160))
        RA(o, a, i), (gt = null), (An = !1)
        var l = i.alternate
        l !== null && (l.return = null), (i.return = null)
      } catch (u) {
        Ue(i, t, u)
      }
    }
  if (t.subtreeFlags & 12854)
    for (t = t.child; t !== null; ) LA(t, e), (t = t.sibling)
}
function LA(e, t) {
  var n = e.alternate,
    r = e.flags
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((On(t, e), Ln(e), r & 4)) {
        try {
          Ts(3, e, e.return), md(3, e)
        } catch (m) {
          Ue(e, e.return, m)
        }
        try {
          Ts(5, e, e.return)
        } catch (m) {
          Ue(e, e.return, m)
        }
      }
      break
    case 1:
      On(t, e), Ln(e), r & 512 && n !== null && Co(n, n.return)
      break
    case 5:
      if (
        (On(t, e),
        Ln(e),
        r & 512 && n !== null && Co(n, n.return),
        e.flags & 32)
      ) {
        var i = e.stateNode
        try {
          Fs(i, "")
        } catch (m) {
          Ue(e, e.return, m)
        }
      }
      if (r & 4 && ((i = e.stateNode), i != null)) {
        var o = e.memoizedProps,
          a = n !== null ? n.memoizedProps : o,
          s = e.type,
          l = e.updateQueue
        if (((e.updateQueue = null), l !== null))
          try {
            s === "input" && o.type === "radio" && o.name != null && o$(i, o),
              um(s, a)
            var u = um(s, o)
            for (a = 0; a < l.length; a += 2) {
              var f = l[a],
                c = l[a + 1]
              f === "style"
                ? c$(i, c)
                : f === "dangerouslySetInnerHTML"
                  ? l$(i, c)
                  : f === "children"
                    ? Fs(i, c)
                    : Dg(i, f, c, u)
            }
            switch (s) {
              case "input":
                im(i, o)
                break
              case "textarea":
                a$(i, o)
                break
              case "select":
                var d = i._wrapperState.wasMultiple
                i._wrapperState.wasMultiple = !!o.multiple
                var p = o.value
                p != null
                  ? Lo(i, !!o.multiple, p, !1)
                  : d !== !!o.multiple &&
                    (o.defaultValue != null
                      ? Lo(i, !!o.multiple, o.defaultValue, !0)
                      : Lo(i, !!o.multiple, o.multiple ? [] : "", !1))
            }
            i[Xs] = o
          } catch (m) {
            Ue(e, e.return, m)
          }
      }
      break
    case 6:
      if ((On(t, e), Ln(e), r & 4)) {
        if (e.stateNode === null) throw Error(z(162))
        ;(i = e.stateNode), (o = e.memoizedProps)
        try {
          i.nodeValue = o
        } catch (m) {
          Ue(e, e.return, m)
        }
      }
      break
    case 3:
      if (
        (On(t, e), Ln(e), r & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          Ws(t.containerInfo)
        } catch (m) {
          Ue(e, e.return, m)
        }
      break
    case 4:
      On(t, e), Ln(e)
      break
    case 13:
      On(t, e),
        Ln(e),
        (i = e.child),
        i.flags & 8192 &&
          ((o = i.memoizedState !== null),
          (i.stateNode.isHidden = o),
          !o ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (py = He())),
        r & 4 && l1(e)
      break
    case 22:
      if (
        ((f = n !== null && n.memoizedState !== null),
        e.mode & 1 ? (($t = (u = $t) || f), On(t, e), ($t = u)) : On(t, e),
        Ln(e),
        r & 8192)
      ) {
        if (
          ((u = e.memoizedState !== null),
          (e.stateNode.isHidden = u) && !f && e.mode & 1)
        )
          for (K = e, f = e.child; f !== null; ) {
            for (c = K = f; K !== null; ) {
              switch (((d = K), (p = d.child), d.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Ts(4, d, d.return)
                  break
                case 1:
                  Co(d, d.return)
                  var h = d.stateNode
                  if (typeof h.componentWillUnmount == "function") {
                    ;(r = d), (n = d.return)
                    try {
                      ;(t = r),
                        (h.props = t.memoizedProps),
                        (h.state = t.memoizedState),
                        h.componentWillUnmount()
                    } catch (m) {
                      Ue(r, n, m)
                    }
                  }
                  break
                case 5:
                  Co(d, d.return)
                  break
                case 22:
                  if (d.memoizedState !== null) {
                    c1(c)
                    continue
                  }
              }
              p !== null ? ((p.return = d), (K = p)) : c1(c)
            }
            f = f.sibling
          }
        e: for (f = null, c = e; ; ) {
          if (c.tag === 5) {
            if (f === null) {
              f = c
              try {
                ;(i = c.stateNode),
                  u
                    ? ((o = i.style),
                      typeof o.setProperty == "function"
                        ? o.setProperty("display", "none", "important")
                        : (o.display = "none"))
                    : ((s = c.stateNode),
                      (l = c.memoizedProps.style),
                      (a =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (s.style.display = u$("display", a)))
              } catch (m) {
                Ue(e, e.return, m)
              }
            }
          } else if (c.tag === 6) {
            if (f === null)
              try {
                c.stateNode.nodeValue = u ? "" : c.memoizedProps
              } catch (m) {
                Ue(e, e.return, m)
              }
          } else if (
            ((c.tag !== 22 && c.tag !== 23) ||
              c.memoizedState === null ||
              c === e) &&
            c.child !== null
          ) {
            ;(c.child.return = c), (c = c.child)
            continue
          }
          if (c === e) break e
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === e) break e
            f === c && (f = null), (c = c.return)
          }
          f === c && (f = null), (c.sibling.return = c.return), (c = c.sibling)
        }
      }
      break
    case 19:
      On(t, e), Ln(e), r & 4 && l1(e)
      break
    case 21:
      break
    default:
      On(t, e), Ln(e)
  }
}
function Ln(e) {
  var t = e.flags
  if (t & 2) {
    try {
      e: {
        for (var n = e.return; n !== null; ) {
          if (NA(n)) {
            var r = n
            break e
          }
          n = n.return
        }
        throw Error(z(160))
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode
          r.flags & 32 && (Fs(i, ""), (r.flags &= -33))
          var o = s1(e)
          Bm(e, o, i)
          break
        case 3:
        case 4:
          var a = r.stateNode.containerInfo,
            s = s1(e)
          Lm(e, s, a)
          break
        default:
          throw Error(z(161))
      }
    } catch (l) {
      Ue(e, e.return, l)
    }
    e.flags &= -3
  }
  t & 4096 && (e.flags &= -4097)
}
function Wj(e, t, n) {
  ;(K = e), BA(e)
}
function BA(e, t, n) {
  for (var r = (e.mode & 1) !== 0; K !== null; ) {
    var i = K,
      o = i.child
    if (i.tag === 22 && r) {
      var a = i.memoizedState !== null || Mu
      if (!a) {
        var s = i.alternate,
          l = (s !== null && s.memoizedState !== null) || $t
        s = Mu
        var u = $t
        if (((Mu = a), ($t = l) && !u))
          for (K = i; K !== null; )
            (a = K),
              (l = a.child),
              a.tag === 22 && a.memoizedState !== null
                ? f1(i)
                : l !== null
                  ? ((l.return = a), (K = l))
                  : f1(i)
        for (; o !== null; ) (K = o), BA(o), (o = o.sibling)
        ;(K = i), (Mu = s), ($t = u)
      }
      u1(e)
    } else
      i.subtreeFlags & 8772 && o !== null ? ((o.return = i), (K = o)) : u1(e)
  }
}
function u1(e) {
  for (; K !== null; ) {
    var t = K
    if (t.flags & 8772) {
      var n = t.alternate
      try {
        if (t.flags & 8772)
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              $t || md(5, t)
              break
            case 1:
              var r = t.stateNode
              if (t.flags & 4 && !$t)
                if (n === null) r.componentDidMount()
                else {
                  var i =
                    t.elementType === t.type
                      ? n.memoizedProps
                      : $n(t.type, n.memoizedProps)
                  r.componentDidUpdate(
                    i,
                    n.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  )
                }
              var o = t.updateQueue
              o !== null && Gb(t, o, r)
              break
            case 3:
              var a = t.updateQueue
              if (a !== null) {
                if (((n = null), t.child !== null))
                  switch (t.child.tag) {
                    case 5:
                      n = t.child.stateNode
                      break
                    case 1:
                      n = t.child.stateNode
                  }
                Gb(t, a, n)
              }
              break
            case 5:
              var s = t.stateNode
              if (n === null && t.flags & 4) {
                n = s
                var l = t.memoizedProps
                switch (t.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus()
                    break
                  case "img":
                    l.src && (n.src = l.src)
                }
              }
              break
            case 6:
              break
            case 4:
              break
            case 12:
              break
            case 13:
              if (t.memoizedState === null) {
                var u = t.alternate
                if (u !== null) {
                  var f = u.memoizedState
                  if (f !== null) {
                    var c = f.dehydrated
                    c !== null && Ws(c)
                  }
                }
              }
              break
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break
            default:
              throw Error(z(163))
          }
        $t || (t.flags & 512 && Rm(t))
      } catch (d) {
        Ue(t, t.return, d)
      }
    }
    if (t === e) {
      K = null
      break
    }
    if (((n = t.sibling), n !== null)) {
      ;(n.return = t.return), (K = n)
      break
    }
    K = t.return
  }
}
function c1(e) {
  for (; K !== null; ) {
    var t = K
    if (t === e) {
      K = null
      break
    }
    var n = t.sibling
    if (n !== null) {
      ;(n.return = t.return), (K = n)
      break
    }
    K = t.return
  }
}
function f1(e) {
  for (; K !== null; ) {
    var t = K
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var n = t.return
          try {
            md(4, t)
          } catch (l) {
            Ue(t, n, l)
          }
          break
        case 1:
          var r = t.stateNode
          if (typeof r.componentDidMount == "function") {
            var i = t.return
            try {
              r.componentDidMount()
            } catch (l) {
              Ue(t, i, l)
            }
          }
          var o = t.return
          try {
            Rm(t)
          } catch (l) {
            Ue(t, o, l)
          }
          break
        case 5:
          var a = t.return
          try {
            Rm(t)
          } catch (l) {
            Ue(t, a, l)
          }
      }
    } catch (l) {
      Ue(t, t.return, l)
    }
    if (t === e) {
      K = null
      break
    }
    var s = t.sibling
    if (s !== null) {
      ;(s.return = t.return), (K = s)
      break
    }
    K = t.return
  }
}
var Hj = Math.ceil,
  qc = Er.ReactCurrentDispatcher,
  fy = Er.ReactCurrentOwner,
  hn = Er.ReactCurrentBatchConfig,
  fe = 0,
  ft = null,
  Xe = null,
  bt = 0,
  Ht = 0,
  _o = yi(0),
  rt = 0,
  tl = null,
  Ji = 0,
  vd = 0,
  dy = 0,
  Es = null,
  Nt = null,
  py = 0,
  ta = 1 / 0,
  rr = null,
  Xc = !1,
  Fm = null,
  ni = null,
  ju = !1,
  Xr = null,
  Yc = 0,
  Cs = 0,
  Vm = null,
  vc = -1,
  gc = 0
function Mt() {
  return fe & 6 ? He() : vc !== -1 ? vc : (vc = He())
}
function ri(e) {
  return e.mode & 1
    ? fe & 2 && bt !== 0
      ? bt & -bt
      : Ej.transition !== null
        ? (gc === 0 && (gc = S$()), gc)
        : ((e = ge),
          e !== 0 || ((e = window.event), (e = e === void 0 ? 16 : C$(e.type))),
          e)
    : 1
}
function Mn(e, t, n, r) {
  if (50 < Cs) throw ((Cs = 0), (Vm = null), Error(z(185)))
  ql(e, n, r),
    (!(fe & 2) || e !== ft) &&
      (e === ft && (!(fe & 2) && (vd |= n), rt === 4 && Kr(e, bt)),
      Vt(e, r),
      n === 1 && fe === 0 && !(t.mode & 1) && ((ta = He() + 500), dd && bi()))
}
function Vt(e, t) {
  var n = e.callbackNode
  E2(e, t)
  var r = jc(e, e === ft ? bt : 0)
  if (r === 0)
    n !== null && xb(n), (e.callbackNode = null), (e.callbackPriority = 0)
  else if (((t = r & -r), e.callbackPriority !== t)) {
    if ((n != null && xb(n), t === 1))
      e.tag === 0 ? Tj(d1.bind(null, e)) : q$(d1.bind(null, e)),
        Oj(function () {
          !(fe & 6) && bi()
        }),
        (n = null)
    else {
      switch (O$(r)) {
        case 1:
          n = Bg
          break
        case 4:
          n = x$
          break
        case 16:
          n = Mc
          break
        case 536870912:
          n = w$
          break
        default:
          n = Mc
      }
      n = KA(n, FA.bind(null, e))
    }
    ;(e.callbackPriority = t), (e.callbackNode = n)
  }
}
function FA(e, t) {
  if (((vc = -1), (gc = 0), fe & 6)) throw Error(z(327))
  var n = e.callbackNode
  if (Uo() && e.callbackNode !== n) return null
  var r = jc(e, e === ft ? bt : 0)
  if (r === 0) return null
  if (r & 30 || r & e.expiredLanes || t) t = Qc(e, r)
  else {
    t = r
    var i = fe
    fe |= 2
    var o = zA()
    ;(ft !== e || bt !== t) && ((rr = null), (ta = He() + 500), Wi(e, t))
    do
      try {
        qj()
        break
      } catch (s) {
        VA(e, s)
      }
    while (!0)
    Zg(),
      (qc.current = o),
      (fe = i),
      Xe !== null ? (t = 0) : ((ft = null), (bt = 0), (t = rt))
  }
  if (t !== 0) {
    if (
      (t === 2 && ((i = hm(e)), i !== 0 && ((r = i), (t = zm(e, i)))), t === 1)
    )
      throw ((n = tl), Wi(e, 0), Kr(e, r), Vt(e, He()), n)
    if (t === 6) Kr(e, r)
    else {
      if (
        ((i = e.current.alternate),
        !(r & 30) &&
          !Gj(i) &&
          ((t = Qc(e, r)),
          t === 2 && ((o = hm(e)), o !== 0 && ((r = o), (t = zm(e, o)))),
          t === 1))
      )
        throw ((n = tl), Wi(e, 0), Kr(e, r), Vt(e, He()), n)
      switch (((e.finishedWork = i), (e.finishedLanes = r), t)) {
        case 0:
        case 1:
          throw Error(z(345))
        case 2:
          _i(e, Nt, rr)
          break
        case 3:
          if (
            (Kr(e, r), (r & 130023424) === r && ((t = py + 500 - He()), 10 < t))
          ) {
            if (jc(e, 0) !== 0) break
            if (((i = e.suspendedLanes), (i & r) !== r)) {
              Mt(), (e.pingedLanes |= e.suspendedLanes & i)
              break
            }
            e.timeoutHandle = Sm(_i.bind(null, e, Nt, rr), t)
            break
          }
          _i(e, Nt, rr)
          break
        case 4:
          if ((Kr(e, r), (r & 4194240) === r)) break
          for (t = e.eventTimes, i = -1; 0 < r; ) {
            var a = 31 - kn(r)
            ;(o = 1 << a), (a = t[a]), a > i && (i = a), (r &= ~o)
          }
          if (
            ((r = i),
            (r = He() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                  ? 480
                  : 1080 > r
                    ? 1080
                    : 1920 > r
                      ? 1920
                      : 3e3 > r
                        ? 3e3
                        : 4320 > r
                          ? 4320
                          : 1960 * Hj(r / 1960)) - r),
            10 < r)
          ) {
            e.timeoutHandle = Sm(_i.bind(null, e, Nt, rr), r)
            break
          }
          _i(e, Nt, rr)
          break
        case 5:
          _i(e, Nt, rr)
          break
        default:
          throw Error(z(329))
      }
    }
  }
  return Vt(e, He()), e.callbackNode === n ? FA.bind(null, e) : null
}
function zm(e, t) {
  var n = Es
  return (
    e.current.memoizedState.isDehydrated && (Wi(e, t).flags |= 256),
    (e = Qc(e, t)),
    e !== 2 && ((t = Nt), (Nt = n), t !== null && Um(t)),
    e
  )
}
function Um(e) {
  Nt === null ? (Nt = e) : Nt.push.apply(Nt, e)
}
function Gj(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var n = t.updateQueue
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            o = i.getSnapshot
          i = i.value
          try {
            if (!Dn(o(), i)) return !1
          } catch {
            return !1
          }
        }
    }
    if (((n = t.child), t.subtreeFlags & 16384 && n !== null))
      (n.return = t), (t = n)
    else {
      if (t === e) break
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0
        t = t.return
      }
      ;(t.sibling.return = t.return), (t = t.sibling)
    }
  }
  return !0
}
function Kr(e, t) {
  for (
    t &= ~dy,
      t &= ~vd,
      e.suspendedLanes |= t,
      e.pingedLanes &= ~t,
      e = e.expirationTimes;
    0 < t;

  ) {
    var n = 31 - kn(t),
      r = 1 << n
    ;(e[n] = -1), (t &= ~r)
  }
}
function d1(e) {
  if (fe & 6) throw Error(z(327))
  Uo()
  var t = jc(e, 0)
  if (!(t & 1)) return Vt(e, He()), null
  var n = Qc(e, t)
  if (e.tag !== 0 && n === 2) {
    var r = hm(e)
    r !== 0 && ((t = r), (n = zm(e, r)))
  }
  if (n === 1) throw ((n = tl), Wi(e, 0), Kr(e, t), Vt(e, He()), n)
  if (n === 6) throw Error(z(345))
  return (
    (e.finishedWork = e.current.alternate),
    (e.finishedLanes = t),
    _i(e, Nt, rr),
    Vt(e, He()),
    null
  )
}
function hy(e, t) {
  var n = fe
  fe |= 1
  try {
    return e(t)
  } finally {
    ;(fe = n), fe === 0 && ((ta = He() + 500), dd && bi())
  }
}
function eo(e) {
  Xr !== null && Xr.tag === 0 && !(fe & 6) && Uo()
  var t = fe
  fe |= 1
  var n = hn.transition,
    r = ge
  try {
    if (((hn.transition = null), (ge = 1), e)) return e()
  } finally {
    ;(ge = r), (hn.transition = n), (fe = t), !(fe & 6) && bi()
  }
}
function my() {
  ;(Ht = _o.current), ke(_o)
}
function Wi(e, t) {
  ;(e.finishedWork = null), (e.finishedLanes = 0)
  var n = e.timeoutHandle
  if ((n !== -1 && ((e.timeoutHandle = -1), Sj(n)), Xe !== null))
    for (n = Xe.return; n !== null; ) {
      var r = n
      switch ((Xg(r), r.tag)) {
        case 1:
          ;(r = r.type.childContextTypes), r != null && Lc()
          break
        case 3:
          Jo(), ke(Bt), ke(Tt), iy()
          break
        case 5:
          ry(r)
          break
        case 4:
          Jo()
          break
        case 13:
          ke(Le)
          break
        case 19:
          ke(Le)
          break
        case 10:
          Jg(r.type._context)
          break
        case 22:
        case 23:
          my()
      }
      n = n.return
    }
  if (
    ((ft = e),
    (Xe = e = ii(e.current, null)),
    (bt = Ht = t),
    (rt = 0),
    (tl = null),
    (dy = vd = Ji = 0),
    (Nt = Es = null),
    Ri !== null)
  ) {
    for (t = 0; t < Ri.length; t++)
      if (((n = Ri[t]), (r = n.interleaved), r !== null)) {
        n.interleaved = null
        var i = r.next,
          o = n.pending
        if (o !== null) {
          var a = o.next
          ;(o.next = i), (r.next = a)
        }
        n.pending = r
      }
    Ri = null
  }
  return e
}
function VA(e, t) {
  do {
    var n = Xe
    try {
      if ((Zg(), (pc.current = Kc), Gc)) {
        for (var r = Ve.memoizedState; r !== null; ) {
          var i = r.queue
          i !== null && (i.pending = null), (r = r.next)
        }
        Gc = !1
      }
      if (
        ((Zi = 0),
        (ut = nt = Ve = null),
        (As = !1),
        (Zs = 0),
        (fy.current = null),
        n === null || n.return === null)
      ) {
        ;(rt = 1), (tl = t), (Xe = null)
        break
      }
      e: {
        var o = e,
          a = n.return,
          s = n,
          l = t
        if (
          ((t = bt),
          (s.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var u = l,
            f = s,
            c = f.tag
          if (!(f.mode & 1) && (c === 0 || c === 11 || c === 15)) {
            var d = f.alternate
            d
              ? ((f.updateQueue = d.updateQueue),
                (f.memoizedState = d.memoizedState),
                (f.lanes = d.lanes))
              : ((f.updateQueue = null), (f.memoizedState = null))
          }
          var p = Jb(a)
          if (p !== null) {
            ;(p.flags &= -257),
              e1(p, a, s, o, t),
              p.mode & 1 && Zb(o, u, t),
              (t = p),
              (l = u)
            var h = t.updateQueue
            if (h === null) {
              var m = new Set()
              m.add(l), (t.updateQueue = m)
            } else h.add(l)
            break e
          } else {
            if (!(t & 1)) {
              Zb(o, u, t), vy()
              break e
            }
            l = Error(z(426))
          }
        } else if (De && s.mode & 1) {
          var b = Jb(a)
          if (b !== null) {
            !(b.flags & 65536) && (b.flags |= 256),
              e1(b, a, s, o, t),
              Yg(ea(l, s))
            break e
          }
        }
        ;(o = l = ea(l, s)),
          rt !== 4 && (rt = 2),
          Es === null ? (Es = [o]) : Es.push(o),
          (o = a)
        do {
          switch (o.tag) {
            case 3:
              ;(o.flags |= 65536), (t &= -t), (o.lanes |= t)
              var g = PA(o, l, t)
              Hb(o, g)
              break e
            case 1:
              s = l
              var v = o.type,
                y = o.stateNode
              if (
                !(o.flags & 128) &&
                (typeof v.getDerivedStateFromError == "function" ||
                  (y !== null &&
                    typeof y.componentDidCatch == "function" &&
                    (ni === null || !ni.has(y))))
              ) {
                ;(o.flags |= 65536), (t &= -t), (o.lanes |= t)
                var w = $A(o, s, t)
                Hb(o, w)
                break e
              }
          }
          o = o.return
        } while (o !== null)
      }
      WA(n)
    } catch (x) {
      ;(t = x), Xe === n && n !== null && (Xe = n = n.return)
      continue
    }
    break
  } while (!0)
}
function zA() {
  var e = qc.current
  return (qc.current = Kc), e === null ? Kc : e
}
function vy() {
  ;(rt === 0 || rt === 3 || rt === 2) && (rt = 4),
    ft === null || (!(Ji & 268435455) && !(vd & 268435455)) || Kr(ft, bt)
}
function Qc(e, t) {
  var n = fe
  fe |= 2
  var r = zA()
  ;(ft !== e || bt !== t) && ((rr = null), Wi(e, t))
  do
    try {
      Kj()
      break
    } catch (i) {
      VA(e, i)
    }
  while (!0)
  if ((Zg(), (fe = n), (qc.current = r), Xe !== null)) throw Error(z(261))
  return (ft = null), (bt = 0), rt
}
function Kj() {
  for (; Xe !== null; ) UA(Xe)
}
function qj() {
  for (; Xe !== null && !b2(); ) UA(Xe)
}
function UA(e) {
  var t = GA(e.alternate, e, Ht)
  ;(e.memoizedProps = e.pendingProps),
    t === null ? WA(e) : (Xe = t),
    (fy.current = null)
}
function WA(e) {
  var t = e
  do {
    var n = t.alternate
    if (((e = t.return), t.flags & 32768)) {
      if (((n = Vj(n, t)), n !== null)) {
        ;(n.flags &= 32767), (Xe = n)
        return
      }
      if (e !== null)
        (e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null)
      else {
        ;(rt = 6), (Xe = null)
        return
      }
    } else if (((n = Fj(n, t, Ht)), n !== null)) {
      Xe = n
      return
    }
    if (((t = t.sibling), t !== null)) {
      Xe = t
      return
    }
    Xe = t = e
  } while (t !== null)
  rt === 0 && (rt = 5)
}
function _i(e, t, n) {
  var r = ge,
    i = hn.transition
  try {
    ;(hn.transition = null), (ge = 1), Xj(e, t, n, r)
  } finally {
    ;(hn.transition = i), (ge = r)
  }
  return null
}
function Xj(e, t, n, r) {
  do Uo()
  while (Xr !== null)
  if (fe & 6) throw Error(z(327))
  n = e.finishedWork
  var i = e.finishedLanes
  if (n === null) return null
  if (((e.finishedWork = null), (e.finishedLanes = 0), n === e.current))
    throw Error(z(177))
  ;(e.callbackNode = null), (e.callbackPriority = 0)
  var o = n.lanes | n.childLanes
  if (
    (C2(e, o),
    e === ft && ((Xe = ft = null), (bt = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      ju ||
      ((ju = !0),
      KA(Mc, function () {
        return Uo(), null
      })),
    (o = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || o)
  ) {
    ;(o = hn.transition), (hn.transition = null)
    var a = ge
    ge = 1
    var s = fe
    ;(fe |= 4),
      (fy.current = null),
      Uj(e, n),
      LA(n, e),
      mj(xm),
      (Dc = !!bm),
      (xm = bm = null),
      (e.current = n),
      Wj(n),
      x2(),
      (fe = s),
      (ge = a),
      (hn.transition = o)
  } else e.current = n
  if (
    (ju && ((ju = !1), (Xr = e), (Yc = i)),
    (o = e.pendingLanes),
    o === 0 && (ni = null),
    O2(n.stateNode),
    Vt(e, He()),
    t !== null)
  )
    for (r = e.onRecoverableError, n = 0; n < t.length; n++)
      (i = t[n]), r(i.value, { componentStack: i.stack, digest: i.digest })
  if (Xc) throw ((Xc = !1), (e = Fm), (Fm = null), e)
  return (
    Yc & 1 && e.tag !== 0 && Uo(),
    (o = e.pendingLanes),
    o & 1 ? (e === Vm ? Cs++ : ((Cs = 0), (Vm = e))) : (Cs = 0),
    bi(),
    null
  )
}
function Uo() {
  if (Xr !== null) {
    var e = O$(Yc),
      t = hn.transition,
      n = ge
    try {
      if (((hn.transition = null), (ge = 16 > e ? 16 : e), Xr === null))
        var r = !1
      else {
        if (((e = Xr), (Xr = null), (Yc = 0), fe & 6)) throw Error(z(331))
        var i = fe
        for (fe |= 4, K = e.current; K !== null; ) {
          var o = K,
            a = o.child
          if (K.flags & 16) {
            var s = o.deletions
            if (s !== null) {
              for (var l = 0; l < s.length; l++) {
                var u = s[l]
                for (K = u; K !== null; ) {
                  var f = K
                  switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ts(8, f, o)
                  }
                  var c = f.child
                  if (c !== null) (c.return = f), (K = c)
                  else
                    for (; K !== null; ) {
                      f = K
                      var d = f.sibling,
                        p = f.return
                      if ((IA(f), f === u)) {
                        K = null
                        break
                      }
                      if (d !== null) {
                        ;(d.return = p), (K = d)
                        break
                      }
                      K = p
                    }
                }
              }
              var h = o.alternate
              if (h !== null) {
                var m = h.child
                if (m !== null) {
                  h.child = null
                  do {
                    var b = m.sibling
                    ;(m.sibling = null), (m = b)
                  } while (m !== null)
                }
              }
              K = o
            }
          }
          if (o.subtreeFlags & 2064 && a !== null) (a.return = o), (K = a)
          else
            e: for (; K !== null; ) {
              if (((o = K), o.flags & 2048))
                switch (o.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Ts(9, o, o.return)
                }
              var g = o.sibling
              if (g !== null) {
                ;(g.return = o.return), (K = g)
                break e
              }
              K = o.return
            }
        }
        var v = e.current
        for (K = v; K !== null; ) {
          a = K
          var y = a.child
          if (a.subtreeFlags & 2064 && y !== null) (y.return = a), (K = y)
          else
            e: for (a = v; K !== null; ) {
              if (((s = K), s.flags & 2048))
                try {
                  switch (s.tag) {
                    case 0:
                    case 11:
                    case 15:
                      md(9, s)
                  }
                } catch (x) {
                  Ue(s, s.return, x)
                }
              if (s === a) {
                K = null
                break e
              }
              var w = s.sibling
              if (w !== null) {
                ;(w.return = s.return), (K = w)
                break e
              }
              K = s.return
            }
        }
        if (
          ((fe = i), bi(), Wn && typeof Wn.onPostCommitFiberRoot == "function")
        )
          try {
            Wn.onPostCommitFiberRoot(sd, e)
          } catch {}
        r = !0
      }
      return r
    } finally {
      ;(ge = n), (hn.transition = t)
    }
  }
  return !1
}
function p1(e, t, n) {
  ;(t = ea(n, t)),
    (t = PA(e, t, 1)),
    (e = ti(e, t, 1)),
    (t = Mt()),
    e !== null && (ql(e, 1, t), Vt(e, t))
}
function Ue(e, t, n) {
  if (e.tag === 3) p1(e, e, n)
  else
    for (; t !== null; ) {
      if (t.tag === 3) {
        p1(t, e, n)
        break
      } else if (t.tag === 1) {
        var r = t.stateNode
        if (
          typeof t.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (ni === null || !ni.has(r)))
        ) {
          ;(e = ea(n, e)),
            (e = $A(t, e, 1)),
            (t = ti(t, e, 1)),
            (e = Mt()),
            t !== null && (ql(t, 1, e), Vt(t, e))
          break
        }
      }
      t = t.return
    }
}
function Yj(e, t, n) {
  var r = e.pingCache
  r !== null && r.delete(t),
    (t = Mt()),
    (e.pingedLanes |= e.suspendedLanes & n),
    ft === e &&
      (bt & n) === n &&
      (rt === 4 || (rt === 3 && (bt & 130023424) === bt && 500 > He() - py)
        ? Wi(e, 0)
        : (dy |= n)),
    Vt(e, t)
}
function HA(e, t) {
  t === 0 &&
    (e.mode & 1
      ? ((t = Ou), (Ou <<= 1), !(Ou & 130023424) && (Ou = 4194304))
      : (t = 1))
  var n = Mt()
  ;(e = yr(e, t)), e !== null && (ql(e, t, n), Vt(e, n))
}
function Qj(e) {
  var t = e.memoizedState,
    n = 0
  t !== null && (n = t.retryLane), HA(e, n)
}
function Zj(e, t) {
  var n = 0
  switch (e.tag) {
    case 13:
      var r = e.stateNode,
        i = e.memoizedState
      i !== null && (n = i.retryLane)
      break
    case 19:
      r = e.stateNode
      break
    default:
      throw Error(z(314))
  }
  r !== null && r.delete(t), HA(e, n)
}
var GA
GA = function (e, t, n) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps || Bt.current) Rt = !0
    else {
      if (!(e.lanes & n) && !(t.flags & 128)) return (Rt = !1), Bj(e, t, n)
      Rt = !!(e.flags & 131072)
    }
  else (Rt = !1), De && t.flags & 1048576 && X$(t, Vc, t.index)
  switch (((t.lanes = 0), t.tag)) {
    case 2:
      var r = t.type
      mc(e, t), (e = t.pendingProps)
      var i = Yo(t, Tt.current)
      zo(t, n), (i = ay(null, t, r, e, i, n))
      var o = sy()
      return (
        (t.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((t.tag = 1),
            (t.memoizedState = null),
            (t.updateQueue = null),
            Ft(r) ? ((o = !0), Bc(t)) : (o = !1),
            (t.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            ty(t),
            (i.updater = pd),
            (t.stateNode = i),
            (i._reactInternals = t),
            Cm(t, r, e, n),
            (t = Mm(null, t, r, !0, o, n)))
          : ((t.tag = 0), De && o && qg(t), _t(null, t, i, n), (t = t.child)),
        t
      )
    case 16:
      r = t.elementType
      e: {
        switch (
          (mc(e, t),
          (e = t.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (t.type = r),
          (i = t.tag = eD(r)),
          (e = $n(r, e)),
          i)
        ) {
          case 0:
            t = km(null, t, r, e, n)
            break e
          case 1:
            t = r1(null, t, r, e, n)
            break e
          case 11:
            t = t1(null, t, r, e, n)
            break e
          case 14:
            t = n1(null, t, r, $n(r.type, e), n)
            break e
        }
        throw Error(z(306, r, ""))
      }
      return t
    case 0:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : $n(r, i)),
        km(e, t, r, i, n)
      )
    case 1:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : $n(r, i)),
        r1(e, t, r, i, n)
      )
    case 3:
      e: {
        if ((CA(t), e === null)) throw Error(z(387))
        ;(r = t.pendingProps),
          (o = t.memoizedState),
          (i = o.element),
          J$(e, t),
          Wc(t, r, null, n)
        var a = t.memoizedState
        if (((r = a.element), o.isDehydrated))
          if (
            ((o = {
              element: r,
              isDehydrated: !1,
              cache: a.cache,
              pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
              transitions: a.transitions
            }),
            (t.updateQueue.baseState = o),
            (t.memoizedState = o),
            t.flags & 256)
          ) {
            ;(i = ea(Error(z(423)), t)), (t = i1(e, t, r, n, i))
            break e
          } else if (r !== i) {
            ;(i = ea(Error(z(424)), t)), (t = i1(e, t, r, n, i))
            break e
          } else
            for (
              qt = ei(t.stateNode.containerInfo.firstChild),
                Xt = t,
                De = !0,
                En = null,
                n = rA(t, null, r, n),
                t.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling)
        else {
          if ((Qo(), r === i)) {
            t = br(e, t, n)
            break e
          }
          _t(e, t, r, n)
        }
        t = t.child
      }
      return t
    case 5:
      return (
        iA(t),
        e === null && Am(t),
        (r = t.type),
        (i = t.pendingProps),
        (o = e !== null ? e.memoizedProps : null),
        (a = i.children),
        wm(r, i) ? (a = null) : o !== null && wm(r, o) && (t.flags |= 32),
        EA(e, t),
        _t(e, t, a, n),
        t.child
      )
    case 6:
      return e === null && Am(t), null
    case 13:
      return _A(e, t, n)
    case 4:
      return (
        ny(t, t.stateNode.containerInfo),
        (r = t.pendingProps),
        e === null ? (t.child = Zo(t, null, r, n)) : _t(e, t, r, n),
        t.child
      )
    case 11:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : $n(r, i)),
        t1(e, t, r, i, n)
      )
    case 7:
      return _t(e, t, t.pendingProps, n), t.child
    case 8:
      return _t(e, t, t.pendingProps.children, n), t.child
    case 12:
      return _t(e, t, t.pendingProps.children, n), t.child
    case 10:
      e: {
        if (
          ((r = t.type._context),
          (i = t.pendingProps),
          (o = t.memoizedProps),
          (a = i.value),
          Ae(zc, r._currentValue),
          (r._currentValue = a),
          o !== null)
        )
          if (Dn(o.value, a)) {
            if (o.children === i.children && !Bt.current) {
              t = br(e, t, n)
              break e
            }
          } else
            for (o = t.child, o !== null && (o.return = t); o !== null; ) {
              var s = o.dependencies
              if (s !== null) {
                a = o.child
                for (var l = s.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (o.tag === 1) {
                      ;(l = dr(-1, n & -n)), (l.tag = 2)
                      var u = o.updateQueue
                      if (u !== null) {
                        u = u.shared
                        var f = u.pending
                        f === null
                          ? (l.next = l)
                          : ((l.next = f.next), (f.next = l)),
                          (u.pending = l)
                      }
                    }
                    ;(o.lanes |= n),
                      (l = o.alternate),
                      l !== null && (l.lanes |= n),
                      Tm(o.return, n, t),
                      (s.lanes |= n)
                    break
                  }
                  l = l.next
                }
              } else if (o.tag === 10) a = o.type === t.type ? null : o.child
              else if (o.tag === 18) {
                if (((a = o.return), a === null)) throw Error(z(341))
                ;(a.lanes |= n),
                  (s = a.alternate),
                  s !== null && (s.lanes |= n),
                  Tm(a, n, t),
                  (a = o.sibling)
              } else a = o.child
              if (a !== null) a.return = o
              else
                for (a = o; a !== null; ) {
                  if (a === t) {
                    a = null
                    break
                  }
                  if (((o = a.sibling), o !== null)) {
                    ;(o.return = a.return), (a = o)
                    break
                  }
                  a = a.return
                }
              o = a
            }
        _t(e, t, i.children, n), (t = t.child)
      }
      return t
    case 9:
      return (
        (i = t.type),
        (r = t.pendingProps.children),
        zo(t, n),
        (i = vn(i)),
        (r = r(i)),
        (t.flags |= 1),
        _t(e, t, r, n),
        t.child
      )
    case 14:
      return (
        (r = t.type),
        (i = $n(r, t.pendingProps)),
        (i = $n(r.type, i)),
        n1(e, t, r, i, n)
      )
    case 15:
      return AA(e, t, t.type, t.pendingProps, n)
    case 17:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : $n(r, i)),
        mc(e, t),
        (t.tag = 1),
        Ft(r) ? ((e = !0), Bc(t)) : (e = !1),
        zo(t, n),
        tA(t, r, i),
        Cm(t, r, i, n),
        Mm(null, t, r, !0, e, n)
      )
    case 19:
      return kA(e, t, n)
    case 22:
      return TA(e, t, n)
  }
  throw Error(z(156, t.tag))
}
function KA(e, t) {
  return b$(e, t)
}
function Jj(e, t, n, r) {
  ;(this.tag = e),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = t),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null)
}
function dn(e, t, n, r) {
  return new Jj(e, t, n, r)
}
function gy(e) {
  return (e = e.prototype), !(!e || !e.isReactComponent)
}
function eD(e) {
  if (typeof e == "function") return gy(e) ? 1 : 0
  if (e != null) {
    if (((e = e.$$typeof), e === Ng)) return 11
    if (e === Rg) return 14
  }
  return 2
}
function ii(e, t) {
  var n = e.alternate
  return (
    n === null
      ? ((n = dn(e.tag, t, e.key, e.mode)),
        (n.elementType = e.elementType),
        (n.type = e.type),
        (n.stateNode = e.stateNode),
        (n.alternate = e),
        (e.alternate = n))
      : ((n.pendingProps = t),
        (n.type = e.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = e.flags & 14680064),
    (n.childLanes = e.childLanes),
    (n.lanes = e.lanes),
    (n.child = e.child),
    (n.memoizedProps = e.memoizedProps),
    (n.memoizedState = e.memoizedState),
    (n.updateQueue = e.updateQueue),
    (t = e.dependencies),
    (n.dependencies =
      t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }),
    (n.sibling = e.sibling),
    (n.index = e.index),
    (n.ref = e.ref),
    n
  )
}
function yc(e, t, n, r, i, o) {
  var a = 2
  if (((r = e), typeof e == "function")) gy(e) && (a = 1)
  else if (typeof e == "string") a = 5
  else
    e: switch (e) {
      case xo:
        return Hi(n.children, i, o, t)
      case Ig:
        ;(a = 8), (i |= 8)
        break
      case Jh:
        return (e = dn(12, n, t, i | 2)), (e.elementType = Jh), (e.lanes = o), e
      case em:
        return (e = dn(13, n, t, i)), (e.elementType = em), (e.lanes = o), e
      case tm:
        return (e = dn(19, n, t, i)), (e.elementType = tm), (e.lanes = o), e
      case n$:
        return gd(n, i, o, t)
      default:
        if (typeof e == "object" && e !== null)
          switch (e.$$typeof) {
            case e$:
              a = 10
              break e
            case t$:
              a = 9
              break e
            case Ng:
              a = 11
              break e
            case Rg:
              a = 14
              break e
            case zr:
              ;(a = 16), (r = null)
              break e
          }
        throw Error(z(130, e == null ? e : typeof e, ""))
    }
  return (
    (t = dn(a, n, t, i)), (t.elementType = e), (t.type = r), (t.lanes = o), t
  )
}
function Hi(e, t, n, r) {
  return (e = dn(7, e, r, t)), (e.lanes = n), e
}
function gd(e, t, n, r) {
  return (
    (e = dn(22, e, r, t)),
    (e.elementType = n$),
    (e.lanes = n),
    (e.stateNode = { isHidden: !1 }),
    e
  )
}
function qp(e, t, n) {
  return (e = dn(6, e, null, t)), (e.lanes = n), e
}
function Xp(e, t, n) {
  return (
    (t = dn(4, e.children !== null ? e.children : [], e.key, t)),
    (t.lanes = n),
    (t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation
    }),
    t
  )
}
function tD(e, t, n, r, i) {
  ;(this.tag = t),
    (this.containerInfo = e),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Cp(0)),
    (this.expirationTimes = Cp(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Cp(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null)
}
function yy(e, t, n, r, i, o, a, s, l) {
  return (
    (e = new tD(e, t, n, s, l)),
    t === 1 ? ((t = 1), o === !0 && (t |= 8)) : (t = 0),
    (o = dn(3, null, null, t)),
    (e.current = o),
    (o.stateNode = e),
    (o.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null
    }),
    ty(o),
    e
  )
}
function nD(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
  return {
    $$typeof: bo,
    key: r == null ? null : "" + r,
    children: e,
    containerInfo: t,
    implementation: n
  }
}
function qA(e) {
  if (!e) return ci
  e = e._reactInternals
  e: {
    if (io(e) !== e || e.tag !== 1) throw Error(z(170))
    var t = e
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context
          break e
        case 1:
          if (Ft(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext
            break e
          }
      }
      t = t.return
    } while (t !== null)
    throw Error(z(171))
  }
  if (e.tag === 1) {
    var n = e.type
    if (Ft(n)) return K$(e, n, t)
  }
  return t
}
function XA(e, t, n, r, i, o, a, s, l) {
  return (
    (e = yy(n, r, !0, e, i, o, a, s, l)),
    (e.context = qA(null)),
    (n = e.current),
    (r = Mt()),
    (i = ri(n)),
    (o = dr(r, i)),
    (o.callback = t ?? null),
    ti(n, o, i),
    (e.current.lanes = i),
    ql(e, i, r),
    Vt(e, r),
    e
  )
}
function yd(e, t, n, r) {
  var i = t.current,
    o = Mt(),
    a = ri(i)
  return (
    (n = qA(n)),
    t.context === null ? (t.context = n) : (t.pendingContext = n),
    (t = dr(o, a)),
    (t.payload = { element: e }),
    (r = r === void 0 ? null : r),
    r !== null && (t.callback = r),
    (e = ti(i, t, a)),
    e !== null && (Mn(e, i, a, o), dc(e, i, a)),
    a
  )
}
function Zc(e) {
  if (((e = e.current), !e.child)) return null
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode
    default:
      return e.child.stateNode
  }
}
function h1(e, t) {
  if (((e = e.memoizedState), e !== null && e.dehydrated !== null)) {
    var n = e.retryLane
    e.retryLane = n !== 0 && n < t ? n : t
  }
}
function by(e, t) {
  h1(e, t), (e = e.alternate) && h1(e, t)
}
function rD() {
  return null
}
var YA =
  typeof reportError == "function"
    ? reportError
    : function (e) {
        console.error(e)
      }
function xy(e) {
  this._internalRoot = e
}
bd.prototype.render = xy.prototype.render = function (e) {
  var t = this._internalRoot
  if (t === null) throw Error(z(409))
  yd(e, t, null, null)
}
bd.prototype.unmount = xy.prototype.unmount = function () {
  var e = this._internalRoot
  if (e !== null) {
    this._internalRoot = null
    var t = e.containerInfo
    eo(function () {
      yd(null, e, null, null)
    }),
      (t[gr] = null)
  }
}
function bd(e) {
  this._internalRoot = e
}
bd.prototype.unstable_scheduleHydration = function (e) {
  if (e) {
    var t = A$()
    e = { blockedOn: null, target: e, priority: t }
    for (var n = 0; n < Gr.length && t !== 0 && t < Gr[n].priority; n++);
    Gr.splice(n, 0, e), n === 0 && E$(e)
  }
}
function wy(e) {
  return !(!e || (e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11))
}
function xd(e) {
  return !(
    !e ||
    (e.nodeType !== 1 &&
      e.nodeType !== 9 &&
      e.nodeType !== 11 &&
      (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
  )
}
function m1() {}
function iD(e, t, n, r, i) {
  if (i) {
    if (typeof r == "function") {
      var o = r
      r = function () {
        var u = Zc(a)
        o.call(u)
      }
    }
    var a = XA(t, r, e, 0, null, !1, !1, "", m1)
    return (
      (e._reactRootContainer = a),
      (e[gr] = a.current),
      Ks(e.nodeType === 8 ? e.parentNode : e),
      eo(),
      a
    )
  }
  for (; (i = e.lastChild); ) e.removeChild(i)
  if (typeof r == "function") {
    var s = r
    r = function () {
      var u = Zc(l)
      s.call(u)
    }
  }
  var l = yy(e, 0, !1, null, null, !1, !1, "", m1)
  return (
    (e._reactRootContainer = l),
    (e[gr] = l.current),
    Ks(e.nodeType === 8 ? e.parentNode : e),
    eo(function () {
      yd(t, l, n, r)
    }),
    l
  )
}
function wd(e, t, n, r, i) {
  var o = n._reactRootContainer
  if (o) {
    var a = o
    if (typeof i == "function") {
      var s = i
      i = function () {
        var l = Zc(a)
        s.call(l)
      }
    }
    yd(t, a, e, i)
  } else a = iD(n, t, e, i, r)
  return Zc(a)
}
P$ = function (e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode
      if (t.current.memoizedState.isDehydrated) {
        var n = vs(t.pendingLanes)
        n !== 0 &&
          (Fg(t, n | 1), Vt(t, He()), !(fe & 6) && ((ta = He() + 500), bi()))
      }
      break
    case 13:
      eo(function () {
        var r = yr(e, 1)
        if (r !== null) {
          var i = Mt()
          Mn(r, e, 1, i)
        }
      }),
        by(e, 1)
  }
}
Vg = function (e) {
  if (e.tag === 13) {
    var t = yr(e, 134217728)
    if (t !== null) {
      var n = Mt()
      Mn(t, e, 134217728, n)
    }
    by(e, 134217728)
  }
}
$$ = function (e) {
  if (e.tag === 13) {
    var t = ri(e),
      n = yr(e, t)
    if (n !== null) {
      var r = Mt()
      Mn(n, e, t, r)
    }
    by(e, t)
  }
}
A$ = function () {
  return ge
}
T$ = function (e, t) {
  var n = ge
  try {
    return (ge = e), t()
  } finally {
    ge = n
  }
}
fm = function (e, t, n) {
  switch (t) {
    case "input":
      if ((im(e, n), (t = n.name), n.type === "radio" && t != null)) {
        for (n = e; n.parentNode; ) n = n.parentNode
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + t) + '][type="radio"]'
          ),
            t = 0;
          t < n.length;
          t++
        ) {
          var r = n[t]
          if (r !== e && r.form === e.form) {
            var i = fd(r)
            if (!i) throw Error(z(90))
            i$(r), im(r, i)
          }
        }
      }
      break
    case "textarea":
      a$(e, n)
      break
    case "select":
      ;(t = n.value), t != null && Lo(e, !!n.multiple, t, !1)
  }
}
p$ = hy
h$ = eo
var oD = { usingClientEntryPoint: !1, Events: [Yl, Po, fd, f$, d$, hy] },
  Qa = {
    findFiberByHostInstance: Ni,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
  },
  aD = {
    bundleType: Qa.bundleType,
    version: Qa.version,
    rendererPackageName: Qa.rendererPackageName,
    rendererConfig: Qa.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Er.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (e) {
      return (e = g$(e)), e === null ? null : e.stateNode
    },
    findFiberByHostInstance: Qa.findFiberByHostInstance || rD,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
  }
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Du = __REACT_DEVTOOLS_GLOBAL_HOOK__
  if (!Du.isDisabled && Du.supportsFiber)
    try {
      ;(sd = Du.inject(aD)), (Wn = Du)
    } catch {}
}
en.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oD
en.createPortal = function (e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
  if (!wy(t)) throw Error(z(200))
  return nD(e, t, null, n)
}
en.createRoot = function (e, t) {
  if (!wy(e)) throw Error(z(299))
  var n = !1,
    r = "",
    i = YA
  return (
    t != null &&
      (t.unstable_strictMode === !0 && (n = !0),
      t.identifierPrefix !== void 0 && (r = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (i = t.onRecoverableError)),
    (t = yy(e, 1, !1, null, null, n, !1, r, i)),
    (e[gr] = t.current),
    Ks(e.nodeType === 8 ? e.parentNode : e),
    new xy(t)
  )
}
en.findDOMNode = function (e) {
  if (e == null) return null
  if (e.nodeType === 1) return e
  var t = e._reactInternals
  if (t === void 0)
    throw typeof e.render == "function"
      ? Error(z(188))
      : ((e = Object.keys(e).join(",")), Error(z(268, e)))
  return (e = g$(t)), (e = e === null ? null : e.stateNode), e
}
en.flushSync = function (e) {
  return eo(e)
}
en.hydrate = function (e, t, n) {
  if (!xd(t)) throw Error(z(200))
  return wd(null, e, t, !0, n)
}
en.hydrateRoot = function (e, t, n) {
  if (!wy(e)) throw Error(z(405))
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    o = "",
    a = YA
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (o = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (a = n.onRecoverableError)),
    (t = XA(t, null, e, 1, n ?? null, i, !1, o, a)),
    (e[gr] = t.current),
    Ks(e),
    r)
  )
    for (e = 0; e < r.length; e++)
      (n = r[e]),
        (i = n._getVersion),
        (i = i(n._source)),
        t.mutableSourceEagerHydrationData == null
          ? (t.mutableSourceEagerHydrationData = [n, i])
          : t.mutableSourceEagerHydrationData.push(n, i)
  return new bd(t)
}
en.render = function (e, t, n) {
  if (!xd(t)) throw Error(z(200))
  return wd(null, e, t, !1, n)
}
en.unmountComponentAtNode = function (e) {
  if (!xd(e)) throw Error(z(40))
  return e._reactRootContainer
    ? (eo(function () {
        wd(null, null, e, !1, function () {
          ;(e._reactRootContainer = null), (e[gr] = null)
        })
      }),
      !0)
    : !1
}
en.unstable_batchedUpdates = hy
en.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
  if (!xd(n)) throw Error(z(200))
  if (e == null || e._reactInternals === void 0) throw Error(z(38))
  return wd(e, t, n, !1, r)
}
en.version = "18.2.0-next-9e3b772b8-20220608"
function QA() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(QA)
    } catch (e) {
      console.error(e)
    }
}
QA(), (XP.exports = en)
var Zl = XP.exports
const sD = Pe(Zl)
var v1 = Zl
;(Qh.createRoot = v1.createRoot), (Qh.hydrateRoot = v1.hydrateRoot)
const lD = ({ children: e }) =>
  j.jsx("section", {
    className: "m-auto w-full max-w-3xl p-4 md:p-0",
    children: e
  })
function ZA(e) {
  var t,
    n,
    r = ""
  if (typeof e == "string" || typeof e == "number") r += e
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var i = e.length
      for (t = 0; t < i; t++)
        e[t] && (n = ZA(e[t])) && (r && (r += " "), (r += n))
    } else for (n in e) e[n] && (r && (r += " "), (r += n))
  return r
}
function Oe() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)
    (e = arguments[n]) && (t = ZA(e)) && (r && (r += " "), (r += t))
  return r
}
const Sy = "-"
function uD(e) {
  const t = fD(e),
    { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e
  function i(a) {
    const s = a.split(Sy)
    return s[0] === "" && s.length !== 1 && s.shift(), JA(s, t) || cD(a)
  }
  function o(a, s) {
    const l = n[a] || []
    return s && r[a] ? [...l, ...r[a]] : l
  }
  return { getClassGroupId: i, getConflictingClassGroupIds: o }
}
function JA(e, t) {
  var a
  if (e.length === 0) return t.classGroupId
  const n = e[0],
    r = t.nextPart.get(n),
    i = r ? JA(e.slice(1), r) : void 0
  if (i) return i
  if (t.validators.length === 0) return
  const o = e.join(Sy)
  return (a = t.validators.find(({ validator: s }) => s(o))) == null
    ? void 0
    : a.classGroupId
}
const g1 = /^\[(.+)\]$/
function cD(e) {
  if (g1.test(e)) {
    const t = g1.exec(e)[1],
      n = t == null ? void 0 : t.substring(0, t.indexOf(":"))
    if (n) return "arbitrary.." + n
  }
}
function fD(e) {
  const { theme: t, prefix: n } = e,
    r = { nextPart: new Map(), validators: [] }
  return (
    pD(Object.entries(e.classGroups), n).forEach(([o, a]) => {
      Wm(a, r, o, t)
    }),
    r
  )
}
function Wm(e, t, n, r) {
  e.forEach((i) => {
    if (typeof i == "string") {
      const o = i === "" ? t : y1(t, i)
      o.classGroupId = n
      return
    }
    if (typeof i == "function") {
      if (dD(i)) {
        Wm(i(r), t, n, r)
        return
      }
      t.validators.push({ validator: i, classGroupId: n })
      return
    }
    Object.entries(i).forEach(([o, a]) => {
      Wm(a, y1(t, o), n, r)
    })
  })
}
function y1(e, t) {
  let n = e
  return (
    t.split(Sy).forEach((r) => {
      n.nextPart.has(r) ||
        n.nextPart.set(r, { nextPart: new Map(), validators: [] }),
        (n = n.nextPart.get(r))
    }),
    n
  )
}
function dD(e) {
  return e.isThemeGetter
}
function pD(e, t) {
  return t
    ? e.map(([n, r]) => {
        const i = r.map((o) =>
          typeof o == "string"
            ? t + o
            : typeof o == "object"
              ? Object.fromEntries(
                  Object.entries(o).map(([a, s]) => [t + a, s])
                )
              : o
        )
        return [n, i]
      })
    : e
}
function hD(e) {
  if (e < 1) return { get: () => {}, set: () => {} }
  let t = 0,
    n = new Map(),
    r = new Map()
  function i(o, a) {
    n.set(o, a), t++, t > e && ((t = 0), (r = n), (n = new Map()))
  }
  return {
    get(o) {
      let a = n.get(o)
      if (a !== void 0) return a
      if ((a = r.get(o)) !== void 0) return i(o, a), a
    },
    set(o, a) {
      n.has(o) ? n.set(o, a) : i(o, a)
    }
  }
}
const eT = "!"
function mD(e) {
  const t = e.separator,
    n = t.length === 1,
    r = t[0],
    i = t.length
  return function (a) {
    const s = []
    let l = 0,
      u = 0,
      f
    for (let m = 0; m < a.length; m++) {
      let b = a[m]
      if (l === 0) {
        if (b === r && (n || a.slice(m, m + i) === t)) {
          s.push(a.slice(u, m)), (u = m + i)
          continue
        }
        if (b === "/") {
          f = m
          continue
        }
      }
      b === "[" ? l++ : b === "]" && l--
    }
    const c = s.length === 0 ? a : a.substring(u),
      d = c.startsWith(eT),
      p = d ? c.substring(1) : c,
      h = f && f > u ? f - u : void 0
    return {
      modifiers: s,
      hasImportantModifier: d,
      baseClassName: p,
      maybePostfixModifierPosition: h
    }
  }
}
function vD(e) {
  if (e.length <= 1) return e
  const t = []
  let n = []
  return (
    e.forEach((r) => {
      r[0] === "[" ? (t.push(...n.sort(), r), (n = [])) : n.push(r)
    }),
    t.push(...n.sort()),
    t
  )
}
function gD(e) {
  return { cache: hD(e.cacheSize), splitModifiers: mD(e), ...uD(e) }
}
const yD = /\s+/
function bD(e, t) {
  const {
      splitModifiers: n,
      getClassGroupId: r,
      getConflictingClassGroupIds: i
    } = t,
    o = new Set()
  return e
    .trim()
    .split(yD)
    .map((a) => {
      const {
        modifiers: s,
        hasImportantModifier: l,
        baseClassName: u,
        maybePostfixModifierPosition: f
      } = n(a)
      let c = r(f ? u.substring(0, f) : u),
        d = !!f
      if (!c) {
        if (!f) return { isTailwindClass: !1, originalClassName: a }
        if (((c = r(u)), !c))
          return { isTailwindClass: !1, originalClassName: a }
        d = !1
      }
      const p = vD(s).join(":")
      return {
        isTailwindClass: !0,
        modifierId: l ? p + eT : p,
        classGroupId: c,
        originalClassName: a,
        hasPostfixModifier: d
      }
    })
    .reverse()
    .filter((a) => {
      if (!a.isTailwindClass) return !0
      const { modifierId: s, classGroupId: l, hasPostfixModifier: u } = a,
        f = s + l
      return o.has(f)
        ? !1
        : (o.add(f), i(l, u).forEach((c) => o.add(s + c)), !0)
    })
    .reverse()
    .map((a) => a.originalClassName)
    .join(" ")
}
function xD() {
  let e = 0,
    t,
    n,
    r = ""
  for (; e < arguments.length; )
    (t = arguments[e++]) && (n = tT(t)) && (r && (r += " "), (r += n))
  return r
}
function tT(e) {
  if (typeof e == "string") return e
  let t,
    n = ""
  for (let r = 0; r < e.length; r++)
    e[r] && (t = tT(e[r])) && (n && (n += " "), (n += t))
  return n
}
function wD(e, ...t) {
  let n,
    r,
    i,
    o = a
  function a(l) {
    const u = t.reduce((f, c) => c(f), e())
    return (n = gD(u)), (r = n.cache.get), (i = n.cache.set), (o = s), s(l)
  }
  function s(l) {
    const u = r(l)
    if (u) return u
    const f = bD(l, n)
    return i(l, f), f
  }
  return function () {
    return o(xD.apply(null, arguments))
  }
}
function Te(e) {
  const t = (n) => n[e] || []
  return (t.isThemeGetter = !0), t
}
const nT = /^\[(?:([a-z-]+):)?(.+)\]$/i,
  SD = /^\d+\/\d+$/,
  OD = new Set(["px", "full", "screen"]),
  PD = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  $D =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  AD = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  TD =
    /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
function nr(e) {
  return Bi(e) || OD.has(e) || SD.test(e)
}
function Ir(e) {
  return Aa(e, "length", ID)
}
function Bi(e) {
  return !!e && !Number.isNaN(Number(e))
}
function Iu(e) {
  return Aa(e, "number", Bi)
}
function Za(e) {
  return !!e && Number.isInteger(Number(e))
}
function ED(e) {
  return e.endsWith("%") && Bi(e.slice(0, -1))
}
function re(e) {
  return nT.test(e)
}
function Nr(e) {
  return PD.test(e)
}
const CD = new Set(["length", "size", "percentage"])
function _D(e) {
  return Aa(e, CD, rT)
}
function kD(e) {
  return Aa(e, "position", rT)
}
const MD = new Set(["image", "url"])
function jD(e) {
  return Aa(e, MD, RD)
}
function DD(e) {
  return Aa(e, "", ND)
}
function Ja() {
  return !0
}
function Aa(e, t, n) {
  const r = nT.exec(e)
  return r
    ? r[1]
      ? typeof t == "string"
        ? r[1] === t
        : t.has(r[1])
      : n(r[2])
    : !1
}
function ID(e) {
  return $D.test(e)
}
function rT() {
  return !1
}
function ND(e) {
  return AD.test(e)
}
function RD(e) {
  return TD.test(e)
}
function LD() {
  const e = Te("colors"),
    t = Te("spacing"),
    n = Te("blur"),
    r = Te("brightness"),
    i = Te("borderColor"),
    o = Te("borderRadius"),
    a = Te("borderSpacing"),
    s = Te("borderWidth"),
    l = Te("contrast"),
    u = Te("grayscale"),
    f = Te("hueRotate"),
    c = Te("invert"),
    d = Te("gap"),
    p = Te("gradientColorStops"),
    h = Te("gradientColorStopPositions"),
    m = Te("inset"),
    b = Te("margin"),
    g = Te("opacity"),
    v = Te("padding"),
    y = Te("saturate"),
    w = Te("scale"),
    x = Te("sepia"),
    S = Te("skew"),
    O = Te("space"),
    $ = Te("translate"),
    A = () => ["auto", "contain", "none"],
    C = () => ["auto", "hidden", "clip", "visible", "scroll"],
    T = () => ["auto", re, t],
    _ = () => [re, t],
    R = () => ["", nr, Ir],
    M = () => ["auto", Bi, re],
    D = () => [
      "bottom",
      "center",
      "left",
      "left-bottom",
      "left-top",
      "right",
      "right-bottom",
      "right-top",
      "top"
    ],
    N = () => ["solid", "dashed", "dotted", "double", "none"],
    L = () => [
      "normal",
      "multiply",
      "screen",
      "overlay",
      "darken",
      "lighten",
      "color-dodge",
      "color-burn",
      "hard-light",
      "soft-light",
      "difference",
      "exclusion",
      "hue",
      "saturation",
      "color",
      "luminosity",
      "plus-lighter"
    ],
    k = () => [
      "start",
      "end",
      "center",
      "between",
      "around",
      "evenly",
      "stretch"
    ],
    I = () => ["", "0", re],
    V = () => [
      "auto",
      "avoid",
      "all",
      "avoid-page",
      "page",
      "left",
      "right",
      "column"
    ],
    U = () => [Bi, Iu],
    H = () => [Bi, re]
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Ja],
      spacing: [nr, Ir],
      blur: ["none", "", Nr, re],
      brightness: U(),
      borderColor: [e],
      borderRadius: ["none", "", "full", Nr, re],
      borderSpacing: _(),
      borderWidth: R(),
      contrast: U(),
      grayscale: I(),
      hueRotate: H(),
      invert: I(),
      gap: _(),
      gradientColorStops: [e],
      gradientColorStopPositions: [ED, Ir],
      inset: T(),
      margin: T(),
      opacity: U(),
      padding: _(),
      saturate: U(),
      scale: U(),
      sepia: I(),
      skew: H(),
      space: _(),
      translate: _()
    },
    classGroups: {
      aspect: [{ aspect: ["auto", "square", "video", re] }],
      container: ["container"],
      columns: [{ columns: [Nr] }],
      "break-after": [{ "break-after": V() }],
      "break-before": [{ "break-before": V() }],
      "break-inside": [
        { "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }
      ],
      "box-decoration": [{ "box-decoration": ["slice", "clone"] }],
      box: [{ box: ["border", "content"] }],
      display: [
        "block",
        "inline-block",
        "inline",
        "flex",
        "inline-flex",
        "table",
        "inline-table",
        "table-caption",
        "table-cell",
        "table-column",
        "table-column-group",
        "table-footer-group",
        "table-header-group",
        "table-row-group",
        "table-row",
        "flow-root",
        "grid",
        "inline-grid",
        "contents",
        "list-item",
        "hidden"
      ],
      float: [{ float: ["right", "left", "none", "start", "end"] }],
      clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }],
      isolation: ["isolate", "isolation-auto"],
      "object-fit": [
        { object: ["contain", "cover", "fill", "none", "scale-down"] }
      ],
      "object-position": [{ object: [...D(), re] }],
      overflow: [{ overflow: C() }],
      "overflow-x": [{ "overflow-x": C() }],
      "overflow-y": [{ "overflow-y": C() }],
      overscroll: [{ overscroll: A() }],
      "overscroll-x": [{ "overscroll-x": A() }],
      "overscroll-y": [{ "overscroll-y": A() }],
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      inset: [{ inset: [m] }],
      "inset-x": [{ "inset-x": [m] }],
      "inset-y": [{ "inset-y": [m] }],
      start: [{ start: [m] }],
      end: [{ end: [m] }],
      top: [{ top: [m] }],
      right: [{ right: [m] }],
      bottom: [{ bottom: [m] }],
      left: [{ left: [m] }],
      visibility: ["visible", "invisible", "collapse"],
      z: [{ z: ["auto", Za, re] }],
      basis: [{ basis: T() }],
      "flex-direction": [
        { flex: ["row", "row-reverse", "col", "col-reverse"] }
      ],
      "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }],
      flex: [{ flex: ["1", "auto", "initial", "none", re] }],
      grow: [{ grow: I() }],
      shrink: [{ shrink: I() }],
      order: [{ order: ["first", "last", "none", Za, re] }],
      "grid-cols": [{ "grid-cols": [Ja] }],
      "col-start-end": [{ col: ["auto", { span: ["full", Za, re] }, re] }],
      "col-start": [{ "col-start": M() }],
      "col-end": [{ "col-end": M() }],
      "grid-rows": [{ "grid-rows": [Ja] }],
      "row-start-end": [{ row: ["auto", { span: [Za, re] }, re] }],
      "row-start": [{ "row-start": M() }],
      "row-end": [{ "row-end": M() }],
      "grid-flow": [
        { "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }
      ],
      "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", re] }],
      "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", re] }],
      gap: [{ gap: [d] }],
      "gap-x": [{ "gap-x": [d] }],
      "gap-y": [{ "gap-y": [d] }],
      "justify-content": [{ justify: ["normal", ...k()] }],
      "justify-items": [
        { "justify-items": ["start", "end", "center", "stretch"] }
      ],
      "justify-self": [
        { "justify-self": ["auto", "start", "end", "center", "stretch"] }
      ],
      "align-content": [{ content: ["normal", ...k(), "baseline"] }],
      "align-items": [
        { items: ["start", "end", "center", "baseline", "stretch"] }
      ],
      "align-self": [
        { self: ["auto", "start", "end", "center", "stretch", "baseline"] }
      ],
      "place-content": [{ "place-content": [...k(), "baseline"] }],
      "place-items": [
        { "place-items": ["start", "end", "center", "baseline", "stretch"] }
      ],
      "place-self": [
        { "place-self": ["auto", "start", "end", "center", "stretch"] }
      ],
      p: [{ p: [v] }],
      px: [{ px: [v] }],
      py: [{ py: [v] }],
      ps: [{ ps: [v] }],
      pe: [{ pe: [v] }],
      pt: [{ pt: [v] }],
      pr: [{ pr: [v] }],
      pb: [{ pb: [v] }],
      pl: [{ pl: [v] }],
      m: [{ m: [b] }],
      mx: [{ mx: [b] }],
      my: [{ my: [b] }],
      ms: [{ ms: [b] }],
      me: [{ me: [b] }],
      mt: [{ mt: [b] }],
      mr: [{ mr: [b] }],
      mb: [{ mb: [b] }],
      ml: [{ ml: [b] }],
      "space-x": [{ "space-x": [O] }],
      "space-x-reverse": ["space-x-reverse"],
      "space-y": [{ "space-y": [O] }],
      "space-y-reverse": ["space-y-reverse"],
      w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", re, t] }],
      "min-w": [{ "min-w": [re, t, "min", "max", "fit"] }],
      "max-w": [
        {
          "max-w": [
            re,
            t,
            "none",
            "full",
            "min",
            "max",
            "fit",
            "prose",
            { screen: [Nr] },
            Nr
          ]
        }
      ],
      h: [{ h: [re, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }],
      "min-h": [{ "min-h": [re, t, "min", "max", "fit", "svh", "lvh", "dvh"] }],
      "max-h": [{ "max-h": [re, t, "min", "max", "fit", "svh", "lvh", "dvh"] }],
      size: [{ size: [re, t, "auto", "min", "max", "fit"] }],
      "font-size": [{ text: ["base", Nr, Ir] }],
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      "font-style": ["italic", "not-italic"],
      "font-weight": [
        {
          font: [
            "thin",
            "extralight",
            "light",
            "normal",
            "medium",
            "semibold",
            "bold",
            "extrabold",
            "black",
            Iu
          ]
        }
      ],
      "font-family": [{ font: [Ja] }],
      "fvn-normal": ["normal-nums"],
      "fvn-ordinal": ["ordinal"],
      "fvn-slashed-zero": ["slashed-zero"],
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      tracking: [
        {
          tracking: [
            "tighter",
            "tight",
            "normal",
            "wide",
            "wider",
            "widest",
            re
          ]
        }
      ],
      "line-clamp": [{ "line-clamp": ["none", Bi, Iu] }],
      leading: [
        {
          leading: [
            "none",
            "tight",
            "snug",
            "normal",
            "relaxed",
            "loose",
            nr,
            re
          ]
        }
      ],
      "list-image": [{ "list-image": ["none", re] }],
      "list-style-type": [{ list: ["none", "disc", "decimal", re] }],
      "list-style-position": [{ list: ["inside", "outside"] }],
      "placeholder-color": [{ placeholder: [e] }],
      "placeholder-opacity": [{ "placeholder-opacity": [g] }],
      "text-alignment": [
        { text: ["left", "center", "right", "justify", "start", "end"] }
      ],
      "text-color": [{ text: [e] }],
      "text-opacity": [{ "text-opacity": [g] }],
      "text-decoration": [
        "underline",
        "overline",
        "line-through",
        "no-underline"
      ],
      "text-decoration-style": [{ decoration: [...N(), "wavy"] }],
      "text-decoration-thickness": [
        { decoration: ["auto", "from-font", nr, Ir] }
      ],
      "underline-offset": [{ "underline-offset": ["auto", nr, re] }],
      "text-decoration-color": [{ decoration: [e] }],
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }],
      indent: [{ indent: _() }],
      "vertical-align": [
        {
          align: [
            "baseline",
            "top",
            "middle",
            "bottom",
            "text-top",
            "text-bottom",
            "sub",
            "super",
            re
          ]
        }
      ],
      whitespace: [
        {
          whitespace: [
            "normal",
            "nowrap",
            "pre",
            "pre-line",
            "pre-wrap",
            "break-spaces"
          ]
        }
      ],
      break: [{ break: ["normal", "words", "all", "keep"] }],
      hyphens: [{ hyphens: ["none", "manual", "auto"] }],
      content: [{ content: ["none", re] }],
      "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }],
      "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }],
      "bg-opacity": [{ "bg-opacity": [g] }],
      "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }],
      "bg-position": [{ bg: [...D(), kD] }],
      "bg-repeat": [
        { bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] }
      ],
      "bg-size": [{ bg: ["auto", "cover", "contain", _D] }],
      "bg-image": [
        {
          bg: [
            "none",
            { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] },
            jD
          ]
        }
      ],
      "bg-color": [{ bg: [e] }],
      "gradient-from-pos": [{ from: [h] }],
      "gradient-via-pos": [{ via: [h] }],
      "gradient-to-pos": [{ to: [h] }],
      "gradient-from": [{ from: [p] }],
      "gradient-via": [{ via: [p] }],
      "gradient-to": [{ to: [p] }],
      rounded: [{ rounded: [o] }],
      "rounded-s": [{ "rounded-s": [o] }],
      "rounded-e": [{ "rounded-e": [o] }],
      "rounded-t": [{ "rounded-t": [o] }],
      "rounded-r": [{ "rounded-r": [o] }],
      "rounded-b": [{ "rounded-b": [o] }],
      "rounded-l": [{ "rounded-l": [o] }],
      "rounded-ss": [{ "rounded-ss": [o] }],
      "rounded-se": [{ "rounded-se": [o] }],
      "rounded-ee": [{ "rounded-ee": [o] }],
      "rounded-es": [{ "rounded-es": [o] }],
      "rounded-tl": [{ "rounded-tl": [o] }],
      "rounded-tr": [{ "rounded-tr": [o] }],
      "rounded-br": [{ "rounded-br": [o] }],
      "rounded-bl": [{ "rounded-bl": [o] }],
      "border-w": [{ border: [s] }],
      "border-w-x": [{ "border-x": [s] }],
      "border-w-y": [{ "border-y": [s] }],
      "border-w-s": [{ "border-s": [s] }],
      "border-w-e": [{ "border-e": [s] }],
      "border-w-t": [{ "border-t": [s] }],
      "border-w-r": [{ "border-r": [s] }],
      "border-w-b": [{ "border-b": [s] }],
      "border-w-l": [{ "border-l": [s] }],
      "border-opacity": [{ "border-opacity": [g] }],
      "border-style": [{ border: [...N(), "hidden"] }],
      "divide-x": [{ "divide-x": [s] }],
      "divide-x-reverse": ["divide-x-reverse"],
      "divide-y": [{ "divide-y": [s] }],
      "divide-y-reverse": ["divide-y-reverse"],
      "divide-opacity": [{ "divide-opacity": [g] }],
      "divide-style": [{ divide: N() }],
      "border-color": [{ border: [i] }],
      "border-color-x": [{ "border-x": [i] }],
      "border-color-y": [{ "border-y": [i] }],
      "border-color-t": [{ "border-t": [i] }],
      "border-color-r": [{ "border-r": [i] }],
      "border-color-b": [{ "border-b": [i] }],
      "border-color-l": [{ "border-l": [i] }],
      "divide-color": [{ divide: [i] }],
      "outline-style": [{ outline: ["", ...N()] }],
      "outline-offset": [{ "outline-offset": [nr, re] }],
      "outline-w": [{ outline: [nr, Ir] }],
      "outline-color": [{ outline: [e] }],
      "ring-w": [{ ring: R() }],
      "ring-w-inset": ["ring-inset"],
      "ring-color": [{ ring: [e] }],
      "ring-opacity": [{ "ring-opacity": [g] }],
      "ring-offset-w": [{ "ring-offset": [nr, Ir] }],
      "ring-offset-color": [{ "ring-offset": [e] }],
      shadow: [{ shadow: ["", "inner", "none", Nr, DD] }],
      "shadow-color": [{ shadow: [Ja] }],
      opacity: [{ opacity: [g] }],
      "mix-blend": [{ "mix-blend": L() }],
      "bg-blend": [{ "bg-blend": L() }],
      filter: [{ filter: ["", "none"] }],
      blur: [{ blur: [n] }],
      brightness: [{ brightness: [r] }],
      contrast: [{ contrast: [l] }],
      "drop-shadow": [{ "drop-shadow": ["", "none", Nr, re] }],
      grayscale: [{ grayscale: [u] }],
      "hue-rotate": [{ "hue-rotate": [f] }],
      invert: [{ invert: [c] }],
      saturate: [{ saturate: [y] }],
      sepia: [{ sepia: [x] }],
      "backdrop-filter": [{ "backdrop-filter": ["", "none"] }],
      "backdrop-blur": [{ "backdrop-blur": [n] }],
      "backdrop-brightness": [{ "backdrop-brightness": [r] }],
      "backdrop-contrast": [{ "backdrop-contrast": [l] }],
      "backdrop-grayscale": [{ "backdrop-grayscale": [u] }],
      "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [f] }],
      "backdrop-invert": [{ "backdrop-invert": [c] }],
      "backdrop-opacity": [{ "backdrop-opacity": [g] }],
      "backdrop-saturate": [{ "backdrop-saturate": [y] }],
      "backdrop-sepia": [{ "backdrop-sepia": [x] }],
      "border-collapse": [{ border: ["collapse", "separate"] }],
      "border-spacing": [{ "border-spacing": [a] }],
      "border-spacing-x": [{ "border-spacing-x": [a] }],
      "border-spacing-y": [{ "border-spacing-y": [a] }],
      "table-layout": [{ table: ["auto", "fixed"] }],
      caption: [{ caption: ["top", "bottom"] }],
      transition: [
        {
          transition: [
            "none",
            "all",
            "",
            "colors",
            "opacity",
            "shadow",
            "transform",
            re
          ]
        }
      ],
      duration: [{ duration: H() }],
      ease: [{ ease: ["linear", "in", "out", "in-out", re] }],
      delay: [{ delay: H() }],
      animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", re] }],
      transform: [{ transform: ["", "gpu", "none"] }],
      scale: [{ scale: [w] }],
      "scale-x": [{ "scale-x": [w] }],
      "scale-y": [{ "scale-y": [w] }],
      rotate: [{ rotate: [Za, re] }],
      "translate-x": [{ "translate-x": [$] }],
      "translate-y": [{ "translate-y": [$] }],
      "skew-x": [{ "skew-x": [S] }],
      "skew-y": [{ "skew-y": [S] }],
      "transform-origin": [
        {
          origin: [
            "center",
            "top",
            "top-right",
            "right",
            "bottom-right",
            "bottom",
            "bottom-left",
            "left",
            "top-left",
            re
          ]
        }
      ],
      accent: [{ accent: ["auto", e] }],
      appearance: [{ appearance: ["none", "auto"] }],
      cursor: [
        {
          cursor: [
            "auto",
            "default",
            "pointer",
            "wait",
            "text",
            "move",
            "help",
            "not-allowed",
            "none",
            "context-menu",
            "progress",
            "cell",
            "crosshair",
            "vertical-text",
            "alias",
            "copy",
            "no-drop",
            "grab",
            "grabbing",
            "all-scroll",
            "col-resize",
            "row-resize",
            "n-resize",
            "e-resize",
            "s-resize",
            "w-resize",
            "ne-resize",
            "nw-resize",
            "se-resize",
            "sw-resize",
            "ew-resize",
            "ns-resize",
            "nesw-resize",
            "nwse-resize",
            "zoom-in",
            "zoom-out",
            re
          ]
        }
      ],
      "caret-color": [{ caret: [e] }],
      "pointer-events": [{ "pointer-events": ["none", "auto"] }],
      resize: [{ resize: ["none", "y", "x", ""] }],
      "scroll-behavior": [{ scroll: ["auto", "smooth"] }],
      "scroll-m": [{ "scroll-m": _() }],
      "scroll-mx": [{ "scroll-mx": _() }],
      "scroll-my": [{ "scroll-my": _() }],
      "scroll-ms": [{ "scroll-ms": _() }],
      "scroll-me": [{ "scroll-me": _() }],
      "scroll-mt": [{ "scroll-mt": _() }],
      "scroll-mr": [{ "scroll-mr": _() }],
      "scroll-mb": [{ "scroll-mb": _() }],
      "scroll-ml": [{ "scroll-ml": _() }],
      "scroll-p": [{ "scroll-p": _() }],
      "scroll-px": [{ "scroll-px": _() }],
      "scroll-py": [{ "scroll-py": _() }],
      "scroll-ps": [{ "scroll-ps": _() }],
      "scroll-pe": [{ "scroll-pe": _() }],
      "scroll-pt": [{ "scroll-pt": _() }],
      "scroll-pr": [{ "scroll-pr": _() }],
      "scroll-pb": [{ "scroll-pb": _() }],
      "scroll-pl": [{ "scroll-pl": _() }],
      "snap-align": [{ snap: ["start", "end", "center", "align-none"] }],
      "snap-stop": [{ snap: ["normal", "always"] }],
      "snap-type": [{ snap: ["none", "x", "y", "both"] }],
      "snap-strictness": [{ snap: ["mandatory", "proximity"] }],
      touch: [{ touch: ["auto", "none", "manipulation"] }],
      "touch-x": [{ "touch-pan": ["x", "left", "right"] }],
      "touch-y": [{ "touch-pan": ["y", "up", "down"] }],
      "touch-pz": ["touch-pinch-zoom"],
      select: [{ select: ["none", "text", "all", "auto"] }],
      "will-change": [
        { "will-change": ["auto", "scroll", "contents", "transform", re] }
      ],
      fill: [{ fill: [e, "none"] }],
      "stroke-w": [{ stroke: [nr, Ir, Iu] }],
      stroke: [{ stroke: [e, "none"] }],
      sr: ["sr-only", "not-sr-only"],
      "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: [
        "inset-x",
        "inset-y",
        "start",
        "end",
        "top",
        "right",
        "bottom",
        "left"
      ],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": [
        "fvn-ordinal",
        "fvn-slashed-zero",
        "fvn-figure",
        "fvn-spacing",
        "fvn-fraction"
      ],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: [
        "rounded-s",
        "rounded-e",
        "rounded-t",
        "rounded-r",
        "rounded-b",
        "rounded-l",
        "rounded-ss",
        "rounded-se",
        "rounded-ee",
        "rounded-es",
        "rounded-tl",
        "rounded-tr",
        "rounded-br",
        "rounded-bl"
      ],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": [
        "border-w-s",
        "border-w-e",
        "border-w-t",
        "border-w-r",
        "border-w-b",
        "border-w-l"
      ],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": [
        "border-color-t",
        "border-color-r",
        "border-color-b",
        "border-color-l"
      ],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": [
        "scroll-mx",
        "scroll-my",
        "scroll-ms",
        "scroll-me",
        "scroll-mt",
        "scroll-mr",
        "scroll-mb",
        "scroll-ml"
      ],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": [
        "scroll-px",
        "scroll-py",
        "scroll-ps",
        "scroll-pe",
        "scroll-pt",
        "scroll-pr",
        "scroll-pb",
        "scroll-pl"
      ],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: { "font-size": ["leading"] }
  }
}
const BD = wD(LD)
function ot(...e) {
  return BD(Oe(e))
}
const iT = P.createContext({
    transformPagePoint: (e) => e,
    isStatic: !1,
    reducedMotion: "never"
  }),
  Sd = P.createContext({}),
  Oy = P.createContext(null),
  Od = typeof document < "u",
  FD = Od ? P.useLayoutEffect : P.useEffect,
  oT = P.createContext({ strict: !1 }),
  Py = (e) => e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
  VD = "framerAppearId",
  aT = "data-" + Py(VD)
function zD(e, t, n, r) {
  const { visualElement: i } = P.useContext(Sd),
    o = P.useContext(oT),
    a = P.useContext(Oy),
    s = P.useContext(iT).reducedMotion,
    l = P.useRef()
  ;(r = r || o.renderer),
    !l.current &&
      r &&
      (l.current = r(e, {
        visualState: t,
        parent: i,
        props: n,
        presenceContext: a,
        blockInitialAnimation: a ? a.initial === !1 : !1,
        reducedMotionConfig: s
      }))
  const u = l.current
  P.useInsertionEffect(() => {
    u && u.update(n, a)
  })
  const f = P.useRef(!!(n[aT] && !window.HandoffComplete))
  return (
    FD(() => {
      u &&
        (u.render(),
        f.current && u.animationState && u.animationState.animateChanges())
    }),
    P.useEffect(() => {
      u &&
        (u.updateFeatures(),
        !f.current && u.animationState && u.animationState.animateChanges(),
        f.current && ((f.current = !1), (window.HandoffComplete = !0)))
    }),
    u
  )
}
function ko(e) {
  return (
    typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current")
  )
}
function UD(e, t, n) {
  return P.useCallback(
    (r) => {
      r && e.mount && e.mount(r),
        t && (r ? t.mount(r) : t.unmount()),
        n && (typeof n == "function" ? n(r) : ko(n) && (n.current = r))
    },
    [t]
  )
}
function nl(e) {
  return typeof e == "string" || Array.isArray(e)
}
function Pd(e) {
  return typeof e == "object" && typeof e.start == "function"
}
const $y = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ],
  Ay = ["initial", ...$y]
function $d(e) {
  return Pd(e.animate) || Ay.some((t) => nl(e[t]))
}
function sT(e) {
  return !!($d(e) || e.variants)
}
function WD(e, t) {
  if ($d(e)) {
    const { initial: n, animate: r } = e
    return {
      initial: n === !1 || nl(n) ? n : void 0,
      animate: nl(r) ? r : void 0
    }
  }
  return e.inherit !== !1 ? t : {}
}
function HD(e) {
  const { initial: t, animate: n } = WD(e, P.useContext(Sd))
  return P.useMemo(() => ({ initial: t, animate: n }), [b1(t), b1(n)])
}
function b1(e) {
  return Array.isArray(e) ? e.join(" ") : e
}
const x1 = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
  },
  rl = {}
for (const e in x1) rl[e] = { isEnabled: (t) => x1[e].some((n) => !!t[n]) }
function GD(e) {
  for (const t in e) rl[t] = { ...rl[t], ...e[t] }
}
const lT = P.createContext({}),
  uT = P.createContext({}),
  KD = Symbol.for("motionComponentSymbol")
function qD({
  preloadedFeatures: e,
  createVisualElement: t,
  useRender: n,
  useVisualState: r,
  Component: i
}) {
  e && GD(e)
  function o(s, l) {
    let u
    const f = { ...P.useContext(iT), ...s, layoutId: XD(s) },
      { isStatic: c } = f,
      d = HD(s),
      p = r(s, c)
    if (!c && Od) {
      d.visualElement = zD(i, p, f, t)
      const h = P.useContext(uT),
        m = P.useContext(oT).strict
      d.visualElement && (u = d.visualElement.loadFeatures(f, m, e, h))
    }
    return P.createElement(
      Sd.Provider,
      { value: d },
      u && d.visualElement
        ? P.createElement(u, { visualElement: d.visualElement, ...f })
        : null,
      n(i, s, UD(p, d.visualElement, l), p, c, d.visualElement)
    )
  }
  const a = P.forwardRef(o)
  return (a[KD] = i), a
}
function XD({ layoutId: e }) {
  const t = P.useContext(lT).id
  return t && e !== void 0 ? t + "-" + e : e
}
function YD(e) {
  function t(r, i = {}) {
    return qD(e(r, i))
  }
  if (typeof Proxy > "u") return t
  const n = new Map()
  return new Proxy(t, { get: (r, i) => (n.has(i) || n.set(i, t(i)), n.get(i)) })
}
const QD = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
]
function Ty(e) {
  return typeof e != "string" || e.includes("-")
    ? !1
    : !!(QD.indexOf(e) > -1 || /[A-Z]/.test(e))
}
const Jc = {}
function ZD(e) {
  Object.assign(Jc, e)
}
const Jl = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ],
  oo = new Set(Jl)
function cT(e, { layout: t, layoutId: n }) {
  return (
    oo.has(e) ||
    e.startsWith("origin") ||
    ((t || n !== void 0) && (!!Jc[e] || e === "opacity"))
  )
}
const zt = (e) => !!(e && e.getVelocity),
  JD = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  },
  eI = Jl.length
function tI(
  e,
  { enableHardwareAcceleration: t = !0, allowTransformNone: n = !0 },
  r,
  i
) {
  let o = ""
  for (let a = 0; a < eI; a++) {
    const s = Jl[a]
    if (e[s] !== void 0) {
      const l = JD[s] || s
      o += `${l}(${e[s]}) `
    }
  }
  return (
    t && !e.z && (o += "translateZ(0)"),
    (o = o.trim()),
    i ? (o = i(e, r ? "" : o)) : n && r && (o = "none"),
    o
  )
}
const fT = (e) => (t) => typeof t == "string" && t.startsWith(e),
  dT = fT("--"),
  Hm = fT("var(--"),
  nI =
    /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
  rI = (e, t) => (t && typeof e == "number" ? t.transform(e) : e),
  fi = (e, t, n) => Math.min(Math.max(n, e), t),
  ao = {
    test: (e) => typeof e == "number",
    parse: parseFloat,
    transform: (e) => e
  },
  _s = { ...ao, transform: (e) => fi(0, 1, e) },
  Nu = { ...ao, default: 1 },
  ks = (e) => Math.round(e * 1e5) / 1e5,
  Ad = /(-)?([\d]*\.?[\d])+/g,
  pT =
    /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
  iI =
    /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i
function eu(e) {
  return typeof e == "string"
}
const tu = (e) => ({
    test: (t) => eu(t) && t.endsWith(e) && t.split(" ").length === 1,
    parse: parseFloat,
    transform: (t) => `${t}${e}`
  }),
  Lr = tu("deg"),
  Gn = tu("%"),
  J = tu("px"),
  oI = tu("vh"),
  aI = tu("vw"),
  w1 = {
    ...Gn,
    parse: (e) => Gn.parse(e) / 100,
    transform: (e) => Gn.transform(e * 100)
  },
  S1 = { ...ao, transform: Math.round },
  hT = {
    borderWidth: J,
    borderTopWidth: J,
    borderRightWidth: J,
    borderBottomWidth: J,
    borderLeftWidth: J,
    borderRadius: J,
    radius: J,
    borderTopLeftRadius: J,
    borderTopRightRadius: J,
    borderBottomRightRadius: J,
    borderBottomLeftRadius: J,
    width: J,
    maxWidth: J,
    height: J,
    maxHeight: J,
    size: J,
    top: J,
    right: J,
    bottom: J,
    left: J,
    padding: J,
    paddingTop: J,
    paddingRight: J,
    paddingBottom: J,
    paddingLeft: J,
    margin: J,
    marginTop: J,
    marginRight: J,
    marginBottom: J,
    marginLeft: J,
    rotate: Lr,
    rotateX: Lr,
    rotateY: Lr,
    rotateZ: Lr,
    scale: Nu,
    scaleX: Nu,
    scaleY: Nu,
    scaleZ: Nu,
    skew: Lr,
    skewX: Lr,
    skewY: Lr,
    distance: J,
    translateX: J,
    translateY: J,
    translateZ: J,
    x: J,
    y: J,
    z: J,
    perspective: J,
    transformPerspective: J,
    opacity: _s,
    originX: w1,
    originY: w1,
    originZ: J,
    zIndex: S1,
    fillOpacity: _s,
    strokeOpacity: _s,
    numOctaves: S1
  }
function Ey(e, t, n, r) {
  const { style: i, vars: o, transform: a, transformOrigin: s } = e
  let l = !1,
    u = !1,
    f = !0
  for (const c in t) {
    const d = t[c]
    if (dT(c)) {
      o[c] = d
      continue
    }
    const p = hT[c],
      h = rI(d, p)
    if (oo.has(c)) {
      if (((l = !0), (a[c] = h), !f)) continue
      d !== (p.default || 0) && (f = !1)
    } else c.startsWith("origin") ? ((u = !0), (s[c] = h)) : (i[c] = h)
  }
  if (
    (t.transform ||
      (l || r
        ? (i.transform = tI(e.transform, n, f, r))
        : i.transform && (i.transform = "none")),
    u)
  ) {
    const { originX: c = "50%", originY: d = "50%", originZ: p = 0 } = s
    i.transformOrigin = `${c} ${d} ${p}`
  }
}
const Cy = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} })
function mT(e, t, n) {
  for (const r in t) !zt(t[r]) && !cT(r, n) && (e[r] = t[r])
}
function sI({ transformTemplate: e }, t, n) {
  return P.useMemo(() => {
    const r = Cy()
    return (
      Ey(r, t, { enableHardwareAcceleration: !n }, e),
      Object.assign({}, r.vars, r.style)
    )
  }, [t])
}
function lI(e, t, n) {
  const r = e.style || {},
    i = {}
  return (
    mT(i, r, e),
    Object.assign(i, sI(e, t, n)),
    e.transformValues ? e.transformValues(i) : i
  )
}
function uI(e, t, n) {
  const r = {},
    i = lI(e, t, n)
  return (
    e.drag &&
      e.dragListener !== !1 &&
      ((r.draggable = !1),
      (i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none"),
      (i.touchAction =
        e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`)),
    e.tabIndex === void 0 &&
      (e.onTap || e.onTapStart || e.whileTap) &&
      (r.tabIndex = 0),
    (r.style = i),
    r
  )
}
const cI = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport"
])
function ef(e) {
  return (
    e.startsWith("while") ||
    (e.startsWith("drag") && e !== "draggable") ||
    e.startsWith("layout") ||
    e.startsWith("onTap") ||
    e.startsWith("onPan") ||
    cI.has(e)
  )
}
let vT = (e) => !ef(e)
function fI(e) {
  e && (vT = (t) => (t.startsWith("on") ? !ef(t) : e(t)))
}
try {
  fI(require("@emotion/is-prop-valid").default)
} catch {}
function dI(e, t, n) {
  const r = {}
  for (const i in e)
    (i === "values" && typeof e.values == "object") ||
      ((vT(i) ||
        (n === !0 && ef(i)) ||
        (!t && !ef(i)) ||
        (e.draggable && i.startsWith("onDrag"))) &&
        (r[i] = e[i]))
  return r
}
function O1(e, t, n) {
  return typeof e == "string" ? e : J.transform(t + n * e)
}
function pI(e, t, n) {
  const r = O1(t, e.x, e.width),
    i = O1(n, e.y, e.height)
  return `${r} ${i}`
}
const hI = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  mI = { offset: "strokeDashoffset", array: "strokeDasharray" }
function vI(e, t, n = 1, r = 0, i = !0) {
  e.pathLength = 1
  const o = i ? hI : mI
  e[o.offset] = J.transform(-r)
  const a = J.transform(t),
    s = J.transform(n)
  e[o.array] = `${a} ${s}`
}
function _y(
  e,
  {
    attrX: t,
    attrY: n,
    attrScale: r,
    originX: i,
    originY: o,
    pathLength: a,
    pathSpacing: s = 1,
    pathOffset: l = 0,
    ...u
  },
  f,
  c,
  d
) {
  if ((Ey(e, u, f, d), c)) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox)
    return
  }
  ;(e.attrs = e.style), (e.style = {})
  const { attrs: p, style: h, dimensions: m } = e
  p.transform && (m && (h.transform = p.transform), delete p.transform),
    m &&
      (i !== void 0 || o !== void 0 || h.transform) &&
      (h.transformOrigin = pI(
        m,
        i !== void 0 ? i : 0.5,
        o !== void 0 ? o : 0.5
      )),
    t !== void 0 && (p.x = t),
    n !== void 0 && (p.y = n),
    r !== void 0 && (p.scale = r),
    a !== void 0 && vI(p, a, s, l, !1)
}
const gT = () => ({ ...Cy(), attrs: {} }),
  ky = (e) => typeof e == "string" && e.toLowerCase() === "svg"
function gI(e, t, n, r) {
  const i = P.useMemo(() => {
    const o = gT()
    return (
      _y(o, t, { enableHardwareAcceleration: !1 }, ky(r), e.transformTemplate),
      { ...o.attrs, style: { ...o.style } }
    )
  }, [t])
  if (e.style) {
    const o = {}
    mT(o, e.style, e), (i.style = { ...o, ...i.style })
  }
  return i
}
function yI(e = !1) {
  return (n, r, i, { latestValues: o }, a) => {
    const l = (Ty(n) ? gI : uI)(r, o, a, n),
      f = { ...dI(r, typeof n == "string", e), ...l, ref: i },
      { children: c } = r,
      d = P.useMemo(() => (zt(c) ? c.get() : c), [c])
    return P.createElement(n, { ...f, children: d })
  }
}
function yT(e, { style: t, vars: n }, r, i) {
  Object.assign(e.style, t, i && i.getProjectionStyles(r))
  for (const o in n) e.style.setProperty(o, n[o])
}
const bT = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
])
function xT(e, t, n, r) {
  yT(e, t, void 0, r)
  for (const i in t.attrs) e.setAttribute(bT.has(i) ? i : Py(i), t.attrs[i])
}
function My(e, t) {
  const { style: n } = e,
    r = {}
  for (const i in n)
    (zt(n[i]) || (t.style && zt(t.style[i])) || cT(i, e)) && (r[i] = n[i])
  return r
}
function wT(e, t) {
  const n = My(e, t)
  for (const r in e)
    if (zt(e[r]) || zt(t[r])) {
      const i =
        Jl.indexOf(r) !== -1
          ? "attr" + r.charAt(0).toUpperCase() + r.substring(1)
          : r
      n[i] = e[r]
    }
  return n
}
function jy(e, t, n, r = {}, i = {}) {
  return (
    typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, r, i)),
    typeof t == "string" && (t = e.variants && e.variants[t]),
    typeof t == "function" && (t = t(n !== void 0 ? n : e.custom, r, i)),
    t
  )
}
function bI(e) {
  const t = P.useRef(null)
  return t.current === null && (t.current = e()), t.current
}
const tf = (e) => Array.isArray(e),
  xI = (e) => !!(e && typeof e == "object" && e.mix && e.toValue),
  wI = (e) => (tf(e) ? e[e.length - 1] || 0 : e)
function bc(e) {
  const t = zt(e) ? e.get() : e
  return xI(t) ? t.toValue() : t
}
function SI(
  { scrapeMotionValuesFromProps: e, createRenderState: t, onMount: n },
  r,
  i,
  o
) {
  const a = { latestValues: OI(r, i, o, e), renderState: t() }
  return n && (a.mount = (s) => n(r, s, a)), a
}
const ST = (e) => (t, n) => {
  const r = P.useContext(Sd),
    i = P.useContext(Oy),
    o = () => SI(e, t, r, i)
  return n ? o() : bI(o)
}
function OI(e, t, n, r) {
  const i = {},
    o = r(e, {})
  for (const d in o) i[d] = bc(o[d])
  let { initial: a, animate: s } = e
  const l = $d(e),
    u = sT(e)
  t &&
    u &&
    !l &&
    e.inherit !== !1 &&
    (a === void 0 && (a = t.initial), s === void 0 && (s = t.animate))
  let f = n ? n.initial === !1 : !1
  f = f || a === !1
  const c = f ? s : a
  return (
    c &&
      typeof c != "boolean" &&
      !Pd(c) &&
      (Array.isArray(c) ? c : [c]).forEach((p) => {
        const h = jy(e, p)
        if (!h) return
        const { transitionEnd: m, transition: b, ...g } = h
        for (const v in g) {
          let y = g[v]
          if (Array.isArray(y)) {
            const w = f ? y.length - 1 : 0
            y = y[w]
          }
          y !== null && (i[v] = y)
        }
        for (const v in m) i[v] = m[v]
      }),
    i
  )
}
const Ge = (e) => e
class P1 {
  constructor() {
    ;(this.order = []), (this.scheduled = new Set())
  }
  add(t) {
    if (!this.scheduled.has(t))
      return this.scheduled.add(t), this.order.push(t), !0
  }
  remove(t) {
    const n = this.order.indexOf(t)
    n !== -1 && (this.order.splice(n, 1), this.scheduled.delete(t))
  }
  clear() {
    ;(this.order.length = 0), this.scheduled.clear()
  }
}
function PI(e) {
  let t = new P1(),
    n = new P1(),
    r = 0,
    i = !1,
    o = !1
  const a = new WeakSet(),
    s = {
      schedule: (l, u = !1, f = !1) => {
        const c = f && i,
          d = c ? t : n
        return u && a.add(l), d.add(l) && c && i && (r = t.order.length), l
      },
      cancel: (l) => {
        n.remove(l), a.delete(l)
      },
      process: (l) => {
        if (i) {
          o = !0
          return
        }
        if (((i = !0), ([t, n] = [n, t]), n.clear(), (r = t.order.length), r))
          for (let u = 0; u < r; u++) {
            const f = t.order[u]
            f(l), a.has(f) && (s.schedule(f), e())
          }
        ;(i = !1), o && ((o = !1), s.process(l))
      }
    }
  return s
}
const Ru = ["prepare", "read", "update", "preRender", "render", "postRender"],
  $I = 40
function AI(e, t) {
  let n = !1,
    r = !0
  const i = { delta: 0, timestamp: 0, isProcessing: !1 },
    o = Ru.reduce((c, d) => ((c[d] = PI(() => (n = !0))), c), {}),
    a = (c) => o[c].process(i),
    s = () => {
      const c = performance.now()
      ;(n = !1),
        (i.delta = r ? 1e3 / 60 : Math.max(Math.min(c - i.timestamp, $I), 1)),
        (i.timestamp = c),
        (i.isProcessing = !0),
        Ru.forEach(a),
        (i.isProcessing = !1),
        n && t && ((r = !1), e(s))
    },
    l = () => {
      ;(n = !0), (r = !0), i.isProcessing || e(s)
    }
  return {
    schedule: Ru.reduce((c, d) => {
      const p = o[d]
      return (c[d] = (h, m = !1, b = !1) => (n || l(), p.schedule(h, m, b))), c
    }, {}),
    cancel: (c) => Ru.forEach((d) => o[d].cancel(c)),
    state: i,
    steps: o
  }
}
const {
    schedule: Me,
    cancel: xr,
    state: Ot,
    steps: Yp
  } = AI(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Ge, !0),
  TI = {
    useVisualState: ST({
      scrapeMotionValuesFromProps: wT,
      createRenderState: gT,
      onMount: (e, t, { renderState: n, latestValues: r }) => {
        Me.read(() => {
          try {
            n.dimensions =
              typeof t.getBBox == "function"
                ? t.getBBox()
                : t.getBoundingClientRect()
          } catch {
            n.dimensions = { x: 0, y: 0, width: 0, height: 0 }
          }
        }),
          Me.render(() => {
            _y(
              n,
              r,
              { enableHardwareAcceleration: !1 },
              ky(t.tagName),
              e.transformTemplate
            ),
              xT(t, n)
          })
      }
    })
  },
  EI = {
    useVisualState: ST({
      scrapeMotionValuesFromProps: My,
      createRenderState: Cy
    })
  }
function CI(e, { forwardMotionProps: t = !1 }, n, r) {
  return {
    ...(Ty(e) ? TI : EI),
    preloadedFeatures: n,
    useRender: yI(t),
    createVisualElement: r,
    Component: e
  }
}
function lr(e, t, n, r = { passive: !0 }) {
  return e.addEventListener(t, n, r), () => e.removeEventListener(t, n)
}
const OT = (e) =>
  e.pointerType === "mouse"
    ? typeof e.button != "number" || e.button <= 0
    : e.isPrimary !== !1
function Td(e, t = "page") {
  return { point: { x: e[t + "X"], y: e[t + "Y"] } }
}
const _I = (e) => (t) => OT(t) && e(t, Td(t))
function pr(e, t, n, r) {
  return lr(e, t, _I(n), r)
}
const kI = (e, t) => (n) => t(e(n)),
  oi = (...e) => e.reduce(kI)
function PT(e) {
  let t = null
  return () => {
    const n = () => {
      t = null
    }
    return t === null ? ((t = e), n) : !1
  }
}
const $1 = PT("dragHorizontal"),
  A1 = PT("dragVertical")
function $T(e) {
  let t = !1
  if (e === "y") t = A1()
  else if (e === "x") t = $1()
  else {
    const n = $1(),
      r = A1()
    n && r
      ? (t = () => {
          n(), r()
        })
      : (n && n(), r && r())
  }
  return t
}
function AT() {
  const e = $T(!0)
  return e ? (e(), !1) : !0
}
class xi {
  constructor(t) {
    ;(this.isMounted = !1), (this.node = t)
  }
  update() {}
}
function T1(e, t) {
  const n = "pointer" + (t ? "enter" : "leave"),
    r = "onHover" + (t ? "Start" : "End"),
    i = (o, a) => {
      if (o.type === "touch" || AT()) return
      const s = e.getProps()
      e.animationState &&
        s.whileHover &&
        e.animationState.setActive("whileHover", t),
        s[r] && Me.update(() => s[r](o, a))
    }
  return pr(e.current, n, i, { passive: !e.getProps()[r] })
}
class MI extends xi {
  mount() {
    this.unmount = oi(T1(this.node, !0), T1(this.node, !1))
  }
  unmount() {}
}
class jI extends xi {
  constructor() {
    super(...arguments), (this.isActive = !1)
  }
  onFocus() {
    let t = !1
    try {
      t = this.node.current.matches(":focus-visible")
    } catch {
      t = !0
    }
    !t ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0))
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1))
  }
  mount() {
    this.unmount = oi(
      lr(this.node.current, "focus", () => this.onFocus()),
      lr(this.node.current, "blur", () => this.onBlur())
    )
  }
  unmount() {}
}
const TT = (e, t) => (t ? (e === t ? !0 : TT(e, t.parentElement)) : !1)
function Qp(e, t) {
  if (!t) return
  const n = new PointerEvent("pointer" + e)
  t(n, Td(n))
}
class DI extends xi {
  constructor() {
    super(...arguments),
      (this.removeStartListeners = Ge),
      (this.removeEndListeners = Ge),
      (this.removeAccessibleListeners = Ge),
      (this.startPointerPress = (t, n) => {
        if ((this.removeEndListeners(), this.isPressing)) return
        const r = this.node.getProps(),
          o = pr(
            window,
            "pointerup",
            (s, l) => {
              if (!this.checkPressEnd()) return
              const { onTap: u, onTapCancel: f } = this.node.getProps()
              Me.update(() => {
                TT(this.node.current, s.target) ? u && u(s, l) : f && f(s, l)
              })
            },
            { passive: !(r.onTap || r.onPointerUp) }
          ),
          a = pr(window, "pointercancel", (s, l) => this.cancelPress(s, l), {
            passive: !(r.onTapCancel || r.onPointerCancel)
          })
        ;(this.removeEndListeners = oi(o, a)), this.startPress(t, n)
      }),
      (this.startAccessiblePress = () => {
        const t = (o) => {
            if (o.key !== "Enter" || this.isPressing) return
            const a = (s) => {
              s.key !== "Enter" ||
                !this.checkPressEnd() ||
                Qp("up", (l, u) => {
                  const { onTap: f } = this.node.getProps()
                  f && Me.update(() => f(l, u))
                })
            }
            this.removeEndListeners(),
              (this.removeEndListeners = lr(this.node.current, "keyup", a)),
              Qp("down", (s, l) => {
                this.startPress(s, l)
              })
          },
          n = lr(this.node.current, "keydown", t),
          r = () => {
            this.isPressing && Qp("cancel", (o, a) => this.cancelPress(o, a))
          },
          i = lr(this.node.current, "blur", r)
        this.removeAccessibleListeners = oi(n, i)
      })
  }
  startPress(t, n) {
    this.isPressing = !0
    const { onTapStart: r, whileTap: i } = this.node.getProps()
    i &&
      this.node.animationState &&
      this.node.animationState.setActive("whileTap", !0),
      r && Me.update(() => r(t, n))
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive("whileTap", !1),
      !AT()
    )
  }
  cancelPress(t, n) {
    if (!this.checkPressEnd()) return
    const { onTapCancel: r } = this.node.getProps()
    r && Me.update(() => r(t, n))
  }
  mount() {
    const t = this.node.getProps(),
      n = pr(this.node.current, "pointerdown", this.startPointerPress, {
        passive: !(t.onTapStart || t.onPointerStart)
      }),
      r = lr(this.node.current, "focus", this.startAccessiblePress)
    this.removeStartListeners = oi(n, r)
  }
  unmount() {
    this.removeStartListeners(),
      this.removeEndListeners(),
      this.removeAccessibleListeners()
  }
}
const Gm = new WeakMap(),
  Zp = new WeakMap(),
  II = (e) => {
    const t = Gm.get(e.target)
    t && t(e)
  },
  NI = (e) => {
    e.forEach(II)
  }
function RI({ root: e, ...t }) {
  const n = e || document
  Zp.has(n) || Zp.set(n, {})
  const r = Zp.get(n),
    i = JSON.stringify(t)
  return r[i] || (r[i] = new IntersectionObserver(NI, { root: e, ...t })), r[i]
}
function LI(e, t, n) {
  const r = RI(t)
  return (
    Gm.set(e, n),
    r.observe(e),
    () => {
      Gm.delete(e), r.unobserve(e)
    }
  )
}
const BI = { some: 0, all: 1 }
class FI extends xi {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1)
  }
  startObserver() {
    this.unmount()
    const { viewport: t = {} } = this.node.getProps(),
      { root: n, margin: r, amount: i = "some", once: o } = t,
      a = {
        root: n ? n.current : void 0,
        rootMargin: r,
        threshold: typeof i == "number" ? i : BI[i]
      },
      s = (l) => {
        const { isIntersecting: u } = l
        if (
          this.isInView === u ||
          ((this.isInView = u), o && !u && this.hasEnteredView)
        )
          return
        u && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", u)
        const { onViewportEnter: f, onViewportLeave: c } = this.node.getProps(),
          d = u ? f : c
        d && d(l)
      }
    return LI(this.node.current, a, s)
  }
  mount() {
    this.startObserver()
  }
  update() {
    if (typeof IntersectionObserver > "u") return
    const { props: t, prevProps: n } = this.node
    ;["amount", "margin", "root"].some(VI(t, n)) && this.startObserver()
  }
  unmount() {}
}
function VI({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n]
}
const zI = {
  inView: { Feature: FI },
  tap: { Feature: DI },
  focus: { Feature: jI },
  hover: { Feature: MI }
}
function ET(e, t) {
  if (!Array.isArray(t)) return !1
  const n = t.length
  if (n !== e.length) return !1
  for (let r = 0; r < n; r++) if (t[r] !== e[r]) return !1
  return !0
}
function UI(e) {
  const t = {}
  return e.values.forEach((n, r) => (t[r] = n.get())), t
}
function WI(e) {
  const t = {}
  return e.values.forEach((n, r) => (t[r] = n.getVelocity())), t
}
function Ed(e, t, n) {
  const r = e.getProps()
  return jy(r, t, n !== void 0 ? n : r.custom, UI(e), WI(e))
}
let Dy = Ge
const Gi = (e) => e * 1e3,
  hr = (e) => e / 1e3,
  HI = { current: !1 },
  CT = (e) => Array.isArray(e) && typeof e[0] == "number"
function _T(e) {
  return !!(
    !e ||
    (typeof e == "string" && kT[e]) ||
    CT(e) ||
    (Array.isArray(e) && e.every(_T))
  )
}
const ys = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`,
  kT = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: ys([0, 0.65, 0.55, 1]),
    circOut: ys([0.55, 0, 1, 0.45]),
    backIn: ys([0.31, 0.01, 0.66, -0.59]),
    backOut: ys([0.33, 1.53, 0.69, 0.99])
  }
function MT(e) {
  if (e) return CT(e) ? ys(e) : Array.isArray(e) ? e.map(MT) : kT[e]
}
function GI(
  e,
  t,
  n,
  {
    delay: r = 0,
    duration: i,
    repeat: o = 0,
    repeatType: a = "loop",
    ease: s,
    times: l
  } = {}
) {
  const u = { [t]: n }
  l && (u.offset = l)
  const f = MT(s)
  return (
    Array.isArray(f) && (u.easing = f),
    e.animate(u, {
      delay: r,
      duration: i,
      easing: Array.isArray(f) ? "linear" : f,
      fill: "both",
      iterations: o + 1,
      direction: a === "reverse" ? "alternate" : "normal"
    })
  )
}
function KI(e, { repeat: t, repeatType: n = "loop" }) {
  const r = t && n !== "loop" && t % 2 === 1 ? 0 : e.length - 1
  return e[r]
}
const jT = (e, t, n) =>
    (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e,
  qI = 1e-7,
  XI = 12
function YI(e, t, n, r, i) {
  let o,
    a,
    s = 0
  do (a = t + (n - t) / 2), (o = jT(a, r, i) - e), o > 0 ? (n = a) : (t = a)
  while (Math.abs(o) > qI && ++s < XI)
  return a
}
function nu(e, t, n, r) {
  if (e === t && n === r) return Ge
  const i = (o) => YI(o, 0, 1, e, n)
  return (o) => (o === 0 || o === 1 ? o : jT(i(o), t, r))
}
const QI = nu(0.42, 0, 1, 1),
  ZI = nu(0, 0, 0.58, 1),
  DT = nu(0.42, 0, 0.58, 1),
  JI = (e) => Array.isArray(e) && typeof e[0] != "number",
  IT = (e) => (t) => (t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2),
  NT = (e) => (t) => 1 - e(1 - t),
  Iy = (e) => 1 - Math.sin(Math.acos(e)),
  RT = NT(Iy),
  eN = IT(Iy),
  LT = nu(0.33, 1.53, 0.69, 0.99),
  Ny = NT(LT),
  tN = IT(Ny),
  nN = (e) =>
    (e *= 2) < 1 ? 0.5 * Ny(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))),
  rN = {
    linear: Ge,
    easeIn: QI,
    easeInOut: DT,
    easeOut: ZI,
    circIn: Iy,
    circInOut: eN,
    circOut: RT,
    backIn: Ny,
    backInOut: tN,
    backOut: LT,
    anticipate: nN
  },
  E1 = (e) => {
    if (Array.isArray(e)) {
      Dy(e.length === 4)
      const [t, n, r, i] = e
      return nu(t, n, r, i)
    } else if (typeof e == "string") return rN[e]
    return e
  },
  Ry = (e, t) => (n) =>
    !!(
      (eu(n) && iI.test(n) && n.startsWith(e)) ||
      (t && Object.prototype.hasOwnProperty.call(n, t))
    ),
  BT = (e, t, n) => (r) => {
    if (!eu(r)) return r
    const [i, o, a, s] = r.match(Ad)
    return {
      [e]: parseFloat(i),
      [t]: parseFloat(o),
      [n]: parseFloat(a),
      alpha: s !== void 0 ? parseFloat(s) : 1
    }
  },
  iN = (e) => fi(0, 255, e),
  Jp = { ...ao, transform: (e) => Math.round(iN(e)) },
  Fi = {
    test: Ry("rgb", "red"),
    parse: BT("red", "green", "blue"),
    transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) =>
      "rgba(" +
      Jp.transform(e) +
      ", " +
      Jp.transform(t) +
      ", " +
      Jp.transform(n) +
      ", " +
      ks(_s.transform(r)) +
      ")"
  }
function oN(e) {
  let t = "",
    n = "",
    r = "",
    i = ""
  return (
    e.length > 5
      ? ((t = e.substring(1, 3)),
        (n = e.substring(3, 5)),
        (r = e.substring(5, 7)),
        (i = e.substring(7, 9)))
      : ((t = e.substring(1, 2)),
        (n = e.substring(2, 3)),
        (r = e.substring(3, 4)),
        (i = e.substring(4, 5)),
        (t += t),
        (n += n),
        (r += r),
        (i += i)),
    {
      red: parseInt(t, 16),
      green: parseInt(n, 16),
      blue: parseInt(r, 16),
      alpha: i ? parseInt(i, 16) / 255 : 1
    }
  )
}
const Km = { test: Ry("#"), parse: oN, transform: Fi.transform },
  Mo = {
    test: Ry("hsl", "hue"),
    parse: BT("hue", "saturation", "lightness"),
    transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) =>
      "hsla(" +
      Math.round(e) +
      ", " +
      Gn.transform(ks(t)) +
      ", " +
      Gn.transform(ks(n)) +
      ", " +
      ks(_s.transform(r)) +
      ")"
  },
  Ct = {
    test: (e) => Fi.test(e) || Km.test(e) || Mo.test(e),
    parse: (e) =>
      Fi.test(e) ? Fi.parse(e) : Mo.test(e) ? Mo.parse(e) : Km.parse(e),
    transform: (e) =>
      eu(e) ? e : e.hasOwnProperty("red") ? Fi.transform(e) : Mo.transform(e)
  },
  Fe = (e, t, n) => -n * e + n * t + e
function eh(e, t, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? e + (t - e) * 6 * n
      : n < 1 / 2
        ? t
        : n < 2 / 3
          ? e + (t - e) * (2 / 3 - n) * 6
          : e
  )
}
function aN({ hue: e, saturation: t, lightness: n, alpha: r }) {
  ;(e /= 360), (t /= 100), (n /= 100)
  let i = 0,
    o = 0,
    a = 0
  if (!t) i = o = a = n
  else {
    const s = n < 0.5 ? n * (1 + t) : n + t - n * t,
      l = 2 * n - s
    ;(i = eh(l, s, e + 1 / 3)), (o = eh(l, s, e)), (a = eh(l, s, e - 1 / 3))
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(o * 255),
    blue: Math.round(a * 255),
    alpha: r
  }
}
const th = (e, t, n) => {
    const r = e * e
    return Math.sqrt(Math.max(0, n * (t * t - r) + r))
  },
  sN = [Km, Fi, Mo],
  lN = (e) => sN.find((t) => t.test(e))
function C1(e) {
  const t = lN(e)
  let n = t.parse(e)
  return t === Mo && (n = aN(n)), n
}
const FT = (e, t) => {
  const n = C1(e),
    r = C1(t),
    i = { ...n }
  return (o) => (
    (i.red = th(n.red, r.red, o)),
    (i.green = th(n.green, r.green, o)),
    (i.blue = th(n.blue, r.blue, o)),
    (i.alpha = Fe(n.alpha, r.alpha, o)),
    Fi.transform(i)
  )
}
function uN(e) {
  var t, n
  return (
    isNaN(e) &&
    eu(e) &&
    (((t = e.match(Ad)) === null || t === void 0 ? void 0 : t.length) || 0) +
      (((n = e.match(pT)) === null || n === void 0 ? void 0 : n.length) || 0) >
      0
  )
}
const VT = { regex: nI, countKey: "Vars", token: "${v}", parse: Ge },
  zT = { regex: pT, countKey: "Colors", token: "${c}", parse: Ct.parse },
  UT = { regex: Ad, countKey: "Numbers", token: "${n}", parse: ao.parse }
function nh(e, { regex: t, countKey: n, token: r, parse: i }) {
  const o = e.tokenised.match(t)
  o &&
    ((e["num" + n] = o.length),
    (e.tokenised = e.tokenised.replace(t, r)),
    e.values.push(...o.map(i)))
}
function nf(e) {
  const t = e.toString(),
    n = {
      value: t,
      tokenised: t,
      values: [],
      numVars: 0,
      numColors: 0,
      numNumbers: 0
    }
  return n.value.includes("var(--") && nh(n, VT), nh(n, zT), nh(n, UT), n
}
function WT(e) {
  return nf(e).values
}
function HT(e) {
  const { values: t, numColors: n, numVars: r, tokenised: i } = nf(e),
    o = t.length
  return (a) => {
    let s = i
    for (let l = 0; l < o; l++)
      l < r
        ? (s = s.replace(VT.token, a[l]))
        : l < r + n
          ? (s = s.replace(zT.token, Ct.transform(a[l])))
          : (s = s.replace(UT.token, ks(a[l])))
    return s
  }
}
const cN = (e) => (typeof e == "number" ? 0 : e)
function fN(e) {
  const t = WT(e)
  return HT(e)(t.map(cN))
}
const di = {
    test: uN,
    parse: WT,
    createTransformer: HT,
    getAnimatableNone: fN
  },
  GT = (e, t) => (n) => `${n > 0 ? t : e}`
function KT(e, t) {
  return typeof e == "number"
    ? (n) => Fe(e, t, n)
    : Ct.test(e)
      ? FT(e, t)
      : e.startsWith("var(")
        ? GT(e, t)
        : XT(e, t)
}
const qT = (e, t) => {
    const n = [...e],
      r = n.length,
      i = e.map((o, a) => KT(o, t[a]))
    return (o) => {
      for (let a = 0; a < r; a++) n[a] = i[a](o)
      return n
    }
  },
  dN = (e, t) => {
    const n = { ...e, ...t },
      r = {}
    for (const i in n)
      e[i] !== void 0 && t[i] !== void 0 && (r[i] = KT(e[i], t[i]))
    return (i) => {
      for (const o in r) n[o] = r[o](i)
      return n
    }
  },
  XT = (e, t) => {
    const n = di.createTransformer(t),
      r = nf(e),
      i = nf(t)
    return r.numVars === i.numVars &&
      r.numColors === i.numColors &&
      r.numNumbers >= i.numNumbers
      ? oi(qT(r.values, i.values), n)
      : GT(e, t)
  },
  il = (e, t, n) => {
    const r = t - e
    return r === 0 ? 1 : (n - e) / r
  },
  _1 = (e, t) => (n) => Fe(e, t, n)
function pN(e) {
  return typeof e == "number"
    ? _1
    : typeof e == "string"
      ? Ct.test(e)
        ? FT
        : XT
      : Array.isArray(e)
        ? qT
        : typeof e == "object"
          ? dN
          : _1
}
function hN(e, t, n) {
  const r = [],
    i = n || pN(e[0]),
    o = e.length - 1
  for (let a = 0; a < o; a++) {
    let s = i(e[a], e[a + 1])
    if (t) {
      const l = Array.isArray(t) ? t[a] || Ge : t
      s = oi(l, s)
    }
    r.push(s)
  }
  return r
}
function YT(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) {
  const o = e.length
  if ((Dy(o === t.length), o === 1)) return () => t[0]
  e[0] > e[o - 1] && ((e = [...e].reverse()), (t = [...t].reverse()))
  const a = hN(t, r, i),
    s = a.length,
    l = (u) => {
      let f = 0
      if (s > 1) for (; f < e.length - 2 && !(u < e[f + 1]); f++);
      const c = il(e[f], e[f + 1], u)
      return a[f](c)
    }
  return n ? (u) => l(fi(e[0], e[o - 1], u)) : l
}
function mN(e, t) {
  const n = e[e.length - 1]
  for (let r = 1; r <= t; r++) {
    const i = il(0, t, r)
    e.push(Fe(n, 1, i))
  }
}
function vN(e) {
  const t = [0]
  return mN(t, e.length - 1), t
}
function gN(e, t) {
  return e.map((n) => n * t)
}
function yN(e, t) {
  return e.map(() => t || DT).splice(0, e.length - 1)
}
function rf({
  duration: e = 300,
  keyframes: t,
  times: n,
  ease: r = "easeInOut"
}) {
  const i = JI(r) ? r.map(E1) : E1(r),
    o = { done: !1, value: t[0] },
    a = gN(n && n.length === t.length ? n : vN(t), e),
    s = YT(a, t, { ease: Array.isArray(i) ? i : yN(t, i) })
  return {
    calculatedDuration: e,
    next: (l) => ((o.value = s(l)), (o.done = l >= e), o)
  }
}
function QT(e, t) {
  return t ? e * (1e3 / t) : 0
}
const bN = 5
function ZT(e, t, n) {
  const r = Math.max(t - bN, 0)
  return QT(n - e(r), t - r)
}
const rh = 0.001,
  xN = 0.01,
  wN = 10,
  SN = 0.05,
  ON = 1
function PN({
  duration: e = 800,
  bounce: t = 0.25,
  velocity: n = 0,
  mass: r = 1
}) {
  let i,
    o,
    a = 1 - t
  ;(a = fi(SN, ON, a)),
    (e = fi(xN, wN, hr(e))),
    a < 1
      ? ((i = (u) => {
          const f = u * a,
            c = f * e,
            d = f - n,
            p = qm(u, a),
            h = Math.exp(-c)
          return rh - (d / p) * h
        }),
        (o = (u) => {
          const c = u * a * e,
            d = c * n + n,
            p = Math.pow(a, 2) * Math.pow(u, 2) * e,
            h = Math.exp(-c),
            m = qm(Math.pow(u, 2), a)
          return ((-i(u) + rh > 0 ? -1 : 1) * ((d - p) * h)) / m
        }))
      : ((i = (u) => {
          const f = Math.exp(-u * e),
            c = (u - n) * e + 1
          return -rh + f * c
        }),
        (o = (u) => {
          const f = Math.exp(-u * e),
            c = (n - u) * (e * e)
          return f * c
        }))
  const s = 5 / e,
    l = AN(i, o, s)
  if (((e = Gi(e)), isNaN(l)))
    return { stiffness: 100, damping: 10, duration: e }
  {
    const u = Math.pow(l, 2) * r
    return { stiffness: u, damping: a * 2 * Math.sqrt(r * u), duration: e }
  }
}
const $N = 12
function AN(e, t, n) {
  let r = n
  for (let i = 1; i < $N; i++) r = r - e(r) / t(r)
  return r
}
function qm(e, t) {
  return e * Math.sqrt(1 - t * t)
}
const TN = ["duration", "bounce"],
  EN = ["stiffness", "damping", "mass"]
function k1(e, t) {
  return t.some((n) => e[n] !== void 0)
}
function CN(e) {
  let t = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...e
  }
  if (!k1(e, EN) && k1(e, TN)) {
    const n = PN(e)
    ;(t = { ...t, ...n, mass: 1 }), (t.isResolvedFromDuration = !0)
  }
  return t
}
function JT({ keyframes: e, restDelta: t, restSpeed: n, ...r }) {
  const i = e[0],
    o = e[e.length - 1],
    a = { done: !1, value: i },
    {
      stiffness: s,
      damping: l,
      mass: u,
      duration: f,
      velocity: c,
      isResolvedFromDuration: d
    } = CN({ ...r, velocity: -hr(r.velocity || 0) }),
    p = c || 0,
    h = l / (2 * Math.sqrt(s * u)),
    m = o - i,
    b = hr(Math.sqrt(s / u)),
    g = Math.abs(m) < 5
  n || (n = g ? 0.01 : 2), t || (t = g ? 0.005 : 0.5)
  let v
  if (h < 1) {
    const y = qm(b, h)
    v = (w) => {
      const x = Math.exp(-h * b * w)
      return (
        o - x * (((p + h * b * m) / y) * Math.sin(y * w) + m * Math.cos(y * w))
      )
    }
  } else if (h === 1) v = (y) => o - Math.exp(-b * y) * (m + (p + b * m) * y)
  else {
    const y = b * Math.sqrt(h * h - 1)
    v = (w) => {
      const x = Math.exp(-h * b * w),
        S = Math.min(y * w, 300)
      return (
        o - (x * ((p + h * b * m) * Math.sinh(S) + y * m * Math.cosh(S))) / y
      )
    }
  }
  return {
    calculatedDuration: (d && f) || null,
    next: (y) => {
      const w = v(y)
      if (d) a.done = y >= f
      else {
        let x = p
        y !== 0 && (h < 1 ? (x = ZT(v, y, w)) : (x = 0))
        const S = Math.abs(x) <= n,
          O = Math.abs(o - w) <= t
        a.done = S && O
      }
      return (a.value = a.done ? o : w), a
    }
  }
}
function M1({
  keyframes: e,
  velocity: t = 0,
  power: n = 0.8,
  timeConstant: r = 325,
  bounceDamping: i = 10,
  bounceStiffness: o = 500,
  modifyTarget: a,
  min: s,
  max: l,
  restDelta: u = 0.5,
  restSpeed: f
}) {
  const c = e[0],
    d = { done: !1, value: c },
    p = ($) => (s !== void 0 && $ < s) || (l !== void 0 && $ > l),
    h = ($) =>
      s === void 0
        ? l
        : l === void 0 || Math.abs(s - $) < Math.abs(l - $)
          ? s
          : l
  let m = n * t
  const b = c + m,
    g = a === void 0 ? b : a(b)
  g !== b && (m = g - c)
  const v = ($) => -m * Math.exp(-$ / r),
    y = ($) => g + v($),
    w = ($) => {
      const A = v($),
        C = y($)
      ;(d.done = Math.abs(A) <= u), (d.value = d.done ? g : C)
    }
  let x, S
  const O = ($) => {
    p(d.value) &&
      ((x = $),
      (S = JT({
        keyframes: [d.value, h(d.value)],
        velocity: ZT(y, $, d.value),
        damping: i,
        stiffness: o,
        restDelta: u,
        restSpeed: f
      })))
  }
  return (
    O(0),
    {
      calculatedDuration: null,
      next: ($) => {
        let A = !1
        return (
          !S && x === void 0 && ((A = !0), w($), O($)),
          x !== void 0 && $ > x ? S.next($ - x) : (!A && w($), d)
        )
      }
    }
  )
}
const _N = (e) => {
    const t = ({ timestamp: n }) => e(n)
    return {
      start: () => Me.update(t, !0),
      stop: () => xr(t),
      now: () => (Ot.isProcessing ? Ot.timestamp : performance.now())
    }
  },
  j1 = 2e4
function D1(e) {
  let t = 0
  const n = 50
  let r = e.next(t)
  for (; !r.done && t < j1; ) (t += n), (r = e.next(t))
  return t >= j1 ? 1 / 0 : t
}
const kN = { decay: M1, inertia: M1, tween: rf, keyframes: rf, spring: JT }
function of({
  autoplay: e = !0,
  delay: t = 0,
  driver: n = _N,
  keyframes: r,
  type: i = "keyframes",
  repeat: o = 0,
  repeatDelay: a = 0,
  repeatType: s = "loop",
  onPlay: l,
  onStop: u,
  onComplete: f,
  onUpdate: c,
  ...d
}) {
  let p = 1,
    h = !1,
    m,
    b
  const g = () => {
    b = new Promise((U) => {
      m = U
    })
  }
  g()
  let v
  const y = kN[i] || rf
  let w
  y !== rf &&
    typeof r[0] != "number" &&
    ((w = YT([0, 100], r, { clamp: !1 })), (r = [0, 100]))
  const x = y({ ...d, keyframes: r })
  let S
  s === "mirror" &&
    (S = y({ ...d, keyframes: [...r].reverse(), velocity: -(d.velocity || 0) }))
  let O = "idle",
    $ = null,
    A = null,
    C = null
  x.calculatedDuration === null && o && (x.calculatedDuration = D1(x))
  const { calculatedDuration: T } = x
  let _ = 1 / 0,
    R = 1 / 0
  T !== null && ((_ = T + a), (R = _ * (o + 1) - a))
  let M = 0
  const D = (U) => {
      if (A === null) return
      p > 0 && (A = Math.min(A, U)),
        p < 0 && (A = Math.min(U - R / p, A)),
        $ !== null ? (M = $) : (M = Math.round(U - A) * p)
      const H = M - t * (p >= 0 ? 1 : -1),
        ee = p >= 0 ? H < 0 : H > R
      ;(M = Math.max(H, 0)), O === "finished" && $ === null && (M = R)
      let X = M,
        de = x
      if (o) {
        const W = M / _
        let Q = Math.floor(W),
          Z = W % 1
        !Z && W >= 1 && (Z = 1), Z === 1 && Q--, (Q = Math.min(Q, o + 1))
        const F = !!(Q % 2)
        F &&
          (s === "reverse"
            ? ((Z = 1 - Z), a && (Z -= a / _))
            : s === "mirror" && (de = S))
        let me = fi(0, 1, Z)
        M > R && (me = s === "reverse" && F ? 1 : 0), (X = me * _)
      }
      const ue = ee ? { done: !1, value: r[0] } : de.next(X)
      w && (ue.value = w(ue.value))
      let { done: We } = ue
      !ee && T !== null && (We = p >= 0 ? M >= R : M <= 0)
      const Qe = $ === null && (O === "finished" || (O === "running" && We))
      return c && c(ue.value), Qe && k(), ue
    },
    N = () => {
      v && v.stop(), (v = void 0)
    },
    L = () => {
      ;(O = "idle"), N(), m(), g(), (A = C = null)
    },
    k = () => {
      ;(O = "finished"), f && f(), N(), m()
    },
    I = () => {
      if (h) return
      v || (v = n(D))
      const U = v.now()
      l && l(),
        $ !== null ? (A = U - $) : (!A || O === "finished") && (A = U),
        O === "finished" && g(),
        (C = A),
        ($ = null),
        (O = "running"),
        v.start()
    }
  e && I()
  const V = {
    then(U, H) {
      return b.then(U, H)
    },
    get time() {
      return hr(M)
    },
    set time(U) {
      ;(U = Gi(U)),
        (M = U),
        $ !== null || !v || p === 0 ? ($ = U) : (A = v.now() - U / p)
    },
    get duration() {
      const U = x.calculatedDuration === null ? D1(x) : x.calculatedDuration
      return hr(U)
    },
    get speed() {
      return p
    },
    set speed(U) {
      U === p || !v || ((p = U), (V.time = hr(M)))
    },
    get state() {
      return O
    },
    play: I,
    pause: () => {
      ;(O = "paused"), ($ = M)
    },
    stop: () => {
      ;(h = !0), O !== "idle" && ((O = "idle"), u && u(), L())
    },
    cancel: () => {
      C !== null && D(C), L()
    },
    complete: () => {
      O = "finished"
    },
    sample: (U) => ((A = 0), D(U))
  }
  return V
}
function MN(e) {
  let t
  return () => (t === void 0 && (t = e()), t)
}
const jN = MN(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
  DN = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform",
    "backgroundColor"
  ]),
  Lu = 10,
  IN = 2e4,
  NN = (e, t) => t.type === "spring" || e === "backgroundColor" || !_T(t.ease)
function RN(e, t, { onUpdate: n, onComplete: r, ...i }) {
  if (
    !(
      jN() &&
      DN.has(t) &&
      !i.repeatDelay &&
      i.repeatType !== "mirror" &&
      i.damping !== 0 &&
      i.type !== "inertia"
    )
  )
    return !1
  let a = !1,
    s,
    l
  const u = () => {
    l = new Promise((v) => {
      s = v
    })
  }
  u()
  let { keyframes: f, duration: c = 300, ease: d, times: p } = i
  if (NN(t, i)) {
    const v = of({ ...i, repeat: 0, delay: 0 })
    let y = { done: !1, value: f[0] }
    const w = []
    let x = 0
    for (; !y.done && x < IN; ) (y = v.sample(x)), w.push(y.value), (x += Lu)
    ;(p = void 0), (f = w), (c = x - Lu), (d = "linear")
  }
  const h = GI(e.owner.current, t, f, { ...i, duration: c, ease: d, times: p }),
    m = () => h.cancel(),
    b = () => {
      Me.update(m), s(), u()
    }
  return (
    (h.onfinish = () => {
      e.set(KI(f, i)), r && r(), b()
    }),
    {
      then(v, y) {
        return l.then(v, y)
      },
      attachTimeline(v) {
        return (h.timeline = v), (h.onfinish = null), Ge
      },
      get time() {
        return hr(h.currentTime || 0)
      },
      set time(v) {
        h.currentTime = Gi(v)
      },
      get speed() {
        return h.playbackRate
      },
      set speed(v) {
        h.playbackRate = v
      },
      get duration() {
        return hr(c)
      },
      play: () => {
        a || (h.play(), xr(m))
      },
      pause: () => h.pause(),
      stop: () => {
        if (((a = !0), h.playState === "idle")) return
        const { currentTime: v } = h
        if (v) {
          const y = of({ ...i, autoplay: !1 })
          e.setWithVelocity(y.sample(v - Lu).value, y.sample(v).value, Lu)
        }
        b()
      },
      complete: () => h.finish(),
      cancel: b
    }
  )
}
function LN({ keyframes: e, delay: t, onUpdate: n, onComplete: r }) {
  const i = () => (
    n && n(e[e.length - 1]),
    r && r(),
    {
      time: 0,
      speed: 1,
      duration: 0,
      play: Ge,
      pause: Ge,
      stop: Ge,
      then: (o) => (o(), Promise.resolve()),
      cancel: Ge,
      complete: Ge
    }
  )
  return t
    ? of({ keyframes: [0, 1], duration: 0, delay: t, onComplete: i })
    : i()
}
const BN = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  FN = (e) => ({
    type: "spring",
    stiffness: 550,
    damping: e === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  }),
  VN = { type: "keyframes", duration: 0.8 },
  zN = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  UN = (e, { keyframes: t }) =>
    t.length > 2
      ? VN
      : oo.has(e)
        ? e.startsWith("scale")
          ? FN(t[1])
          : BN
        : zN,
  Xm = (e, t) =>
    e === "zIndex"
      ? !1
      : !!(
          typeof t == "number" ||
          Array.isArray(t) ||
          (typeof t == "string" &&
            (di.test(t) || t === "0") &&
            !t.startsWith("url("))
        ),
  WN = new Set(["brightness", "contrast", "saturate", "opacity"])
function HN(e) {
  const [t, n] = e.slice(0, -1).split("(")
  if (t === "drop-shadow") return e
  const [r] = n.match(Ad) || []
  if (!r) return e
  const i = n.replace(r, "")
  let o = WN.has(t) ? 1 : 0
  return r !== n && (o *= 100), t + "(" + o + i + ")"
}
const GN = /([a-z-]*)\(.*?\)/g,
  Ym = {
    ...di,
    getAnimatableNone: (e) => {
      const t = e.match(GN)
      return t ? t.map(HN).join(" ") : e
    }
  },
  KN = {
    ...hT,
    color: Ct,
    backgroundColor: Ct,
    outlineColor: Ct,
    fill: Ct,
    stroke: Ct,
    borderColor: Ct,
    borderTopColor: Ct,
    borderRightColor: Ct,
    borderBottomColor: Ct,
    borderLeftColor: Ct,
    filter: Ym,
    WebkitFilter: Ym
  },
  Ly = (e) => KN[e]
function eE(e, t) {
  let n = Ly(e)
  return (
    n !== Ym && (n = di), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
  )
}
const tE = (e) => /^0[^.\s]+$/.test(e)
function qN(e) {
  if (typeof e == "number") return e === 0
  if (e !== null) return e === "none" || e === "0" || tE(e)
}
function XN(e, t, n, r) {
  const i = Xm(t, n)
  let o
  Array.isArray(n) ? (o = [...n]) : (o = [null, n])
  const a = r.from !== void 0 ? r.from : e.get()
  let s
  const l = []
  for (let u = 0; u < o.length; u++)
    o[u] === null && (o[u] = u === 0 ? a : o[u - 1]),
      qN(o[u]) && l.push(u),
      typeof o[u] == "string" && o[u] !== "none" && o[u] !== "0" && (s = o[u])
  if (i && l.length && s)
    for (let u = 0; u < l.length; u++) {
      const f = l[u]
      o[f] = eE(t, s)
    }
  return o
}
function YN({
  when: e,
  delay: t,
  delayChildren: n,
  staggerChildren: r,
  staggerDirection: i,
  repeat: o,
  repeatType: a,
  repeatDelay: s,
  from: l,
  elapsed: u,
  ...f
}) {
  return !!Object.keys(f).length
}
function By(e, t) {
  return e[t] || e.default || e
}
const QN = { skipAnimations: !1 },
  Fy =
    (e, t, n, r = {}) =>
    (i) => {
      const o = By(r, e) || {},
        a = o.delay || r.delay || 0
      let { elapsed: s = 0 } = r
      s = s - Gi(a)
      const l = XN(t, e, n, o),
        u = l[0],
        f = l[l.length - 1],
        c = Xm(e, u),
        d = Xm(e, f)
      let p = {
        keyframes: l,
        velocity: t.getVelocity(),
        ease: "easeOut",
        ...o,
        delay: -s,
        onUpdate: (h) => {
          t.set(h), o.onUpdate && o.onUpdate(h)
        },
        onComplete: () => {
          i(), o.onComplete && o.onComplete()
        }
      }
      if (
        (YN(o) || (p = { ...p, ...UN(e, p) }),
        p.duration && (p.duration = Gi(p.duration)),
        p.repeatDelay && (p.repeatDelay = Gi(p.repeatDelay)),
        !c || !d || HI.current || o.type === !1 || QN.skipAnimations)
      )
        return LN(p)
      if (
        !r.isHandoff &&
        t.owner &&
        t.owner.current instanceof HTMLElement &&
        !t.owner.getProps().onUpdate
      ) {
        const h = RN(t, e, p)
        if (h) return h
      }
      return of(p)
    }
function af(e) {
  return !!(zt(e) && e.add)
}
const nE = (e) => /^\-?\d*\.?\d+$/.test(e)
function Vy(e, t) {
  e.indexOf(t) === -1 && e.push(t)
}
function zy(e, t) {
  const n = e.indexOf(t)
  n > -1 && e.splice(n, 1)
}
class Uy {
  constructor() {
    this.subscriptions = []
  }
  add(t) {
    return Vy(this.subscriptions, t), () => zy(this.subscriptions, t)
  }
  notify(t, n, r) {
    const i = this.subscriptions.length
    if (i)
      if (i === 1) this.subscriptions[0](t, n, r)
      else
        for (let o = 0; o < i; o++) {
          const a = this.subscriptions[o]
          a && a(t, n, r)
        }
  }
  getSize() {
    return this.subscriptions.length
  }
  clear() {
    this.subscriptions.length = 0
  }
}
const ZN = (e) => !isNaN(parseFloat(e))
class JN {
  constructor(t, n = {}) {
    ;(this.version = "10.17.4"),
      (this.timeDelta = 0),
      (this.lastUpdated = 0),
      (this.canTrackVelocity = !1),
      (this.events = {}),
      (this.updateAndNotify = (r, i = !0) => {
        ;(this.prev = this.current), (this.current = r)
        const { delta: o, timestamp: a } = Ot
        this.lastUpdated !== a &&
          ((this.timeDelta = o),
          (this.lastUpdated = a),
          Me.postRender(this.scheduleVelocityCheck)),
          this.prev !== this.current &&
            this.events.change &&
            this.events.change.notify(this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()),
          i &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current)
      }),
      (this.scheduleVelocityCheck = () => Me.postRender(this.velocityCheck)),
      (this.velocityCheck = ({ timestamp: r }) => {
        r !== this.lastUpdated &&
          ((this.prev = this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()))
      }),
      (this.hasAnimated = !1),
      (this.prev = this.current = t),
      (this.canTrackVelocity = ZN(this.current)),
      (this.owner = n.owner)
  }
  onChange(t) {
    return this.on("change", t)
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new Uy())
    const r = this.events[t].add(n)
    return t === "change"
      ? () => {
          r(),
            Me.read(() => {
              this.events.change.getSize() || this.stop()
            })
        }
      : r
  }
  clearListeners() {
    for (const t in this.events) this.events[t].clear()
  }
  attach(t, n) {
    ;(this.passiveEffect = t), (this.stopPassiveEffect = n)
  }
  set(t, n = !0) {
    !n || !this.passiveEffect
      ? this.updateAndNotify(t, n)
      : this.passiveEffect(t, this.updateAndNotify)
  }
  setWithVelocity(t, n, r) {
    this.set(n), (this.prev = t), (this.timeDelta = r)
  }
  jump(t) {
    this.updateAndNotify(t),
      (this.prev = t),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
  get() {
    return this.current
  }
  getPrevious() {
    return this.prev
  }
  getVelocity() {
    return this.canTrackVelocity
      ? QT(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      : 0
  }
  start(t) {
    return (
      this.stop(),
      new Promise((n) => {
        ;(this.hasAnimated = !0),
          (this.animation = t(n)),
          this.events.animationStart && this.events.animationStart.notify()
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation()
      })
    )
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation()
  }
  isAnimating() {
    return !!this.animation
  }
  clearAnimation() {
    delete this.animation
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
}
function na(e, t) {
  return new JN(e, t)
}
const rE = (e) => (t) => t.test(e),
  eR = { test: (e) => e === "auto", parse: (e) => e },
  iE = [ao, J, Gn, Lr, aI, oI, eR],
  es = (e) => iE.find(rE(e)),
  tR = [...iE, Ct, di],
  nR = (e) => tR.find(rE(e))
function rR(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, na(n))
}
function iR(e, t) {
  const n = Ed(e, t)
  let {
    transitionEnd: r = {},
    transition: i = {},
    ...o
  } = n ? e.makeTargetAnimatable(n, !1) : {}
  o = { ...o, ...r }
  for (const a in o) {
    const s = wI(o[a])
    rR(e, a, s)
  }
}
function oR(e, t, n) {
  var r, i
  const o = Object.keys(t).filter((s) => !e.hasValue(s)),
    a = o.length
  if (a)
    for (let s = 0; s < a; s++) {
      const l = o[s],
        u = t[l]
      let f = null
      Array.isArray(u) && (f = u[0]),
        f === null &&
          (f =
            (i = (r = n[l]) !== null && r !== void 0 ? r : e.readValue(l)) !==
              null && i !== void 0
              ? i
              : t[l]),
        f != null &&
          (typeof f == "string" && (nE(f) || tE(f))
            ? (f = parseFloat(f))
            : !nR(f) && di.test(u) && (f = eE(l, u)),
          e.addValue(l, na(f, { owner: e })),
          n[l] === void 0 && (n[l] = f),
          f !== null && e.setBaseTarget(l, f))
    }
}
function aR(e, t) {
  return t ? (t[e] || t.default || t).from : void 0
}
function sR(e, t, n) {
  const r = {}
  for (const i in e) {
    const o = aR(i, t)
    if (o !== void 0) r[i] = o
    else {
      const a = n.getValue(i)
      a && (r[i] = a.get())
    }
  }
  return r
}
function lR({ protectedKeys: e, needsAnimating: t }, n) {
  const r = e.hasOwnProperty(n) && t[n] !== !0
  return (t[n] = !1), r
}
function uR(e, t) {
  const n = e.get()
  if (Array.isArray(t)) {
    for (let r = 0; r < t.length; r++) if (t[r] !== n) return !0
  } else return n !== t
}
function oE(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) {
  let {
    transition: o = e.getDefaultTransition(),
    transitionEnd: a,
    ...s
  } = e.makeTargetAnimatable(t)
  const l = e.getValue("willChange")
  r && (o = r)
  const u = [],
    f = i && e.animationState && e.animationState.getState()[i]
  for (const c in s) {
    const d = e.getValue(c),
      p = s[c]
    if (!d || p === void 0 || (f && lR(f, c))) continue
    const h = { delay: n, elapsed: 0, ...By(o || {}, c) }
    if (window.HandoffAppearAnimations) {
      const g = e.getProps()[aT]
      if (g) {
        const v = window.HandoffAppearAnimations(g, c, d, Me)
        v !== null && ((h.elapsed = v), (h.isHandoff = !0))
      }
    }
    let m = !h.isHandoff && !uR(d, p)
    if (
      (h.type === "spring" && (d.getVelocity() || h.velocity) && (m = !1),
      d.animation && (m = !1),
      m)
    )
      continue
    d.start(Fy(c, d, p, e.shouldReduceMotion && oo.has(c) ? { type: !1 } : h))
    const b = d.animation
    af(l) && (l.add(c), b.then(() => l.remove(c))), u.push(b)
  }
  return (
    a &&
      Promise.all(u).then(() => {
        a && iR(e, a)
      }),
    u
  )
}
function Qm(e, t, n = {}) {
  const r = Ed(e, t, n.custom)
  let { transition: i = e.getDefaultTransition() || {} } = r || {}
  n.transitionOverride && (i = n.transitionOverride)
  const o = r ? () => Promise.all(oE(e, r, n)) : () => Promise.resolve(),
    a =
      e.variantChildren && e.variantChildren.size
        ? (l = 0) => {
            const {
              delayChildren: u = 0,
              staggerChildren: f,
              staggerDirection: c
            } = i
            return cR(e, t, u + l, f, c, n)
          }
        : () => Promise.resolve(),
    { when: s } = i
  if (s) {
    const [l, u] = s === "beforeChildren" ? [o, a] : [a, o]
    return l().then(() => u())
  } else return Promise.all([o(), a(n.delay)])
}
function cR(e, t, n = 0, r = 0, i = 1, o) {
  const a = [],
    s = (e.variantChildren.size - 1) * r,
    l = i === 1 ? (u = 0) => u * r : (u = 0) => s - u * r
  return (
    Array.from(e.variantChildren)
      .sort(fR)
      .forEach((u, f) => {
        u.notify("AnimationStart", t),
          a.push(
            Qm(u, t, { ...o, delay: n + l(f) }).then(() =>
              u.notify("AnimationComplete", t)
            )
          )
      }),
    Promise.all(a)
  )
}
function fR(e, t) {
  return e.sortNodePosition(t)
}
function dR(e, t, n = {}) {
  e.notify("AnimationStart", t)
  let r
  if (Array.isArray(t)) {
    const i = t.map((o) => Qm(e, o, n))
    r = Promise.all(i)
  } else if (typeof t == "string") r = Qm(e, t, n)
  else {
    const i = typeof t == "function" ? Ed(e, t, n.custom) : t
    r = Promise.all(oE(e, i, n))
  }
  return r.then(() => e.notify("AnimationComplete", t))
}
const pR = [...$y].reverse(),
  hR = $y.length
function mR(e) {
  return (t) =>
    Promise.all(t.map(({ animation: n, options: r }) => dR(e, n, r)))
}
function vR(e) {
  let t = mR(e)
  const n = yR()
  let r = !0
  const i = (l, u) => {
    const f = Ed(e, u)
    if (f) {
      const { transition: c, transitionEnd: d, ...p } = f
      l = { ...l, ...p, ...d }
    }
    return l
  }
  function o(l) {
    t = l(e)
  }
  function a(l, u) {
    const f = e.getProps(),
      c = e.getVariantContext(!0) || {},
      d = [],
      p = new Set()
    let h = {},
      m = 1 / 0
    for (let g = 0; g < hR; g++) {
      const v = pR[g],
        y = n[v],
        w = f[v] !== void 0 ? f[v] : c[v],
        x = nl(w),
        S = v === u ? y.isActive : null
      S === !1 && (m = g)
      let O = w === c[v] && w !== f[v] && x
      if (
        (O && r && e.manuallyAnimateOnMount && (O = !1),
        (y.protectedKeys = { ...h }),
        (!y.isActive && S === null) ||
          (!w && !y.prevProp) ||
          Pd(w) ||
          typeof w == "boolean")
      )
        continue
      let A =
          gR(y.prevProp, w) ||
          (v === u && y.isActive && !O && x) ||
          (g > m && x),
        C = !1
      const T = Array.isArray(w) ? w : [w]
      let _ = T.reduce(i, {})
      S === !1 && (_ = {})
      const { prevResolvedValues: R = {} } = y,
        M = { ...R, ..._ },
        D = (N) => {
          ;(A = !0),
            p.has(N) && ((C = !0), p.delete(N)),
            (y.needsAnimating[N] = !0)
        }
      for (const N in M) {
        const L = _[N],
          k = R[N]
        if (h.hasOwnProperty(N)) continue
        let I = !1
        tf(L) && tf(k) ? (I = !ET(L, k)) : (I = L !== k),
          I
            ? L !== void 0
              ? D(N)
              : p.add(N)
            : L !== void 0 && p.has(N)
              ? D(N)
              : (y.protectedKeys[N] = !0)
      }
      ;(y.prevProp = w),
        (y.prevResolvedValues = _),
        y.isActive && (h = { ...h, ..._ }),
        r && e.blockInitialAnimation && (A = !1),
        A &&
          (!O || C) &&
          d.push(
            ...T.map((N) => ({ animation: N, options: { type: v, ...l } }))
          )
    }
    if (p.size) {
      const g = {}
      p.forEach((v) => {
        const y = e.getBaseTarget(v)
        y !== void 0 && (g[v] = y)
      }),
        d.push({ animation: g })
    }
    let b = !!d.length
    return (
      r &&
        (f.initial === !1 || f.initial === f.animate) &&
        !e.manuallyAnimateOnMount &&
        (b = !1),
      (r = !1),
      b ? t(d) : Promise.resolve()
    )
  }
  function s(l, u, f) {
    var c
    if (n[l].isActive === u) return Promise.resolve()
    ;(c = e.variantChildren) === null ||
      c === void 0 ||
      c.forEach((p) => {
        var h
        return (h = p.animationState) === null || h === void 0
          ? void 0
          : h.setActive(l, u)
      }),
      (n[l].isActive = u)
    const d = a(f, l)
    for (const p in n) n[p].protectedKeys = {}
    return d
  }
  return {
    animateChanges: a,
    setActive: s,
    setAnimateFunction: o,
    getState: () => n
  }
}
function gR(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !ET(t, e) : !1
}
function Ai(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  }
}
function yR() {
  return {
    animate: Ai(!0),
    whileInView: Ai(),
    whileHover: Ai(),
    whileTap: Ai(),
    whileDrag: Ai(),
    whileFocus: Ai(),
    exit: Ai()
  }
}
class bR extends xi {
  constructor(t) {
    super(t), t.animationState || (t.animationState = vR(t))
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps()
    this.unmount(), Pd(t) && (this.unmount = t.subscribe(this.node))
  }
  mount() {
    this.updateAnimationControlsSubscription()
  }
  update() {
    const { animate: t } = this.node.getProps(),
      { animate: n } = this.node.prevProps || {}
    t !== n && this.updateAnimationControlsSubscription()
  }
  unmount() {}
}
let xR = 0
class wR extends xi {
  constructor() {
    super(...arguments), (this.id = xR++)
  }
  update() {
    if (!this.node.presenceContext) return
    const {
        isPresent: t,
        onExitComplete: n,
        custom: r
      } = this.node.presenceContext,
      { isPresent: i } = this.node.prevPresenceContext || {}
    if (!this.node.animationState || t === i) return
    const o = this.node.animationState.setActive("exit", !t, {
      custom: r ?? this.node.getProps().custom
    })
    n && !t && o.then(() => n(this.id))
  }
  mount() {
    const { register: t } = this.node.presenceContext || {}
    t && (this.unmount = t(this.id))
  }
  unmount() {}
}
const SR = { animation: { Feature: bR }, exit: { Feature: wR } },
  I1 = (e, t) => Math.abs(e - t)
function OR(e, t) {
  const n = I1(e.x, t.x),
    r = I1(e.y, t.y)
  return Math.sqrt(n ** 2 + r ** 2)
}
class aE {
  constructor(
    t,
    n,
    { transformPagePoint: r, contextWindow: i, dragSnapToOrigin: o = !1 } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return
        const c = oh(this.lastMoveEventInfo, this.history),
          d = this.startEvent !== null,
          p = OR(c.offset, { x: 0, y: 0 }) >= 3
        if (!d && !p) return
        const { point: h } = c,
          { timestamp: m } = Ot
        this.history.push({ ...h, timestamp: m })
        const { onStart: b, onMove: g } = this.handlers
        d ||
          (b && b(this.lastMoveEvent, c),
          (this.startEvent = this.lastMoveEvent)),
          g && g(this.lastMoveEvent, c)
      }),
      (this.handlePointerMove = (c, d) => {
        ;(this.lastMoveEvent = c),
          (this.lastMoveEventInfo = ih(d, this.transformPagePoint)),
          Me.update(this.updatePoint, !0)
      }),
      (this.handlePointerUp = (c, d) => {
        this.end()
        const { onEnd: p, onSessionEnd: h, resumeAnimation: m } = this.handlers
        if (
          (this.dragSnapToOrigin && m && m(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return
        const b = oh(
          c.type === "pointercancel"
            ? this.lastMoveEventInfo
            : ih(d, this.transformPagePoint),
          this.history
        )
        this.startEvent && p && p(c, b), h && h(c, b)
      }),
      !OT(t))
    )
      return
    ;(this.dragSnapToOrigin = o),
      (this.handlers = n),
      (this.transformPagePoint = r),
      (this.contextWindow = i || window)
    const a = Td(t),
      s = ih(a, this.transformPagePoint),
      { point: l } = s,
      { timestamp: u } = Ot
    this.history = [{ ...l, timestamp: u }]
    const { onSessionStart: f } = n
    f && f(t, oh(s, this.history)),
      (this.removeListeners = oi(
        pr(this.contextWindow, "pointermove", this.handlePointerMove),
        pr(this.contextWindow, "pointerup", this.handlePointerUp),
        pr(this.contextWindow, "pointercancel", this.handlePointerUp)
      ))
  }
  updateHandlers(t) {
    this.handlers = t
  }
  end() {
    this.removeListeners && this.removeListeners(), xr(this.updatePoint)
  }
}
function ih(e, t) {
  return t ? { point: t(e.point) } : e
}
function N1(e, t) {
  return { x: e.x - t.x, y: e.y - t.y }
}
function oh({ point: e }, t) {
  return {
    point: e,
    delta: N1(e, sE(t)),
    offset: N1(e, PR(t)),
    velocity: $R(t, 0.1)
  }
}
function PR(e) {
  return e[0]
}
function sE(e) {
  return e[e.length - 1]
}
function $R(e, t) {
  if (e.length < 2) return { x: 0, y: 0 }
  let n = e.length - 1,
    r = null
  const i = sE(e)
  for (; n >= 0 && ((r = e[n]), !(i.timestamp - r.timestamp > Gi(t))); ) n--
  if (!r) return { x: 0, y: 0 }
  const o = hr(i.timestamp - r.timestamp)
  if (o === 0) return { x: 0, y: 0 }
  const a = { x: (i.x - r.x) / o, y: (i.y - r.y) / o }
  return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a
}
function Zt(e) {
  return e.max - e.min
}
function Zm(e, t = 0, n = 0.01) {
  return Math.abs(e - t) <= n
}
function R1(e, t, n, r = 0.5) {
  ;(e.origin = r),
    (e.originPoint = Fe(t.min, t.max, e.origin)),
    (e.scale = Zt(n) / Zt(t)),
    (Zm(e.scale, 1, 1e-4) || isNaN(e.scale)) && (e.scale = 1),
    (e.translate = Fe(n.min, n.max, e.origin) - e.originPoint),
    (Zm(e.translate) || isNaN(e.translate)) && (e.translate = 0)
}
function Ms(e, t, n, r) {
  R1(e.x, t.x, n.x, r ? r.originX : void 0),
    R1(e.y, t.y, n.y, r ? r.originY : void 0)
}
function L1(e, t, n) {
  ;(e.min = n.min + t.min), (e.max = e.min + Zt(t))
}
function AR(e, t, n) {
  L1(e.x, t.x, n.x), L1(e.y, t.y, n.y)
}
function B1(e, t, n) {
  ;(e.min = t.min - n.min), (e.max = e.min + Zt(t))
}
function js(e, t, n) {
  B1(e.x, t.x, n.x), B1(e.y, t.y, n.y)
}
function TR(e, { min: t, max: n }, r) {
  return (
    t !== void 0 && e < t
      ? (e = r ? Fe(t, e, r.min) : Math.max(e, t))
      : n !== void 0 && e > n && (e = r ? Fe(n, e, r.max) : Math.min(e, n)),
    e
  )
}
function F1(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  }
}
function ER(e, { top: t, left: n, bottom: r, right: i }) {
  return { x: F1(e.x, n, i), y: F1(e.y, t, r) }
}
function V1(e, t) {
  let n = t.min - e.min,
    r = t.max - e.max
  return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r }
}
function CR(e, t) {
  return { x: V1(e.x, t.x), y: V1(e.y, t.y) }
}
function _R(e, t) {
  let n = 0.5
  const r = Zt(e),
    i = Zt(t)
  return (
    i > r
      ? (n = il(t.min, t.max - r, e.min))
      : r > i && (n = il(e.min, e.max - i, t.min)),
    fi(0, 1, n)
  )
}
function kR(e, t) {
  const n = {}
  return (
    t.min !== void 0 && (n.min = t.min - e.min),
    t.max !== void 0 && (n.max = t.max - e.min),
    n
  )
}
const Jm = 0.35
function MR(e = Jm) {
  return (
    e === !1 ? (e = 0) : e === !0 && (e = Jm),
    { x: z1(e, "left", "right"), y: z1(e, "top", "bottom") }
  )
}
function z1(e, t, n) {
  return { min: U1(e, t), max: U1(e, n) }
}
function U1(e, t) {
  return typeof e == "number" ? e : e[t] || 0
}
const W1 = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  jo = () => ({ x: W1(), y: W1() }),
  H1 = () => ({ min: 0, max: 0 }),
  qe = () => ({ x: H1(), y: H1() })
function ln(e) {
  return [e("x"), e("y")]
}
function lE({ top: e, left: t, right: n, bottom: r }) {
  return { x: { min: t, max: n }, y: { min: e, max: r } }
}
function jR({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min }
}
function DR(e, t) {
  if (!t) return e
  const n = t({ x: e.left, y: e.top }),
    r = t({ x: e.right, y: e.bottom })
  return { top: n.y, left: n.x, bottom: r.y, right: r.x }
}
function ah(e) {
  return e === void 0 || e === 1
}
function ev({ scale: e, scaleX: t, scaleY: n }) {
  return !ah(e) || !ah(t) || !ah(n)
}
function ki(e) {
  return ev(e) || uE(e) || e.z || e.rotate || e.rotateX || e.rotateY
}
function uE(e) {
  return G1(e.x) || G1(e.y)
}
function G1(e) {
  return e && e !== "0%"
}
function sf(e, t, n) {
  const r = e - n,
    i = t * r
  return n + i
}
function K1(e, t, n, r, i) {
  return i !== void 0 && (e = sf(e, i, r)), sf(e, n, r) + t
}
function tv(e, t = 0, n = 1, r, i) {
  ;(e.min = K1(e.min, t, n, r, i)), (e.max = K1(e.max, t, n, r, i))
}
function cE(e, { x: t, y: n }) {
  tv(e.x, t.translate, t.scale, t.originPoint),
    tv(e.y, n.translate, n.scale, n.originPoint)
}
function IR(e, t, n, r = !1) {
  const i = n.length
  if (!i) return
  t.x = t.y = 1
  let o, a
  for (let s = 0; s < i; s++) {
    ;(o = n[s]), (a = o.projectionDelta)
    const l = o.instance
    ;(l && l.style && l.style.display === "contents") ||
      (r &&
        o.options.layoutScroll &&
        o.scroll &&
        o !== o.root &&
        Do(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }),
      a && ((t.x *= a.x.scale), (t.y *= a.y.scale), cE(e, a)),
      r && ki(o.latestValues) && Do(e, o.latestValues))
  }
  ;(t.x = q1(t.x)), (t.y = q1(t.y))
}
function q1(e) {
  return Number.isInteger(e) || e > 1.0000000000001 || e < 0.999999999999
    ? e
    : 1
}
function Wr(e, t) {
  ;(e.min = e.min + t), (e.max = e.max + t)
}
function X1(e, t, [n, r, i]) {
  const o = t[i] !== void 0 ? t[i] : 0.5,
    a = Fe(e.min, e.max, o)
  tv(e, t[n], t[r], a, t.scale)
}
const NR = ["x", "scaleX", "originX"],
  RR = ["y", "scaleY", "originY"]
function Do(e, t) {
  X1(e.x, t, NR), X1(e.y, t, RR)
}
function fE(e, t) {
  return lE(DR(e.getBoundingClientRect(), t))
}
function LR(e, t, n) {
  const r = fE(e, n),
    { scroll: i } = t
  return i && (Wr(r.x, i.offset.x), Wr(r.y, i.offset.y)), r
}
const dE = ({ current: e }) => (e ? e.ownerDocument.defaultView : null),
  BR = new WeakMap()
class FR {
  constructor(t) {
    ;(this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = qe()),
      (this.visualElement = t)
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: r } = this.visualElement
    if (r && r.isPresent === !1) return
    const i = (f) => {
        const { dragSnapToOrigin: c } = this.getProps()
        c ? this.pauseAnimation() : this.stopAnimation(),
          n && this.snapToCursor(Td(f, "page").point)
      },
      o = (f, c) => {
        const { drag: d, dragPropagation: p, onDragStart: h } = this.getProps()
        if (
          d &&
          !p &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = $T(d)),
          !this.openGlobalLock)
        )
          return
        ;(this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          ln((b) => {
            let g = this.getAxisMotionValue(b).get() || 0
            if (Gn.test(g)) {
              const { projection: v } = this.visualElement
              if (v && v.layout) {
                const y = v.layout.layoutBox[b]
                y && (g = Zt(y) * (parseFloat(g) / 100))
              }
            }
            this.originPoint[b] = g
          }),
          h && Me.update(() => h(f, c), !1, !0)
        const { animationState: m } = this.visualElement
        m && m.setActive("whileDrag", !0)
      },
      a = (f, c) => {
        const {
          dragPropagation: d,
          dragDirectionLock: p,
          onDirectionLock: h,
          onDrag: m
        } = this.getProps()
        if (!d && !this.openGlobalLock) return
        const { offset: b } = c
        if (p && this.currentDirection === null) {
          ;(this.currentDirection = VR(b)),
            this.currentDirection !== null && h && h(this.currentDirection)
          return
        }
        this.updateAxis("x", c.point, b),
          this.updateAxis("y", c.point, b),
          this.visualElement.render(),
          m && m(f, c)
      },
      s = (f, c) => this.stop(f, c),
      l = () =>
        ln((f) => {
          var c
          return (
            this.getAnimationState(f) === "paused" &&
            ((c = this.getAxisMotionValue(f).animation) === null || c === void 0
              ? void 0
              : c.play())
          )
        }),
      { dragSnapToOrigin: u } = this.getProps()
    this.panSession = new aE(
      t,
      {
        onSessionStart: i,
        onStart: o,
        onMove: a,
        onSessionEnd: s,
        resumeAnimation: l
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: u,
        contextWindow: dE(this.visualElement)
      }
    )
  }
  stop(t, n) {
    const r = this.isDragging
    if ((this.cancel(), !r)) return
    const { velocity: i } = n
    this.startAnimation(i)
    const { onDragEnd: o } = this.getProps()
    o && Me.update(() => o(t, n))
  }
  cancel() {
    this.isDragging = !1
    const { projection: t, animationState: n } = this.visualElement
    t && (t.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0)
    const { dragPropagation: r } = this.getProps()
    !r &&
      this.openGlobalLock &&
      (this.openGlobalLock(), (this.openGlobalLock = null)),
      n && n.setActive("whileDrag", !1)
  }
  updateAxis(t, n, r) {
    const { drag: i } = this.getProps()
    if (!r || !Bu(t, i, this.currentDirection)) return
    const o = this.getAxisMotionValue(t)
    let a = this.originPoint[t] + r[t]
    this.constraints &&
      this.constraints[t] &&
      (a = TR(a, this.constraints[t], this.elastic[t])),
      o.set(a)
  }
  resolveConstraints() {
    var t
    const { dragConstraints: n, dragElastic: r } = this.getProps(),
      i =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (t = this.visualElement.projection) === null || t === void 0
            ? void 0
            : t.layout,
      o = this.constraints
    n && ko(n)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : n && i
        ? (this.constraints = ER(i.layoutBox, n))
        : (this.constraints = !1),
      (this.elastic = MR(r)),
      o !== this.constraints &&
        i &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        ln((a) => {
          this.getAxisMotionValue(a) &&
            (this.constraints[a] = kR(i.layoutBox[a], this.constraints[a]))
        })
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps()
    if (!t || !ko(t)) return !1
    const r = t.current,
      { projection: i } = this.visualElement
    if (!i || !i.layout) return !1
    const o = LR(r, i.root, this.visualElement.getTransformPagePoint())
    let a = CR(i.layout.layoutBox, o)
    if (n) {
      const s = n(jR(a))
      ;(this.hasMutatedConstraints = !!s), s && (a = lE(s))
    }
    return a
  }
  startAnimation(t) {
    const {
        drag: n,
        dragMomentum: r,
        dragElastic: i,
        dragTransition: o,
        dragSnapToOrigin: a,
        onDragTransitionEnd: s
      } = this.getProps(),
      l = this.constraints || {},
      u = ln((f) => {
        if (!Bu(f, n, this.currentDirection)) return
        let c = (l && l[f]) || {}
        a && (c = { min: 0, max: 0 })
        const d = i ? 200 : 1e6,
          p = i ? 40 : 1e7,
          h = {
            type: "inertia",
            velocity: r ? t[f] : 0,
            bounceStiffness: d,
            bounceDamping: p,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...o,
            ...c
          }
        return this.startAxisValueAnimation(f, h)
      })
    return Promise.all(u).then(s)
  }
  startAxisValueAnimation(t, n) {
    const r = this.getAxisMotionValue(t)
    return r.start(Fy(t, r, 0, n))
  }
  stopAnimation() {
    ln((t) => this.getAxisMotionValue(t).stop())
  }
  pauseAnimation() {
    ln((t) => {
      var n
      return (n = this.getAxisMotionValue(t).animation) === null || n === void 0
        ? void 0
        : n.pause()
    })
  }
  getAnimationState(t) {
    var n
    return (n = this.getAxisMotionValue(t).animation) === null || n === void 0
      ? void 0
      : n.state
  }
  getAxisMotionValue(t) {
    const n = "_drag" + t.toUpperCase(),
      r = this.visualElement.getProps(),
      i = r[n]
    return (
      i ||
      this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0)
    )
  }
  snapToCursor(t) {
    ln((n) => {
      const { drag: r } = this.getProps()
      if (!Bu(n, r, this.currentDirection)) return
      const { projection: i } = this.visualElement,
        o = this.getAxisMotionValue(n)
      if (i && i.layout) {
        const { min: a, max: s } = i.layout.layoutBox[n]
        o.set(t[n] - Fe(a, s, 0.5))
      }
    })
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return
    const { drag: t, dragConstraints: n } = this.getProps(),
      { projection: r } = this.visualElement
    if (!ko(n) || !r || !this.constraints) return
    this.stopAnimation()
    const i = { x: 0, y: 0 }
    ln((a) => {
      const s = this.getAxisMotionValue(a)
      if (s) {
        const l = s.get()
        i[a] = _R({ min: l, max: l }, this.constraints[a])
      }
    })
    const { transformTemplate: o } = this.visualElement.getProps()
    ;(this.visualElement.current.style.transform = o ? o({}, "") : "none"),
      r.root && r.root.updateScroll(),
      r.updateLayout(),
      this.resolveConstraints(),
      ln((a) => {
        if (!Bu(a, t, null)) return
        const s = this.getAxisMotionValue(a),
          { min: l, max: u } = this.constraints[a]
        s.set(Fe(l, u, i[a]))
      })
  }
  addListeners() {
    if (!this.visualElement.current) return
    BR.set(this.visualElement, this)
    const t = this.visualElement.current,
      n = pr(t, "pointerdown", (l) => {
        const { drag: u, dragListener: f = !0 } = this.getProps()
        u && f && this.start(l)
      }),
      r = () => {
        const { dragConstraints: l } = this.getProps()
        ko(l) && (this.constraints = this.resolveRefConstraints())
      },
      { projection: i } = this.visualElement,
      o = i.addEventListener("measure", r)
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), r()
    const a = lr(window, "resize", () => this.scalePositionWithinConstraints()),
      s = i.addEventListener(
        "didUpdate",
        ({ delta: l, hasLayoutChanged: u }) => {
          this.isDragging &&
            u &&
            (ln((f) => {
              const c = this.getAxisMotionValue(f)
              c &&
                ((this.originPoint[f] += l[f].translate),
                c.set(c.get() + l[f].translate))
            }),
            this.visualElement.render())
        }
      )
    return () => {
      a(), n(), o(), s && s()
    }
  }
  getProps() {
    const t = this.visualElement.getProps(),
      {
        drag: n = !1,
        dragDirectionLock: r = !1,
        dragPropagation: i = !1,
        dragConstraints: o = !1,
        dragElastic: a = Jm,
        dragMomentum: s = !0
      } = t
    return {
      ...t,
      drag: n,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: o,
      dragElastic: a,
      dragMomentum: s
    }
  }
}
function Bu(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e)
}
function VR(e, t = 10) {
  let n = null
  return Math.abs(e.y) > t ? (n = "y") : Math.abs(e.x) > t && (n = "x"), n
}
class zR extends xi {
  constructor(t) {
    super(t),
      (this.removeGroupControls = Ge),
      (this.removeListeners = Ge),
      (this.controls = new FR(t))
  }
  mount() {
    const { dragControls: t } = this.node.getProps()
    t && (this.removeGroupControls = t.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || Ge)
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners()
  }
}
const Y1 = (e) => (t, n) => {
  e && Me.update(() => e(t, n))
}
class UR extends xi {
  constructor() {
    super(...arguments), (this.removePointerDownListener = Ge)
  }
  onPointerDown(t) {
    this.session = new aE(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: dE(this.node)
    })
  }
  createPanHandlers() {
    const {
      onPanSessionStart: t,
      onPanStart: n,
      onPan: r,
      onPanEnd: i
    } = this.node.getProps()
    return {
      onSessionStart: Y1(t),
      onStart: Y1(n),
      onMove: r,
      onEnd: (o, a) => {
        delete this.session, i && Me.update(() => i(o, a))
      }
    }
  }
  mount() {
    this.removePointerDownListener = pr(this.node.current, "pointerdown", (t) =>
      this.onPointerDown(t)
    )
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end()
  }
}
function WR() {
  const e = P.useContext(Oy)
  if (e === null) return [!0, null]
  const { isPresent: t, onExitComplete: n, register: r } = e,
    i = P.useId()
  return P.useEffect(() => r(i), []), !t && n ? [!1, () => n && n(i)] : [!0]
}
const xc = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }
function Q1(e, t) {
  return t.max === t.min ? 0 : (e / (t.max - t.min)) * 100
}
const ts = {
    correct: (e, t) => {
      if (!t.target) return e
      if (typeof e == "string")
        if (J.test(e)) e = parseFloat(e)
        else return e
      const n = Q1(e, t.target.x),
        r = Q1(e, t.target.y)
      return `${n}% ${r}%`
    }
  },
  HR = {
    correct: (e, { treeScale: t, projectionDelta: n }) => {
      const r = e,
        i = di.parse(e)
      if (i.length > 5) return r
      const o = di.createTransformer(e),
        a = typeof i[0] != "number" ? 1 : 0,
        s = n.x.scale * t.x,
        l = n.y.scale * t.y
      ;(i[0 + a] /= s), (i[1 + a] /= l)
      const u = Fe(s, l, 0.5)
      return (
        typeof i[2 + a] == "number" && (i[2 + a] /= u),
        typeof i[3 + a] == "number" && (i[3 + a] /= u),
        o(i)
      )
    }
  }
class GR extends E.Component {
  componentDidMount() {
    const {
        visualElement: t,
        layoutGroup: n,
        switchLayoutGroup: r,
        layoutId: i
      } = this.props,
      { projection: o } = t
    ZD(KR),
      o &&
        (n.group && n.group.add(o),
        r && r.register && i && r.register(o),
        o.root.didUpdate(),
        o.addEventListener("animationComplete", () => {
          this.safeToRemove()
        }),
        o.setOptions({
          ...o.options,
          onExitComplete: () => this.safeToRemove()
        })),
      (xc.hasEverUpdated = !0)
  }
  getSnapshotBeforeUpdate(t) {
    const {
        layoutDependency: n,
        visualElement: r,
        drag: i,
        isPresent: o
      } = this.props,
      a = r.projection
    return (
      a &&
        ((a.isPresent = o),
        i || t.layoutDependency !== n || n === void 0
          ? a.willUpdate()
          : this.safeToRemove(),
        t.isPresent !== o &&
          (o
            ? a.promote()
            : a.relegate() ||
              Me.postRender(() => {
                const s = a.getStack()
                ;(!s || !s.members.length) && this.safeToRemove()
              }))),
      null
    )
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement
    t &&
      (t.root.didUpdate(),
      queueMicrotask(() => {
        !t.currentAnimation && t.isLead() && this.safeToRemove()
      }))
  }
  componentWillUnmount() {
    const {
        visualElement: t,
        layoutGroup: n,
        switchLayoutGroup: r
      } = this.props,
      { projection: i } = t
    i &&
      (i.scheduleCheckAfterUnmount(),
      n && n.group && n.group.remove(i),
      r && r.deregister && r.deregister(i))
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props
    t && t()
  }
  render() {
    return null
  }
}
function pE(e) {
  const [t, n] = WR(),
    r = P.useContext(lT)
  return E.createElement(GR, {
    ...e,
    layoutGroup: r,
    switchLayoutGroup: P.useContext(uT),
    isPresent: t,
    safeToRemove: n
  })
}
const KR = {
    borderRadius: {
      ...ts,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: ts,
    borderTopRightRadius: ts,
    borderBottomLeftRadius: ts,
    borderBottomRightRadius: ts,
    boxShadow: HR
  },
  hE = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  qR = hE.length,
  Z1 = (e) => (typeof e == "string" ? parseFloat(e) : e),
  J1 = (e) => typeof e == "number" || J.test(e)
function XR(e, t, n, r, i, o) {
  i
    ? ((e.opacity = Fe(0, n.opacity !== void 0 ? n.opacity : 1, YR(r))),
      (e.opacityExit = Fe(t.opacity !== void 0 ? t.opacity : 1, 0, QR(r))))
    : o &&
      (e.opacity = Fe(
        t.opacity !== void 0 ? t.opacity : 1,
        n.opacity !== void 0 ? n.opacity : 1,
        r
      ))
  for (let a = 0; a < qR; a++) {
    const s = `border${hE[a]}Radius`
    let l = ex(t, s),
      u = ex(n, s)
    if (l === void 0 && u === void 0) continue
    l || (l = 0),
      u || (u = 0),
      l === 0 || u === 0 || J1(l) === J1(u)
        ? ((e[s] = Math.max(Fe(Z1(l), Z1(u), r), 0)),
          (Gn.test(u) || Gn.test(l)) && (e[s] += "%"))
        : (e[s] = u)
  }
  ;(t.rotate || n.rotate) && (e.rotate = Fe(t.rotate || 0, n.rotate || 0, r))
}
function ex(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius
}
const YR = mE(0, 0.5, RT),
  QR = mE(0.5, 0.95, Ge)
function mE(e, t, n) {
  return (r) => (r < e ? 0 : r > t ? 1 : n(il(e, t, r)))
}
function tx(e, t) {
  ;(e.min = t.min), (e.max = t.max)
}
function rn(e, t) {
  tx(e.x, t.x), tx(e.y, t.y)
}
function nx(e, t, n, r, i) {
  return (
    (e -= t), (e = sf(e, 1 / n, r)), i !== void 0 && (e = sf(e, 1 / i, r)), e
  )
}
function ZR(e, t = 0, n = 1, r = 0.5, i, o = e, a = e) {
  if (
    (Gn.test(t) &&
      ((t = parseFloat(t)), (t = Fe(a.min, a.max, t / 100) - a.min)),
    typeof t != "number")
  )
    return
  let s = Fe(o.min, o.max, r)
  e === o && (s -= t),
    (e.min = nx(e.min, t, n, s, i)),
    (e.max = nx(e.max, t, n, s, i))
}
function rx(e, t, [n, r, i], o, a) {
  ZR(e, t[n], t[r], t[i], t.scale, o, a)
}
const JR = ["x", "scaleX", "originX"],
  eL = ["y", "scaleY", "originY"]
function ix(e, t, n, r) {
  rx(e.x, t, JR, n ? n.x : void 0, r ? r.x : void 0),
    rx(e.y, t, eL, n ? n.y : void 0, r ? r.y : void 0)
}
function ox(e) {
  return e.translate === 0 && e.scale === 1
}
function vE(e) {
  return ox(e.x) && ox(e.y)
}
function tL(e, t) {
  return (
    e.x.min === t.x.min &&
    e.x.max === t.x.max &&
    e.y.min === t.y.min &&
    e.y.max === t.y.max
  )
}
function gE(e, t) {
  return (
    Math.round(e.x.min) === Math.round(t.x.min) &&
    Math.round(e.x.max) === Math.round(t.x.max) &&
    Math.round(e.y.min) === Math.round(t.y.min) &&
    Math.round(e.y.max) === Math.round(t.y.max)
  )
}
function ax(e) {
  return Zt(e.x) / Zt(e.y)
}
class nL {
  constructor() {
    this.members = []
  }
  add(t) {
    Vy(this.members, t), t.scheduleRender()
  }
  remove(t) {
    if (
      (zy(this.members, t),
      t === this.prevLead && (this.prevLead = void 0),
      t === this.lead)
    ) {
      const n = this.members[this.members.length - 1]
      n && this.promote(n)
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i)
    if (n === 0) return !1
    let r
    for (let i = n; i >= 0; i--) {
      const o = this.members[i]
      if (o.isPresent !== !1) {
        r = o
        break
      }
    }
    return r ? (this.promote(r), !0) : !1
  }
  promote(t, n) {
    const r = this.lead
    if (t !== r && ((this.prevLead = r), (this.lead = t), t.show(), r)) {
      r.instance && r.scheduleRender(),
        t.scheduleRender(),
        (t.resumeFrom = r),
        n && (t.resumeFrom.preserveOpacity = !0),
        r.snapshot &&
          ((t.snapshot = r.snapshot),
          (t.snapshot.latestValues = r.animationValues || r.latestValues)),
        t.root && t.root.isUpdating && (t.isLayoutDirty = !0)
      const { crossfade: i } = t.options
      i === !1 && r.hide()
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: r } = t
      n.onExitComplete && n.onExitComplete(),
        r && r.options.onExitComplete && r.options.onExitComplete()
    })
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1)
    })
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}
function sx(e, t, n) {
  let r = ""
  const i = e.x.translate / t.x,
    o = e.y.translate / t.y
  if (
    ((i || o) && (r = `translate3d(${i}px, ${o}px, 0) `),
    (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `),
    n)
  ) {
    const { rotate: l, rotateX: u, rotateY: f } = n
    l && (r += `rotate(${l}deg) `),
      u && (r += `rotateX(${u}deg) `),
      f && (r += `rotateY(${f}deg) `)
  }
  const a = e.x.scale * t.x,
    s = e.y.scale * t.y
  return (a !== 1 || s !== 1) && (r += `scale(${a}, ${s})`), r || "none"
}
const rL = (e, t) => e.depth - t.depth
class iL {
  constructor() {
    ;(this.children = []), (this.isDirty = !1)
  }
  add(t) {
    Vy(this.children, t), (this.isDirty = !0)
  }
  remove(t) {
    zy(this.children, t), (this.isDirty = !0)
  }
  forEach(t) {
    this.isDirty && this.children.sort(rL),
      (this.isDirty = !1),
      this.children.forEach(t)
  }
}
function oL(e, t) {
  const n = performance.now(),
    r = ({ timestamp: i }) => {
      const o = i - n
      o >= t && (xr(r), e(o - t))
    }
  return Me.read(r, !0), () => xr(r)
}
function aL(e) {
  window.MotionDebug && window.MotionDebug.record(e)
}
function sL(e) {
  return e instanceof SVGElement && e.tagName !== "svg"
}
function lL(e, t, n) {
  const r = zt(e) ? e : na(e)
  return r.start(Fy("", r, t, n)), r.animation
}
const lx = ["", "X", "Y", "Z"],
  uL = { visibility: "hidden" },
  ux = 1e3
let cL = 0
const Mi = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}
function yE({
  attachResizeListener: e,
  defaultParent: t,
  measureScroll: n,
  checkIsScrollRoot: r,
  resetTransform: i
}) {
  return class {
    constructor(a = {}, s = t == null ? void 0 : t()) {
      ;(this.id = cL++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots())
        }),
        (this.updateProjection = () => {
          ;(this.projectionUpdateScheduled = !1),
            (Mi.totalNodes =
              Mi.resolvedTargetDeltas =
              Mi.recalculatedProjection =
                0),
            this.nodes.forEach(pL),
            this.nodes.forEach(yL),
            this.nodes.forEach(bL),
            this.nodes.forEach(hL),
            aL(Mi)
        }),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = a),
        (this.root = s ? s.root || s : this),
        (this.path = s ? [...s.path, s] : []),
        (this.parent = s),
        (this.depth = s ? s.depth + 1 : 0)
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0
      this.root === this && (this.nodes = new iL())
    }
    addEventListener(a, s) {
      return (
        this.eventHandlers.has(a) || this.eventHandlers.set(a, new Uy()),
        this.eventHandlers.get(a).add(s)
      )
    }
    notifyListeners(a, ...s) {
      const l = this.eventHandlers.get(a)
      l && l.notify(...s)
    }
    hasListeners(a) {
      return this.eventHandlers.has(a)
    }
    mount(a, s = this.root.hasTreeAnimated) {
      if (this.instance) return
      ;(this.isSVG = sL(a)), (this.instance = a)
      const { layoutId: l, layout: u, visualElement: f } = this.options
      if (
        (f && !f.current && f.mount(a),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        s && (u || l) && (this.isLayoutDirty = !0),
        e)
      ) {
        let c
        const d = () => (this.root.updateBlockedByResize = !1)
        e(a, () => {
          ;(this.root.updateBlockedByResize = !0),
            c && c(),
            (c = oL(d, 250)),
            xc.hasAnimatedSinceResize &&
              ((xc.hasAnimatedSinceResize = !1), this.nodes.forEach(fx))
        })
      }
      l && this.root.registerSharedNode(l, this),
        this.options.animate !== !1 &&
          f &&
          (l || u) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: c,
              hasLayoutChanged: d,
              hasRelativeTargetChanged: p,
              layout: h
            }) => {
              if (this.isTreeAnimationBlocked()) {
                ;(this.target = void 0), (this.relativeTarget = void 0)
                return
              }
              const m =
                  this.options.transition || f.getDefaultTransition() || PL,
                { onLayoutAnimationStart: b, onLayoutAnimationComplete: g } =
                  f.getProps(),
                v = !this.targetLayout || !gE(this.targetLayout, h) || p,
                y = !d && p
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                y ||
                (d && (v || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(c, y)
                const w = { ...By(m, "layout"), onPlay: b, onComplete: g }
                ;(f.shouldReduceMotion || this.options.layoutRoot) &&
                  ((w.delay = 0), (w.type = !1)),
                  this.startAnimation(w)
              } else
                d || fx(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete()
              this.targetLayout = h
            }
          )
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this)
      const a = this.getStack()
      a && a.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        xr(this.updateProjection)
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      )
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(xL),
        this.animationId++)
    }
    getTransformTemplate() {
      const { visualElement: a } = this.options
      return a && a.getProps().transformTemplate
    }
    willUpdate(a = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete()
        return
      }
      if (
        (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
      )
        return
      this.isLayoutDirty = !0
      for (let f = 0; f < this.path.length; f++) {
        const c = this.path[f]
        ;(c.shouldResetTransform = !0),
          c.updateScroll("snapshot"),
          c.options.layoutRoot && c.willUpdate(!1)
      }
      const { layoutId: s, layout: l } = this.options
      if (s === void 0 && !l) return
      const u = this.getTransformTemplate()
      ;(this.prevTransformTemplateValue = u
        ? u(this.latestValues, "")
        : void 0),
        this.updateSnapshot(),
        a && this.notifyListeners("willUpdate")
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(cx)
        return
      }
      this.isUpdating || this.nodes.forEach(vL),
        (this.isUpdating = !1),
        this.nodes.forEach(gL),
        this.nodes.forEach(fL),
        this.nodes.forEach(dL),
        this.clearAllSnapshots()
      const s = performance.now()
      ;(Ot.delta = fi(0, 1e3 / 60, s - Ot.timestamp)),
        (Ot.timestamp = s),
        (Ot.isProcessing = !0),
        Yp.update.process(Ot),
        Yp.preRender.process(Ot),
        Yp.render.process(Ot),
        (Ot.isProcessing = !1)
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), queueMicrotask(() => this.update()))
    }
    clearAllSnapshots() {
      this.nodes.forEach(mL), this.sharedNodes.forEach(wL)
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        Me.preRender(this.updateProjection, !1, !0))
    }
    scheduleCheckAfterUnmount() {
      Me.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed()
      })
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure())
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll()
      const a = this.layout
      ;(this.layout = this.measure(!1)),
        (this.layoutCorrected = qe()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox)
      const { visualElement: s } = this.options
      s &&
        s.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          a ? a.layoutBox : void 0
        )
    }
    updateScroll(a = "measure") {
      let s = !!(this.options.layoutScroll && this.instance)
      this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === a &&
        (s = !1),
        s &&
          (this.scroll = {
            animationId: this.root.animationId,
            phase: a,
            isRoot: r(this.instance),
            offset: n(this.instance)
          })
    }
    resetTransform() {
      if (!i) return
      const a = this.isLayoutDirty || this.shouldResetTransform,
        s = this.projectionDelta && !vE(this.projectionDelta),
        l = this.getTransformTemplate(),
        u = l ? l(this.latestValues, "") : void 0,
        f = u !== this.prevTransformTemplateValue
      a &&
        (s || ki(this.latestValues) || f) &&
        (i(this.instance, u),
        (this.shouldResetTransform = !1),
        this.scheduleRender())
    }
    measure(a = !0) {
      const s = this.measurePageBox()
      let l = this.removeElementScroll(s)
      return (
        a && (l = this.removeTransform(l)),
        $L(l),
        {
          animationId: this.root.animationId,
          measuredBox: s,
          layoutBox: l,
          latestValues: {},
          source: this.id
        }
      )
    }
    measurePageBox() {
      const { visualElement: a } = this.options
      if (!a) return qe()
      const s = a.measureViewportBox(),
        { scroll: l } = this.root
      return l && (Wr(s.x, l.offset.x), Wr(s.y, l.offset.y)), s
    }
    removeElementScroll(a) {
      const s = qe()
      rn(s, a)
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l],
          { scroll: f, options: c } = u
        if (u !== this.root && f && c.layoutScroll) {
          if (f.isRoot) {
            rn(s, a)
            const { scroll: d } = this.root
            d && (Wr(s.x, -d.offset.x), Wr(s.y, -d.offset.y))
          }
          Wr(s.x, f.offset.x), Wr(s.y, f.offset.y)
        }
      }
      return s
    }
    applyTransform(a, s = !1) {
      const l = qe()
      rn(l, a)
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u]
        !s &&
          f.options.layoutScroll &&
          f.scroll &&
          f !== f.root &&
          Do(l, { x: -f.scroll.offset.x, y: -f.scroll.offset.y }),
          ki(f.latestValues) && Do(l, f.latestValues)
      }
      return ki(this.latestValues) && Do(l, this.latestValues), l
    }
    removeTransform(a) {
      const s = qe()
      rn(s, a)
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l]
        if (!u.instance || !ki(u.latestValues)) continue
        ev(u.latestValues) && u.updateSnapshot()
        const f = qe(),
          c = u.measurePageBox()
        rn(f, c),
          ix(s, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, f)
      }
      return ki(this.latestValues) && ix(s, this.latestValues), s
    }
    setTargetDelta(a) {
      ;(this.targetDelta = a),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0)
    }
    setOptions(a) {
      this.options = {
        ...this.options,
        ...a,
        crossfade: a.crossfade !== void 0 ? a.crossfade : !0
      }
    }
    clearMeasurements() {
      ;(this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1)
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== Ot.timestamp &&
        this.relativeParent.resolveTargetDelta(!0)
    }
    resolveTargetDelta(a = !1) {
      var s
      const l = this.getLead()
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = l.isSharedProjectionDirty)
      const u = !!this.resumingFrom || this !== l
      if (
        !(
          a ||
          (u && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((s = this.parent) === null || s === void 0) &&
            s.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget
        )
      )
        return
      const { layout: c, layoutId: d } = this.options
      if (!(!this.layout || !(c || d))) {
        if (
          ((this.resolvedRelativeTargetAt = Ot.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const p = this.getClosestProjectingParent()
          p && p.layout && this.animationProgress !== 1
            ? ((this.relativeParent = p),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = qe()),
              (this.relativeTargetOrigin = qe()),
              js(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                p.layout.layoutBox
              ),
              rn(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = qe()), (this.targetWithTransforms = qe())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                AR(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target
                ))
              : this.targetDelta
                ? (this.resumingFrom
                    ? (this.target = this.applyTransform(this.layout.layoutBox))
                    : rn(this.target, this.layout.layoutBox),
                  cE(this.target, this.targetDelta))
                : rn(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1
            const p = this.getClosestProjectingParent()
            p &&
            !!p.resumingFrom == !!this.resumingFrom &&
            !p.options.layoutScroll &&
            p.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = p),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = qe()),
                (this.relativeTargetOrigin = qe()),
                js(this.relativeTargetOrigin, this.target, p.target),
                rn(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0)
          }
          Mi.resolvedTargetDeltas++
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          ev(this.parent.latestValues) ||
          uE(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent()
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      )
    }
    calcProjection() {
      var a
      const s = this.getLead(),
        l = !!this.resumingFrom || this !== s
      let u = !0
      if (
        ((this.isProjectionDirty ||
          (!((a = this.parent) === null || a === void 0) &&
            a.isProjectionDirty)) &&
          (u = !1),
        l &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (u = !1),
        this.resolvedRelativeTargetAt === Ot.timestamp && (u = !1),
        u)
      )
        return
      const { layout: f, layoutId: c } = this.options
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(f || c))
      )
        return
      rn(this.layoutCorrected, this.layout.layoutBox)
      const d = this.treeScale.x,
        p = this.treeScale.y
      IR(this.layoutCorrected, this.treeScale, this.path, l),
        s.layout &&
          !s.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          (s.target = s.layout.layoutBox)
      const { target: h } = s
      if (!h) {
        this.projectionTransform &&
          ((this.projectionDelta = jo()),
          (this.projectionTransform = "none"),
          this.scheduleRender())
        return
      }
      this.projectionDelta ||
        ((this.projectionDelta = jo()),
        (this.projectionDeltaWithTransform = jo()))
      const m = this.projectionTransform
      Ms(this.projectionDelta, this.layoutCorrected, h, this.latestValues),
        (this.projectionTransform = sx(this.projectionDelta, this.treeScale)),
        (this.projectionTransform !== m ||
          this.treeScale.x !== d ||
          this.treeScale.y !== p) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", h)),
        Mi.recalculatedProjection++
    }
    hide() {
      this.isVisible = !1
    }
    show() {
      this.isVisible = !0
    }
    scheduleRender(a = !0) {
      if ((this.options.scheduleRender && this.options.scheduleRender(), a)) {
        const s = this.getStack()
        s && s.scheduleRender()
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0)
    }
    setAnimationOrigin(a, s = !1) {
      const l = this.snapshot,
        u = l ? l.latestValues : {},
        f = { ...this.latestValues },
        c = jo()
      ;(!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !s)
      const d = qe(),
        p = l ? l.source : void 0,
        h = this.layout ? this.layout.source : void 0,
        m = p !== h,
        b = this.getStack(),
        g = !b || b.members.length <= 1,
        v = !!(m && !g && this.options.crossfade === !0 && !this.path.some(OL))
      this.animationProgress = 0
      let y
      ;(this.mixTargetDelta = (w) => {
        const x = w / 1e3
        dx(c.x, a.x, x),
          dx(c.y, a.y, x),
          this.setTargetDelta(c),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (js(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            SL(this.relativeTarget, this.relativeTargetOrigin, d, x),
            y && tL(this.relativeTarget, y) && (this.isProjectionDirty = !1),
            y || (y = qe()),
            rn(y, this.relativeTarget)),
          m &&
            ((this.animationValues = f), XR(f, u, this.latestValues, x, v, g)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = x)
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
    }
    startAnimation(a) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (xr(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = Me.update(() => {
          ;(xc.hasAnimatedSinceResize = !0),
            (this.currentAnimation = lL(0, ux, {
              ...a,
              onUpdate: (s) => {
                this.mixTargetDelta(s), a.onUpdate && a.onUpdate(s)
              },
              onComplete: () => {
                a.onComplete && a.onComplete(), this.completeAnimation()
              }
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0)
        }))
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0))
      const a = this.getStack()
      a && a.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete")
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(ux),
        this.currentAnimation.stop()),
        this.completeAnimation()
    }
    applyTransformsToTarget() {
      const a = this.getLead()
      let { targetWithTransforms: s, target: l, layout: u, latestValues: f } = a
      if (!(!s || !l || !u)) {
        if (
          this !== a &&
          this.layout &&
          u &&
          bE(this.options.animationType, this.layout.layoutBox, u.layoutBox)
        ) {
          l = this.target || qe()
          const c = Zt(this.layout.layoutBox.x)
          ;(l.x.min = a.target.x.min), (l.x.max = l.x.min + c)
          const d = Zt(this.layout.layoutBox.y)
          ;(l.y.min = a.target.y.min), (l.y.max = l.y.min + d)
        }
        rn(s, l),
          Do(s, f),
          Ms(this.projectionDeltaWithTransform, this.layoutCorrected, s, f)
      }
    }
    registerSharedNode(a, s) {
      this.sharedNodes.has(a) || this.sharedNodes.set(a, new nL()),
        this.sharedNodes.get(a).add(s)
      const u = s.options.initialPromotionConfig
      s.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity:
          u && u.shouldPreserveFollowOpacity
            ? u.shouldPreserveFollowOpacity(s)
            : void 0
      })
    }
    isLead() {
      const a = this.getStack()
      return a ? a.lead === this : !0
    }
    getLead() {
      var a
      const { layoutId: s } = this.options
      return s
        ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) ||
            this
        : this
    }
    getPrevLead() {
      var a
      const { layoutId: s } = this.options
      return s
        ? (a = this.getStack()) === null || a === void 0
          ? void 0
          : a.prevLead
        : void 0
    }
    getStack() {
      const { layoutId: a } = this.options
      if (a) return this.root.sharedNodes.get(a)
    }
    promote({ needsReset: a, transition: s, preserveFollowOpacity: l } = {}) {
      const u = this.getStack()
      u && u.promote(this, l),
        a && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        s && this.setOptions({ transition: s })
    }
    relegate() {
      const a = this.getStack()
      return a ? a.relegate(this) : !1
    }
    resetRotation() {
      const { visualElement: a } = this.options
      if (!a) return
      let s = !1
      const { latestValues: l } = a
      if (((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (s = !0), !s))
        return
      const u = {}
      for (let f = 0; f < lx.length; f++) {
        const c = "rotate" + lx[f]
        l[c] && ((u[c] = l[c]), a.setStaticValue(c, 0))
      }
      a.render()
      for (const f in u) a.setStaticValue(f, u[f])
      a.scheduleRender()
    }
    getProjectionStyles(a) {
      var s, l
      if (!this.instance || this.isSVG) return
      if (!this.isVisible) return uL
      const u = { visibility: "" },
        f = this.getTransformTemplate()
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (u.opacity = ""),
          (u.pointerEvents = bc(a == null ? void 0 : a.pointerEvents) || ""),
          (u.transform = f ? f(this.latestValues, "") : "none"),
          u
        )
      const c = this.getLead()
      if (!this.projectionDelta || !this.layout || !c.target) {
        const m = {}
        return (
          this.options.layoutId &&
            ((m.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (m.pointerEvents = bc(a == null ? void 0 : a.pointerEvents) || "")),
          this.hasProjected &&
            !ki(this.latestValues) &&
            ((m.transform = f ? f({}, "") : "none"), (this.hasProjected = !1)),
          m
        )
      }
      const d = c.animationValues || c.latestValues
      this.applyTransformsToTarget(),
        (u.transform = sx(
          this.projectionDeltaWithTransform,
          this.treeScale,
          d
        )),
        f && (u.transform = f(d, u.transform))
      const { x: p, y: h } = this.projectionDelta
      ;(u.transformOrigin = `${p.origin * 100}% ${h.origin * 100}% 0`),
        c.animationValues
          ? (u.opacity =
              c === this
                ? (l =
                    (s = d.opacity) !== null && s !== void 0
                      ? s
                      : this.latestValues.opacity) !== null && l !== void 0
                  ? l
                  : 1
                : this.preserveOpacity
                  ? this.latestValues.opacity
                  : d.opacityExit)
          : (u.opacity =
              c === this
                ? d.opacity !== void 0
                  ? d.opacity
                  : ""
                : d.opacityExit !== void 0
                  ? d.opacityExit
                  : 0)
      for (const m in Jc) {
        if (d[m] === void 0) continue
        const { correct: b, applyTo: g } = Jc[m],
          v = u.transform === "none" ? d[m] : b(d[m], c)
        if (g) {
          const y = g.length
          for (let w = 0; w < y; w++) u[g[w]] = v
        } else u[m] = v
      }
      return (
        this.options.layoutId &&
          (u.pointerEvents =
            c === this
              ? bc(a == null ? void 0 : a.pointerEvents) || ""
              : "none"),
        u
      )
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0
    }
    resetTree() {
      this.root.nodes.forEach((a) => {
        var s
        return (s = a.currentAnimation) === null || s === void 0
          ? void 0
          : s.stop()
      }),
        this.root.nodes.forEach(cx),
        this.root.sharedNodes.clear()
    }
  }
}
function fL(e) {
  e.updateLayout()
}
function dL(e) {
  var t
  const n =
    ((t = e.resumeFrom) === null || t === void 0 ? void 0 : t.snapshot) ||
    e.snapshot
  if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: i } = e.layout,
      { animationType: o } = e.options,
      a = n.source !== e.layout.source
    o === "size"
      ? ln((c) => {
          const d = a ? n.measuredBox[c] : n.layoutBox[c],
            p = Zt(d)
          ;(d.min = r[c].min), (d.max = d.min + p)
        })
      : bE(o, n.layoutBox, r) &&
        ln((c) => {
          const d = a ? n.measuredBox[c] : n.layoutBox[c],
            p = Zt(r[c])
          ;(d.max = d.min + p),
            e.relativeTarget &&
              !e.currentAnimation &&
              ((e.isProjectionDirty = !0),
              (e.relativeTarget[c].max = e.relativeTarget[c].min + p))
        })
    const s = jo()
    Ms(s, r, n.layoutBox)
    const l = jo()
    a ? Ms(l, e.applyTransform(i, !0), n.measuredBox) : Ms(l, r, n.layoutBox)
    const u = !vE(s)
    let f = !1
    if (!e.resumeFrom) {
      const c = e.getClosestProjectingParent()
      if (c && !c.resumeFrom) {
        const { snapshot: d, layout: p } = c
        if (d && p) {
          const h = qe()
          js(h, n.layoutBox, d.layoutBox)
          const m = qe()
          js(m, r, p.layoutBox),
            gE(h, m) || (f = !0),
            c.options.layoutRoot &&
              ((e.relativeTarget = m),
              (e.relativeTargetOrigin = h),
              (e.relativeParent = c))
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: r,
      snapshot: n,
      delta: l,
      layoutDelta: s,
      hasLayoutChanged: u,
      hasRelativeTargetChanged: f
    })
  } else if (e.isLead()) {
    const { onExitComplete: r } = e.options
    r && r()
  }
  e.options.transition = void 0
}
function pL(e) {
  Mi.totalNodes++,
    e.parent &&
      (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty),
      e.isSharedProjectionDirty ||
        (e.isSharedProjectionDirty = !!(
          e.isProjectionDirty ||
          e.parent.isProjectionDirty ||
          e.parent.isSharedProjectionDirty
        )),
      e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty))
}
function hL(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1
}
function mL(e) {
  e.clearSnapshot()
}
function cx(e) {
  e.clearMeasurements()
}
function vL(e) {
  e.isLayoutDirty = !1
}
function gL(e) {
  const { visualElement: t } = e.options
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"),
    e.resetTransform()
}
function fx(e) {
  e.finishAnimation(),
    (e.targetDelta = e.relativeTarget = e.target = void 0),
    (e.isProjectionDirty = !0)
}
function yL(e) {
  e.resolveTargetDelta()
}
function bL(e) {
  e.calcProjection()
}
function xL(e) {
  e.resetRotation()
}
function wL(e) {
  e.removeLeadSnapshot()
}
function dx(e, t, n) {
  ;(e.translate = Fe(t.translate, 0, n)),
    (e.scale = Fe(t.scale, 1, n)),
    (e.origin = t.origin),
    (e.originPoint = t.originPoint)
}
function px(e, t, n, r) {
  ;(e.min = Fe(t.min, n.min, r)), (e.max = Fe(t.max, n.max, r))
}
function SL(e, t, n, r) {
  px(e.x, t.x, n.x, r), px(e.y, t.y, n.y, r)
}
function OL(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0
}
const PL = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  hx = (e) =>
    typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(e),
  mx = hx("applewebkit/") && !hx("chrome/") ? Math.round : Ge
function vx(e) {
  ;(e.min = mx(e.min)), (e.max = mx(e.max))
}
function $L(e) {
  vx(e.x), vx(e.y)
}
function bE(e, t, n) {
  return e === "position" || (e === "preserve-aspect" && !Zm(ax(t), ax(n), 0.2))
}
const AL = yE({
    attachResizeListener: (e, t) => lr(e, "resize", t),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
  }),
  sh = { current: void 0 },
  xE = yE({
    measureScroll: (e) => ({ x: e.scrollLeft, y: e.scrollTop }),
    defaultParent: () => {
      if (!sh.current) {
        const e = new AL({})
        e.mount(window), e.setOptions({ layoutScroll: !0 }), (sh.current = e)
      }
      return sh.current
    },
    resetTransform: (e, t) => {
      e.style.transform = t !== void 0 ? t : "none"
    },
    checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
  }),
  TL = {
    pan: { Feature: UR },
    drag: { Feature: zR, ProjectionNode: xE, MeasureLayout: pE }
  },
  EL = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/
function CL(e) {
  const t = EL.exec(e)
  if (!t) return [,]
  const [, n, r] = t
  return [n, r]
}
function nv(e, t, n = 1) {
  const [r, i] = CL(e)
  if (!r) return
  const o = window.getComputedStyle(t).getPropertyValue(r)
  if (o) {
    const a = o.trim()
    return nE(a) ? parseFloat(a) : a
  } else return Hm(i) ? nv(i, t, n + 1) : i
}
function _L(e, { ...t }, n) {
  const r = e.current
  if (!(r instanceof Element)) return { target: t, transitionEnd: n }
  n && (n = { ...n }),
    e.values.forEach((i) => {
      const o = i.get()
      if (!Hm(o)) return
      const a = nv(o, r)
      a && i.set(a)
    })
  for (const i in t) {
    const o = t[i]
    if (!Hm(o)) continue
    const a = nv(o, r)
    a && ((t[i] = a), n || (n = {}), n[i] === void 0 && (n[i] = o))
  }
  return { target: t, transitionEnd: n }
}
const kL = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY"
  ]),
  wE = (e) => kL.has(e),
  ML = (e) => Object.keys(e).some(wE),
  gx = (e) => e === ao || e === J,
  yx = (e, t) => parseFloat(e.split(", ")[t]),
  bx =
    (e, t) =>
    (n, { transform: r }) => {
      if (r === "none" || !r) return 0
      const i = r.match(/^matrix3d\((.+)\)$/)
      if (i) return yx(i[1], t)
      {
        const o = r.match(/^matrix\((.+)\)$/)
        return o ? yx(o[1], e) : 0
      }
    },
  jL = new Set(["x", "y", "z"]),
  DL = Jl.filter((e) => !jL.has(e))
function IL(e) {
  const t = []
  return (
    DL.forEach((n) => {
      const r = e.getValue(n)
      r !== void 0 &&
        (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0))
    }),
    t.length && e.render(),
    t
  )
}
const ra = {
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) =>
    e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) =>
    e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  x: bx(4, 13),
  y: bx(5, 14)
}
ra.translateX = ra.x
ra.translateY = ra.y
const NL = (e, t, n) => {
    const r = t.measureViewportBox(),
      i = t.current,
      o = getComputedStyle(i),
      { display: a } = o,
      s = {}
    a === "none" && t.setStaticValue("display", e.display || "block"),
      n.forEach((u) => {
        s[u] = ra[u](r, o)
      }),
      t.render()
    const l = t.measureViewportBox()
    return (
      n.forEach((u) => {
        const f = t.getValue(u)
        f && f.jump(s[u]), (e[u] = ra[u](l, o))
      }),
      e
    )
  },
  RL = (e, t, n = {}, r = {}) => {
    ;(t = { ...t }), (r = { ...r })
    const i = Object.keys(t).filter(wE)
    let o = [],
      a = !1
    const s = []
    if (
      (i.forEach((l) => {
        const u = e.getValue(l)
        if (!e.hasValue(l)) return
        let f = n[l],
          c = es(f)
        const d = t[l]
        let p
        if (tf(d)) {
          const h = d.length,
            m = d[0] === null ? 1 : 0
          ;(f = d[m]), (c = es(f))
          for (let b = m; b < h && d[b] !== null; b++)
            p ? Dy(es(d[b]) === p) : (p = es(d[b]))
        } else p = es(d)
        if (c !== p)
          if (gx(c) && gx(p)) {
            const h = u.get()
            typeof h == "string" && u.set(parseFloat(h)),
              typeof d == "string"
                ? (t[l] = parseFloat(d))
                : Array.isArray(d) && p === J && (t[l] = d.map(parseFloat))
          } else
            c != null &&
            c.transform &&
            p != null &&
            p.transform &&
            (f === 0 || d === 0)
              ? f === 0
                ? u.set(p.transform(f))
                : (t[l] = c.transform(d))
              : (a || ((o = IL(e)), (a = !0)),
                s.push(l),
                (r[l] = r[l] !== void 0 ? r[l] : t[l]),
                u.jump(d))
      }),
      s.length)
    ) {
      const l = s.indexOf("height") >= 0 ? window.pageYOffset : null,
        u = NL(t, e, s)
      return (
        o.length &&
          o.forEach(([f, c]) => {
            e.getValue(f).set(c)
          }),
        e.render(),
        Od && l !== null && window.scrollTo({ top: l }),
        { target: u, transitionEnd: r }
      )
    } else return { target: t, transitionEnd: r }
  }
function LL(e, t, n, r) {
  return ML(t) ? RL(e, t, n, r) : { target: t, transitionEnd: r }
}
const BL = (e, t, n, r) => {
    const i = _L(e, t, r)
    return (t = i.target), (r = i.transitionEnd), LL(e, t, n, r)
  },
  rv = { current: null },
  SE = { current: !1 }
function FL() {
  if (((SE.current = !0), !!Od))
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"),
        t = () => (rv.current = e.matches)
      e.addListener(t), t()
    } else rv.current = !1
}
function VL(e, t, n) {
  const { willChange: r } = t
  for (const i in t) {
    const o = t[i],
      a = n[i]
    if (zt(o)) e.addValue(i, o), af(r) && r.add(i)
    else if (zt(a)) e.addValue(i, na(o, { owner: e })), af(r) && r.remove(i)
    else if (a !== o)
      if (e.hasValue(i)) {
        const s = e.getValue(i)
        !s.hasAnimated && s.set(o)
      } else {
        const s = e.getStaticValue(i)
        e.addValue(i, na(s !== void 0 ? s : o, { owner: e }))
      }
  }
  for (const i in n) t[i] === void 0 && e.removeValue(i)
  return t
}
const xx = new WeakMap(),
  OE = Object.keys(rl),
  zL = OE.length,
  wx = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ],
  UL = Ay.length
class WL {
  constructor(
    {
      parent: t,
      props: n,
      presenceContext: r,
      reducedMotionConfig: i,
      visualState: o
    },
    a = {}
  ) {
    ;(this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ))
      }),
      (this.scheduleRender = () => Me.render(this.render, !1, !0))
    const { latestValues: s, renderState: l } = o
    ;(this.latestValues = s),
      (this.baseTarget = { ...s }),
      (this.initialValues = n.initial ? { ...s } : {}),
      (this.renderState = l),
      (this.parent = t),
      (this.props = n),
      (this.presenceContext = r),
      (this.depth = t ? t.depth + 1 : 0),
      (this.reducedMotionConfig = i),
      (this.options = a),
      (this.isControllingVariants = $d(n)),
      (this.isVariantNode = sT(n)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(t && t.current))
    const { willChange: u, ...f } = this.scrapeMotionValuesFromProps(n, {})
    for (const c in f) {
      const d = f[c]
      s[c] !== void 0 && zt(d) && (d.set(s[c], !1), af(u) && u.add(c))
    }
  }
  scrapeMotionValuesFromProps(t, n) {
    return {}
  }
  mount(t) {
    ;(this.current = t),
      xx.set(t, this),
      this.projection && !this.projection.instance && this.projection.mount(t),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((n, r) => this.bindToMotionValue(r, n)),
      SE.current || FL(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
            ? !0
            : rv.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext)
  }
  unmount() {
    xx.delete(this.current),
      this.projection && this.projection.unmount(),
      xr(this.notifyUpdate),
      xr(this.render),
      this.valueSubscriptions.forEach((t) => t()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this)
    for (const t in this.events) this.events[t].clear()
    for (const t in this.features) this.features[t].unmount()
    this.current = null
  }
  bindToMotionValue(t, n) {
    const r = oo.has(t),
      i = n.on("change", (a) => {
        ;(this.latestValues[t] = a),
          this.props.onUpdate && Me.update(this.notifyUpdate, !1, !0),
          r && this.projection && (this.projection.isTransformDirty = !0)
      }),
      o = n.on("renderRequest", this.scheduleRender)
    this.valueSubscriptions.set(t, () => {
      i(), o()
    })
  }
  sortNodePosition(t) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== t.type
      ? 0
      : this.sortInstanceNodePosition(this.current, t.current)
  }
  loadFeatures({ children: t, ...n }, r, i, o) {
    let a, s
    for (let l = 0; l < zL; l++) {
      const u = OE[l],
        {
          isEnabled: f,
          Feature: c,
          ProjectionNode: d,
          MeasureLayout: p
        } = rl[u]
      d && (a = d),
        f(n) &&
          (!this.features[u] && c && (this.features[u] = new c(this)),
          p && (s = p))
    }
    if (!this.projection && a) {
      this.projection = new a(
        this.latestValues,
        this.parent && this.parent.projection
      )
      const {
        layoutId: l,
        layout: u,
        drag: f,
        dragConstraints: c,
        layoutScroll: d,
        layoutRoot: p
      } = n
      this.projection.setOptions({
        layoutId: l,
        layout: u,
        alwaysMeasureLayout: !!f || (c && ko(c)),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: typeof u == "string" ? u : "both",
        initialPromotionConfig: o,
        layoutScroll: d,
        layoutRoot: p
      })
    }
    return s
  }
  updateFeatures() {
    for (const t in this.features) {
      const n = this.features[t]
      n.isMounted ? n.update() : (n.mount(), (n.isMounted = !0))
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props)
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : qe()
  }
  getStaticValue(t) {
    return this.latestValues[t]
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n
  }
  makeTargetAnimatable(t, n = !0) {
    return this.makeTargetAnimatableFromInstance(t, this.props, n)
  }
  update(t, n) {
    ;(t.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = t),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = n)
    for (let r = 0; r < wx.length; r++) {
      const i = wx[r]
      this.propEventSubscriptions[i] &&
        (this.propEventSubscriptions[i](),
        delete this.propEventSubscriptions[i])
      const o = t["on" + i]
      o && (this.propEventSubscriptions[i] = this.on(i, o))
    }
    ;(this.prevMotionValues = VL(
      this,
      this.scrapeMotionValuesFromProps(t, this.prevProps),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue()
  }
  getProps() {
    return this.props
  }
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0
  }
  getDefaultTransition() {
    return this.props.transition
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
        ? this.parent.getClosestVariantNode()
        : void 0
  }
  getVariantContext(t = !1) {
    if (t) return this.parent ? this.parent.getVariantContext() : void 0
    if (!this.isControllingVariants) {
      const r = this.parent ? this.parent.getVariantContext() || {} : {}
      return (
        this.props.initial !== void 0 && (r.initial = this.props.initial), r
      )
    }
    const n = {}
    for (let r = 0; r < UL; r++) {
      const i = Ay[r],
        o = this.props[i]
      ;(nl(o) || o === !1) && (n[i] = o)
    }
    return n
  }
  addVariantChild(t) {
    const n = this.getClosestVariantNode()
    if (n)
      return (
        n.variantChildren && n.variantChildren.add(t),
        () => n.variantChildren.delete(t)
      )
  }
  addValue(t, n) {
    n !== this.values.get(t) &&
      (this.removeValue(t), this.bindToMotionValue(t, n)),
      this.values.set(t, n),
      (this.latestValues[t] = n.get())
  }
  removeValue(t) {
    this.values.delete(t)
    const n = this.valueSubscriptions.get(t)
    n && (n(), this.valueSubscriptions.delete(t)),
      delete this.latestValues[t],
      this.removeValueFromRenderState(t, this.renderState)
  }
  hasValue(t) {
    return this.values.has(t)
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t]) return this.props.values[t]
    let r = this.values.get(t)
    return (
      r === void 0 &&
        n !== void 0 &&
        ((r = na(n, { owner: this })), this.addValue(t, r)),
      r
    )
  }
  readValue(t) {
    var n
    return this.latestValues[t] !== void 0 || !this.current
      ? this.latestValues[t]
      : (n = this.getBaseTargetFromProps(this.props, t)) !== null &&
          n !== void 0
        ? n
        : this.readValueFromInstance(this.current, t, this.options)
  }
  setBaseTarget(t, n) {
    this.baseTarget[t] = n
  }
  getBaseTarget(t) {
    var n
    const { initial: r } = this.props,
      i =
        typeof r == "string" || typeof r == "object"
          ? (n = jy(this.props, r)) === null || n === void 0
            ? void 0
            : n[t]
          : void 0
    if (r && i !== void 0) return i
    const o = this.getBaseTargetFromProps(this.props, t)
    return o !== void 0 && !zt(o)
      ? o
      : this.initialValues[t] !== void 0 && i === void 0
        ? void 0
        : this.baseTarget[t]
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new Uy()), this.events[t].add(n)
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n)
  }
}
class PE extends WL {
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0
  }
  removeValueFromRenderState(t, { vars: n, style: r }) {
    delete n[t], delete r[t]
  }
  makeTargetAnimatableFromInstance(
    { transition: t, transitionEnd: n, ...r },
    { transformValues: i },
    o
  ) {
    let a = sR(r, t || {}, this)
    if ((i && (n && (n = i(n)), r && (r = i(r)), a && (a = i(a))), o)) {
      oR(this, r, a)
      const s = BL(this, r, a, n)
      ;(n = s.transitionEnd), (r = s.target)
    }
    return { transition: t, transitionEnd: n, ...r }
  }
}
function HL(e) {
  return window.getComputedStyle(e)
}
class GL extends PE {
  readValueFromInstance(t, n) {
    if (oo.has(n)) {
      const r = Ly(n)
      return (r && r.default) || 0
    } else {
      const r = HL(t),
        i = (dT(n) ? r.getPropertyValue(n) : r[n]) || 0
      return typeof i == "string" ? i.trim() : i
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return fE(t, n)
  }
  build(t, n, r, i) {
    Ey(t, n, r, i.transformTemplate)
  }
  scrapeMotionValuesFromProps(t, n) {
    return My(t, n)
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription)
    const { children: t } = this.props
    zt(t) &&
      (this.childSubscription = t.on("change", (n) => {
        this.current && (this.current.textContent = `${n}`)
      }))
  }
  renderInstance(t, n, r, i) {
    yT(t, n, r, i)
  }
}
class KL extends PE {
  constructor() {
    super(...arguments), (this.isSVGTag = !1)
  }
  getBaseTargetFromProps(t, n) {
    return t[n]
  }
  readValueFromInstance(t, n) {
    if (oo.has(n)) {
      const r = Ly(n)
      return (r && r.default) || 0
    }
    return (n = bT.has(n) ? n : Py(n)), t.getAttribute(n)
  }
  measureInstanceViewportBox() {
    return qe()
  }
  scrapeMotionValuesFromProps(t, n) {
    return wT(t, n)
  }
  build(t, n, r, i) {
    _y(t, n, r, this.isSVGTag, i.transformTemplate)
  }
  renderInstance(t, n, r, i) {
    xT(t, n, r, i)
  }
  mount(t) {
    ;(this.isSVGTag = ky(t.tagName)), super.mount(t)
  }
}
const qL = (e, t) =>
    Ty(e)
      ? new KL(t, { enableHardwareAcceleration: !1 })
      : new GL(t, { enableHardwareAcceleration: !0 }),
  XL = { layout: { ProjectionNode: xE, MeasureLayout: pE } },
  YL = { ...SR, ...zI, ...TL, ...XL },
  Sx = YD((e, t) => CI(e, t, YL, qL))
function se() {
  return (
    (se = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    se.apply(this, arguments)
  )
}
function QL(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t)
}
function $E(...e) {
  return (t) => e.forEach((n) => QL(n, t))
}
function Jt(...e) {
  return P.useCallback($E(...e), e)
}
const ia = P.forwardRef((e, t) => {
  const { children: n, ...r } = e,
    i = P.Children.toArray(n),
    o = i.find(ZL)
  if (o) {
    const a = o.props.children,
      s = i.map((l) =>
        l === o
          ? P.Children.count(a) > 1
            ? P.Children.only(null)
            : P.isValidElement(a)
              ? a.props.children
              : null
          : l
      )
    return P.createElement(
      iv,
      se({}, r, { ref: t }),
      P.isValidElement(a) ? P.cloneElement(a, void 0, s) : null
    )
  }
  return P.createElement(iv, se({}, r, { ref: t }), n)
})
ia.displayName = "Slot"
const iv = P.forwardRef((e, t) => {
  const { children: n, ...r } = e
  return P.isValidElement(n)
    ? P.cloneElement(n, { ...JL(r, n.props), ref: t ? $E(t, n.ref) : n.ref })
    : P.Children.count(n) > 1
      ? P.Children.only(null)
      : null
})
iv.displayName = "SlotClone"
const AE = ({ children: e }) => P.createElement(P.Fragment, null, e)
function ZL(e) {
  return P.isValidElement(e) && e.type === AE
}
function JL(e, t) {
  const n = { ...t }
  for (const r in t) {
    const i = e[r],
      o = t[r]
    ;/^on[A-Z]/.test(r)
      ? i && o
        ? (n[r] = (...s) => {
            o(...s), i(...s)
          })
        : i && (n[r] = i)
      : r === "style"
        ? (n[r] = { ...i, ...o })
        : r === "className" && (n[r] = [i, o].filter(Boolean).join(" "))
  }
  return { ...e, ...n }
}
function TE(e) {
  var t,
    n,
    r = ""
  if (typeof e == "string" || typeof e == "number") r += e
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = TE(e[t])) && (r && (r += " "), (r += n))
    else for (t in e) e[t] && (r && (r += " "), (r += t))
  return r
}
function e3() {
  for (var e, t, n = 0, r = ""; n < arguments.length; )
    (e = arguments[n++]) && (t = TE(e)) && (r && (r += " "), (r += t))
  return r
}
const Ox = (e) => (typeof e == "boolean" ? "".concat(e) : e === 0 ? "0" : e),
  Px = e3,
  t3 = (e, t) => (n) => {
    var r
    if ((t == null ? void 0 : t.variants) == null)
      return Px(
        e,
        n == null ? void 0 : n.class,
        n == null ? void 0 : n.className
      )
    const { variants: i, defaultVariants: o } = t,
      a = Object.keys(i).map((u) => {
        const f = n == null ? void 0 : n[u],
          c = o == null ? void 0 : o[u]
        if (f === null) return null
        const d = Ox(f) || Ox(c)
        return i[u][d]
      }),
      s =
        n &&
        Object.entries(n).reduce((u, f) => {
          let [c, d] = f
          return d === void 0 || (u[c] = d), u
        }, {}),
      l =
        t == null || (r = t.compoundVariants) === null || r === void 0
          ? void 0
          : r.reduce((u, f) => {
              let { class: c, className: d, ...p } = f
              return Object.entries(p).every((h) => {
                let [m, b] = h
                return Array.isArray(b)
                  ? b.includes({ ...o, ...s }[m])
                  : { ...o, ...s }[m] === b
              })
                ? [...u, c, d]
                : u
            }, [])
    return Px(
      e,
      a,
      l,
      n == null ? void 0 : n.class,
      n == null ? void 0 : n.className
    )
  },
  Cd = t3(
    "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
    {
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/90",
          destructive:
            "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          outline:
            "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
          secondary:
            "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
          default: "h-10 px-4 py-2",
          sm: "h-9 rounded-md px-3",
          lg: "h-11 rounded-md px-8",
          icon: "h-10 w-10"
        }
      },
      defaultVariants: { variant: "default", size: "default" }
    }
  ),
  ir = P.forwardRef(
    ({ className: e, variant: t, size: n, asChild: r = !1, ...i }, o) => {
      const a = r ? ia : "button"
      return j.jsx(a, {
        className: ot(Cd({ variant: t, size: n, className: e })),
        ref: o,
        ...i
      })
    }
  )
ir.displayName = "Button"
const n3 = () =>
  j.jsxs("header", {
    className:
      "relative mt-24 flex flex-col items-center gap-y-6 break-keep md:mt-32 md:gap-y-8",
    children: [
      j.jsx(Sx.image, {
        initial: { opacity: 0 },
        animate: { opacity: 0.2 },
        "aria-hidden": !0,
        transition: { duration: 3 },
        className:
          "absolute -top-20 -z-10 opacity-20 [mask-image:radial-gradient(ellipse_at_center,black,transparent_70%)] md:-top-32 md:opacity-10 md:[mask-image:radial-gradient(ellipse_at_center,black,transparent_70%)]",
        children: j.jsx("img", { src: "/grid.svg", alt: "bg" })
      }),
      j.jsx("h1", {
        className: "text-center text-4xl font-bold md:text-5xl lg:text-6xl",
        children: "Table viewer for modern developers"
      }),
      j.jsx("p", {
        className: "text-muted-foreground text-center md:text-lg lg:text-xl",
        children: "Database browsing experience like never before"
      }),
      j.jsxs("div", {
        className: "flex items-center gap-x-7",
        children: [
          j.jsx(ir, { className: "font-semi", children: "Download Now" }),
          j.jsxs("a", {
            href: "https://github.com/kareemmahlees/tablex",
            target: "_blank",
            rel: "noreferrer",
            className: ot(
              Cd({ variant: "secondary" }),
              "hover:bg-secondary group relative"
            ),
            children: [
              j.jsx("img", {
                src: "/icons/github.svg",
                alt: "github icon",
                className: "h-5 w-5"
              }),
              j.jsx(Sx.image, {
                className: "absolute -z-10 h-7 w-7",
                initial: { opacity: 0 },
                animate: { opacity: 100 },
                children: j.jsx("img", {
                  src: "/icons/start.svg",
                  alt: "star",
                  className: "transition-transform group-hover:-translate-y-5",
                  "aria-hidden": !0
                })
              })
            ]
          })
        ]
      }),
      j.jsx("img", {
        src: "/overview.png",
        alt: "overview",
        className:
          "mt-5 w-[400px] rounded-sm brightness-[80%] [mask-image:linear-gradient(black,gray,transparent_75%)] md:w-[600px] lg:w-[850px]"
      })
    ]
  })
var r3 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
}
const i3 = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
  o3 = (e, t) => {
    const n = P.forwardRef(
      (
        {
          color: r = "currentColor",
          size: i = 24,
          strokeWidth: o = 2,
          absoluteStrokeWidth: a,
          children: s,
          ...l
        },
        u
      ) =>
        P.createElement(
          "svg",
          {
            ref: u,
            ...r3,
            width: i,
            height: i,
            stroke: r,
            strokeWidth: a ? (Number(o) * 24) / Number(i) : o,
            className: `lucide lucide-${i3(e)}`,
            ...l
          },
          [
            ...t.map(([f, c]) => P.createElement(f, c)),
            ...((Array.isArray(s) ? s : [s]) || [])
          ]
        )
    )
    return (n.displayName = `${e}`), n
  },
  a3 = o3("Menu", [
    ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }],
    ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }],
    ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]
  ])
function Be(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function (i) {
    if ((e == null || e(i), n === !1 || !i.defaultPrevented))
      return t == null ? void 0 : t(i)
  }
}
function Ta(e, t = []) {
  let n = []
  function r(o, a) {
    const s = P.createContext(a),
      l = n.length
    n = [...n, a]
    function u(c) {
      const { scope: d, children: p, ...h } = c,
        m = (d == null ? void 0 : d[e][l]) || s,
        b = P.useMemo(() => h, Object.values(h))
      return P.createElement(m.Provider, { value: b }, p)
    }
    function f(c, d) {
      const p = (d == null ? void 0 : d[e][l]) || s,
        h = P.useContext(p)
      if (h) return h
      if (a !== void 0) return a
      throw new Error(`\`${c}\` must be used within \`${o}\``)
    }
    return (u.displayName = o + "Provider"), [u, f]
  }
  const i = () => {
    const o = n.map((a) => P.createContext(a))
    return function (s) {
      const l = (s == null ? void 0 : s[e]) || o
      return P.useMemo(() => ({ [`__scope${e}`]: { ...s, [e]: l } }), [s, l])
    }
  }
  return (i.scopeName = e), [r, s3(i, ...t)]
}
function s3(...e) {
  const t = e[0]
  if (e.length === 1) return t
  const n = () => {
    const r = e.map((i) => ({ useScope: i(), scopeName: i.scopeName }))
    return function (o) {
      const a = r.reduce((s, { useScope: l, scopeName: u }) => {
        const c = l(o)[`__scope${u}`]
        return { ...s, ...c }
      }, {})
      return P.useMemo(() => ({ [`__scope${t.scopeName}`]: a }), [a])
    }
  }
  return (n.scopeName = t.scopeName), n
}
const oa =
    globalThis != null && globalThis.document ? P.useLayoutEffect : () => {},
  l3 = QM.useId || (() => {})
let u3 = 0
function Wo(e) {
  const [t, n] = P.useState(l3())
  return (
    oa(() => {
      e || n((r) => r ?? String(u3++))
    }, [e]),
    e || (t ? `radix-${t}` : "")
  )
}
function wr(e) {
  const t = P.useRef(e)
  return (
    P.useEffect(() => {
      t.current = e
    }),
    P.useMemo(
      () =>
        (...n) => {
          var r
          return (r = t.current) === null || r === void 0
            ? void 0
            : r.call(t, ...n)
        },
      []
    )
  )
}
function _d({ prop: e, defaultProp: t, onChange: n = () => {} }) {
  const [r, i] = c3({ defaultProp: t, onChange: n }),
    o = e !== void 0,
    a = o ? e : r,
    s = wr(n),
    l = P.useCallback(
      (u) => {
        if (o) {
          const c = typeof u == "function" ? u(e) : u
          c !== e && s(c)
        } else i(u)
      },
      [o, e, i, s]
    )
  return [a, l]
}
function c3({ defaultProp: e, onChange: t }) {
  const n = P.useState(e),
    [r] = n,
    i = P.useRef(r),
    o = wr(t)
  return (
    P.useEffect(() => {
      i.current !== r && (o(r), (i.current = r))
    }, [r, i, o]),
    n
  )
}
const f3 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ],
  dt = f3.reduce((e, t) => {
    const n = P.forwardRef((r, i) => {
      const { asChild: o, ...a } = r,
        s = o ? ia : t
      return (
        P.useEffect(() => {
          window[Symbol.for("radix-ui")] = !0
        }, []),
        P.createElement(s, se({}, a, { ref: i }))
      )
    })
    return (n.displayName = `Primitive.${t}`), { ...e, [t]: n }
  }, {})
function d3(e, t) {
  e && Zl.flushSync(() => e.dispatchEvent(t))
}
function p3(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = wr(e)
  P.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i)
    }
    return (
      t.addEventListener("keydown", r),
      () => t.removeEventListener("keydown", r)
    )
  }, [n, t])
}
const ov = "dismissableLayer.update",
  h3 = "dismissableLayer.pointerDownOutside",
  m3 = "dismissableLayer.focusOutside"
let $x
const v3 = P.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set()
  }),
  EE = P.forwardRef((e, t) => {
    var n
    const {
        disableOutsidePointerEvents: r = !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: o,
        onFocusOutside: a,
        onInteractOutside: s,
        onDismiss: l,
        ...u
      } = e,
      f = P.useContext(v3),
      [c, d] = P.useState(null),
      p =
        (n = c == null ? void 0 : c.ownerDocument) !== null && n !== void 0
          ? n
          : globalThis == null
            ? void 0
            : globalThis.document,
      [, h] = P.useState({}),
      m = Jt(t, ($) => d($)),
      b = Array.from(f.layers),
      [g] = [...f.layersWithOutsidePointerEventsDisabled].slice(-1),
      v = b.indexOf(g),
      y = c ? b.indexOf(c) : -1,
      w = f.layersWithOutsidePointerEventsDisabled.size > 0,
      x = y >= v,
      S = g3(($) => {
        const A = $.target,
          C = [...f.branches].some((T) => T.contains(A))
        !x ||
          C ||
          (o == null || o($),
          s == null || s($),
          $.defaultPrevented || l == null || l())
      }, p),
      O = y3(($) => {
        const A = $.target
        ;[...f.branches].some((T) => T.contains(A)) ||
          (a == null || a($),
          s == null || s($),
          $.defaultPrevented || l == null || l())
      }, p)
    return (
      p3(($) => {
        y === f.layers.size - 1 &&
          (i == null || i($),
          !$.defaultPrevented && l && ($.preventDefault(), l()))
      }, p),
      P.useEffect(() => {
        if (c)
          return (
            r &&
              (f.layersWithOutsidePointerEventsDisabled.size === 0 &&
                (($x = p.body.style.pointerEvents),
                (p.body.style.pointerEvents = "none")),
              f.layersWithOutsidePointerEventsDisabled.add(c)),
            f.layers.add(c),
            Ax(),
            () => {
              r &&
                f.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (p.body.style.pointerEvents = $x)
            }
          )
      }, [c, p, r, f]),
      P.useEffect(
        () => () => {
          c &&
            (f.layers.delete(c),
            f.layersWithOutsidePointerEventsDisabled.delete(c),
            Ax())
        },
        [c, f]
      ),
      P.useEffect(() => {
        const $ = () => h({})
        return (
          document.addEventListener(ov, $),
          () => document.removeEventListener(ov, $)
        )
      }, []),
      P.createElement(
        dt.div,
        se({}, u, {
          ref: m,
          style: {
            pointerEvents: w ? (x ? "auto" : "none") : void 0,
            ...e.style
          },
          onFocusCapture: Be(e.onFocusCapture, O.onFocusCapture),
          onBlurCapture: Be(e.onBlurCapture, O.onBlurCapture),
          onPointerDownCapture: Be(
            e.onPointerDownCapture,
            S.onPointerDownCapture
          )
        })
      )
    )
  })
function g3(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = wr(e),
    r = P.useRef(!1),
    i = P.useRef(() => {})
  return (
    P.useEffect(() => {
      const o = (s) => {
          if (s.target && !r.current) {
            let f = function () {
              CE(h3, n, u, { discrete: !0 })
            }
            var l = f
            const u = { originalEvent: s }
            s.pointerType === "touch"
              ? (t.removeEventListener("click", i.current),
                (i.current = f),
                t.addEventListener("click", i.current, { once: !0 }))
              : f()
          } else t.removeEventListener("click", i.current)
          r.current = !1
        },
        a = window.setTimeout(() => {
          t.addEventListener("pointerdown", o)
        }, 0)
      return () => {
        window.clearTimeout(a),
          t.removeEventListener("pointerdown", o),
          t.removeEventListener("click", i.current)
      }
    }, [t, n]),
    { onPointerDownCapture: () => (r.current = !0) }
  )
}
function y3(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = wr(e),
    r = P.useRef(!1)
  return (
    P.useEffect(() => {
      const i = (o) => {
        o.target &&
          !r.current &&
          CE(m3, n, { originalEvent: o }, { discrete: !1 })
      }
      return (
        t.addEventListener("focusin", i),
        () => t.removeEventListener("focusin", i)
      )
    }, [t, n]),
    {
      onFocusCapture: () => (r.current = !0),
      onBlurCapture: () => (r.current = !1)
    }
  )
}
function Ax() {
  const e = new CustomEvent(ov)
  document.dispatchEvent(e)
}
function CE(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target,
    o = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n })
  t && i.addEventListener(e, t, { once: !0 }), r ? d3(i, o) : i.dispatchEvent(o)
}
const lh = "focusScope.autoFocusOnMount",
  uh = "focusScope.autoFocusOnUnmount",
  Tx = { bubbles: !1, cancelable: !0 },
  b3 = P.forwardRef((e, t) => {
    const {
        loop: n = !1,
        trapped: r = !1,
        onMountAutoFocus: i,
        onUnmountAutoFocus: o,
        ...a
      } = e,
      [s, l] = P.useState(null),
      u = wr(i),
      f = wr(o),
      c = P.useRef(null),
      d = Jt(t, (m) => l(m)),
      p = P.useRef({
        paused: !1,
        pause() {
          this.paused = !0
        },
        resume() {
          this.paused = !1
        }
      }).current
    P.useEffect(() => {
      if (r) {
        let v = function (S) {
            if (p.paused || !s) return
            const O = S.target
            s.contains(O) ? (c.current = O) : Br(c.current, { select: !0 })
          },
          y = function (S) {
            if (p.paused || !s) return
            const O = S.relatedTarget
            O !== null && (s.contains(O) || Br(c.current, { select: !0 }))
          },
          w = function (S) {
            if (document.activeElement === document.body)
              for (const $ of S) $.removedNodes.length > 0 && Br(s)
          }
        var m = v,
          b = y,
          g = w
        document.addEventListener("focusin", v),
          document.addEventListener("focusout", y)
        const x = new MutationObserver(w)
        return (
          s && x.observe(s, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", v),
              document.removeEventListener("focusout", y),
              x.disconnect()
          }
        )
      }
    }, [r, s, p.paused]),
      P.useEffect(() => {
        if (s) {
          Cx.add(p)
          const m = document.activeElement
          if (!s.contains(m)) {
            const g = new CustomEvent(lh, Tx)
            s.addEventListener(lh, u),
              s.dispatchEvent(g),
              g.defaultPrevented ||
                (x3($3(_E(s)), { select: !0 }),
                document.activeElement === m && Br(s))
          }
          return () => {
            s.removeEventListener(lh, u),
              setTimeout(() => {
                const g = new CustomEvent(uh, Tx)
                s.addEventListener(uh, f),
                  s.dispatchEvent(g),
                  g.defaultPrevented || Br(m ?? document.body, { select: !0 }),
                  s.removeEventListener(uh, f),
                  Cx.remove(p)
              }, 0)
          }
        }
      }, [s, u, f, p])
    const h = P.useCallback(
      (m) => {
        if ((!n && !r) || p.paused) return
        const b = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey,
          g = document.activeElement
        if (b && g) {
          const v = m.currentTarget,
            [y, w] = w3(v)
          y && w
            ? !m.shiftKey && g === w
              ? (m.preventDefault(), n && Br(y, { select: !0 }))
              : m.shiftKey &&
                g === y &&
                (m.preventDefault(), n && Br(w, { select: !0 }))
            : g === v && m.preventDefault()
        }
      },
      [n, r, p.paused]
    )
    return P.createElement(
      dt.div,
      se({ tabIndex: -1 }, a, { ref: d, onKeyDown: h })
    )
  })
function x3(e, { select: t = !1 } = {}) {
  const n = document.activeElement
  for (const r of e)
    if ((Br(r, { select: t }), document.activeElement !== n)) return
}
function w3(e) {
  const t = _E(e),
    n = Ex(t, e),
    r = Ex(t.reverse(), e)
  return [n, r]
}
function _E(e) {
  const t = [],
    n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === "INPUT" && r.type === "hidden"
        return r.disabled || r.hidden || i
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
            ? NodeFilter.FILTER_ACCEPT
            : NodeFilter.FILTER_SKIP
      }
    })
  for (; n.nextNode(); ) t.push(n.currentNode)
  return t
}
function Ex(e, t) {
  for (const n of e) if (!S3(n, { upTo: t })) return n
}
function S3(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0
  for (; e; ) {
    if (t !== void 0 && e === t) return !1
    if (getComputedStyle(e).display === "none") return !0
    e = e.parentElement
  }
  return !1
}
function O3(e) {
  return e instanceof HTMLInputElement && "select" in e
}
function Br(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement
    e.focus({ preventScroll: !0 }), e !== n && O3(e) && t && e.select()
  }
}
const Cx = P3()
function P3() {
  let e = []
  return {
    add(t) {
      const n = e[0]
      t !== n && (n == null || n.pause()), (e = _x(e, t)), e.unshift(t)
    },
    remove(t) {
      var n
      ;(e = _x(e, t)), (n = e[0]) === null || n === void 0 || n.resume()
    }
  }
}
function _x(e, t) {
  const n = [...e],
    r = n.indexOf(t)
  return r !== -1 && n.splice(r, 1), n
}
function $3(e) {
  return e.filter((t) => t.tagName !== "A")
}
const A3 = P.forwardRef((e, t) => {
  var n
  const {
    container: r = globalThis == null ||
    (n = globalThis.document) === null ||
    n === void 0
      ? void 0
      : n.body,
    ...i
  } = e
  return r
    ? sD.createPortal(P.createElement(dt.div, se({}, i, { ref: t })), r)
    : null
})
function T3(e, t) {
  return P.useReducer((n, r) => {
    const i = t[n][r]
    return i ?? n
  }, e)
}
const Ea = (e) => {
  const { present: t, children: n } = e,
    r = E3(t),
    i =
      typeof n == "function" ? n({ present: r.isPresent }) : P.Children.only(n),
    o = Jt(r.ref, i.ref)
  return typeof n == "function" || r.isPresent
    ? P.cloneElement(i, { ref: o })
    : null
}
Ea.displayName = "Presence"
function E3(e) {
  const [t, n] = P.useState(),
    r = P.useRef({}),
    i = P.useRef(e),
    o = P.useRef("none"),
    a = e ? "mounted" : "unmounted",
    [s, l] = T3(a, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" }
    })
  return (
    P.useEffect(() => {
      const u = Fu(r.current)
      o.current = s === "mounted" ? u : "none"
    }, [s]),
    oa(() => {
      const u = r.current,
        f = i.current
      if (f !== e) {
        const d = o.current,
          p = Fu(u)
        e
          ? l("MOUNT")
          : p === "none" || (u == null ? void 0 : u.display) === "none"
            ? l("UNMOUNT")
            : l(f && d !== p ? "ANIMATION_OUT" : "UNMOUNT"),
          (i.current = e)
      }
    }, [e, l]),
    oa(() => {
      if (t) {
        const u = (c) => {
            const p = Fu(r.current).includes(c.animationName)
            c.target === t && p && Zl.flushSync(() => l("ANIMATION_END"))
          },
          f = (c) => {
            c.target === t && (o.current = Fu(r.current))
          }
        return (
          t.addEventListener("animationstart", f),
          t.addEventListener("animationcancel", u),
          t.addEventListener("animationend", u),
          () => {
            t.removeEventListener("animationstart", f),
              t.removeEventListener("animationcancel", u),
              t.removeEventListener("animationend", u)
          }
        )
      } else l("ANIMATION_END")
    }, [t, l]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(s),
      ref: P.useCallback((u) => {
        u && (r.current = getComputedStyle(u)), n(u)
      }, [])
    }
  )
}
function Fu(e) {
  return (e == null ? void 0 : e.animationName) || "none"
}
let ch = 0
function C3() {
  P.useEffect(() => {
    var e, t
    const n = document.querySelectorAll("[data-radix-focus-guard]")
    return (
      document.body.insertAdjacentElement(
        "afterbegin",
        (e = n[0]) !== null && e !== void 0 ? e : kx()
      ),
      document.body.insertAdjacentElement(
        "beforeend",
        (t = n[1]) !== null && t !== void 0 ? t : kx()
      ),
      ch++,
      () => {
        ch === 1 &&
          document
            .querySelectorAll("[data-radix-focus-guard]")
            .forEach((r) => r.remove()),
          ch--
      }
    )
  }, [])
}
function kx() {
  const e = document.createElement("span")
  return (
    e.setAttribute("data-radix-focus-guard", ""),
    (e.tabIndex = 0),
    (e.style.cssText =
      "outline: none; opacity: 0; position: fixed; pointer-events: none"),
    e
  )
}
var zn = function () {
  return (
    (zn =
      Object.assign ||
      function (t) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r]
          for (var o in n)
            Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o])
        }
        return t
      }),
    zn.apply(this, arguments)
  )
}
function kE(e, t) {
  var n = {}
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      t.indexOf(r) < 0 &&
      (n[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
        (n[r[i]] = e[r[i]])
  return n
}
function _3(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, o; r < i; r++)
      (o || !(r in t)) &&
        (o || (o = Array.prototype.slice.call(t, 0, r)), (o[r] = t[r]))
  return e.concat(o || Array.prototype.slice.call(t))
}
var wc = "right-scroll-bar-position",
  Sc = "width-before-scroll-bar",
  k3 = "with-scroll-bars-hidden",
  M3 = "--removed-body-scroll-bar-size"
function fh(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e
}
function j3(e, t) {
  var n = P.useState(function () {
    return {
      value: e,
      callback: t,
      facade: {
        get current() {
          return n.value
        },
        set current(r) {
          var i = n.value
          i !== r && ((n.value = r), n.callback(r, i))
        }
      }
    }
  })[0]
  return (n.callback = t), n.facade
}
var Mx = new WeakMap()
function D3(e, t) {
  var n = j3(t || null, function (r) {
    return e.forEach(function (i) {
      return fh(i, r)
    })
  })
  return (
    P.useLayoutEffect(
      function () {
        var r = Mx.get(n)
        if (r) {
          var i = new Set(r),
            o = new Set(e),
            a = n.current
          i.forEach(function (s) {
            o.has(s) || fh(s, null)
          }),
            o.forEach(function (s) {
              i.has(s) || fh(s, a)
            })
        }
        Mx.set(n, e)
      },
      [e]
    ),
    n
  )
}
function I3(e) {
  return e
}
function N3(e, t) {
  t === void 0 && (t = I3)
  var n = [],
    r = !1,
    i = {
      read: function () {
        if (r)
          throw new Error(
            "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."
          )
        return n.length ? n[n.length - 1] : e
      },
      useMedium: function (o) {
        var a = t(o, r)
        return (
          n.push(a),
          function () {
            n = n.filter(function (s) {
              return s !== a
            })
          }
        )
      },
      assignSyncMedium: function (o) {
        for (r = !0; n.length; ) {
          var a = n
          ;(n = []), a.forEach(o)
        }
        n = {
          push: function (s) {
            return o(s)
          },
          filter: function () {
            return n
          }
        }
      },
      assignMedium: function (o) {
        r = !0
        var a = []
        if (n.length) {
          var s = n
          ;(n = []), s.forEach(o), (a = n)
        }
        var l = function () {
            var f = a
            ;(a = []), f.forEach(o)
          },
          u = function () {
            return Promise.resolve().then(l)
          }
        u(),
          (n = {
            push: function (f) {
              a.push(f), u()
            },
            filter: function (f) {
              return (a = a.filter(f)), n
            }
          })
      }
    }
  return i
}
function R3(e) {
  e === void 0 && (e = {})
  var t = N3(null)
  return (t.options = zn({ async: !0, ssr: !1 }, e)), t
}
var ME = function (e) {
  var t = e.sideCar,
    n = kE(e, ["sideCar"])
  if (!t)
    throw new Error(
      "Sidecar: please provide `sideCar` property to import the right car"
    )
  var r = t.read()
  if (!r) throw new Error("Sidecar medium not found")
  return P.createElement(r, zn({}, n))
}
ME.isSideCarExport = !0
function L3(e, t) {
  return e.useMedium(t), ME
}
var jE = R3(),
  dh = function () {},
  kd = P.forwardRef(function (e, t) {
    var n = P.useRef(null),
      r = P.useState({
        onScrollCapture: dh,
        onWheelCapture: dh,
        onTouchMoveCapture: dh
      }),
      i = r[0],
      o = r[1],
      a = e.forwardProps,
      s = e.children,
      l = e.className,
      u = e.removeScrollBar,
      f = e.enabled,
      c = e.shards,
      d = e.sideCar,
      p = e.noIsolation,
      h = e.inert,
      m = e.allowPinchZoom,
      b = e.as,
      g = b === void 0 ? "div" : b,
      v = kE(e, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as"
      ]),
      y = d,
      w = D3([n, t]),
      x = zn(zn({}, v), i)
    return P.createElement(
      P.Fragment,
      null,
      f &&
        P.createElement(y, {
          sideCar: jE,
          removeScrollBar: u,
          shards: c,
          noIsolation: p,
          inert: h,
          setCallbacks: o,
          allowPinchZoom: !!m,
          lockRef: n
        }),
      a
        ? P.cloneElement(P.Children.only(s), zn(zn({}, x), { ref: w }))
        : P.createElement(g, zn({}, x, { className: l, ref: w }), s)
    )
  })
kd.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }
kd.classNames = { fullWidth: Sc, zeroRight: wc }
var B3 = function () {
  if (typeof __webpack_nonce__ < "u") return __webpack_nonce__
}
function F3() {
  if (!document) return null
  var e = document.createElement("style")
  e.type = "text/css"
  var t = B3()
  return t && e.setAttribute("nonce", t), e
}
function V3(e, t) {
  e.styleSheet
    ? (e.styleSheet.cssText = t)
    : e.appendChild(document.createTextNode(t))
}
function z3(e) {
  var t = document.head || document.getElementsByTagName("head")[0]
  t.appendChild(e)
}
var U3 = function () {
    var e = 0,
      t = null
    return {
      add: function (n) {
        e == 0 && (t = F3()) && (V3(t, n), z3(t)), e++
      },
      remove: function () {
        e--,
          !e && t && (t.parentNode && t.parentNode.removeChild(t), (t = null))
      }
    }
  },
  W3 = function () {
    var e = U3()
    return function (t, n) {
      P.useEffect(
        function () {
          return (
            e.add(t),
            function () {
              e.remove()
            }
          )
        },
        [t && n]
      )
    }
  },
  DE = function () {
    var e = W3(),
      t = function (n) {
        var r = n.styles,
          i = n.dynamic
        return e(r, i), null
      }
    return t
  },
  H3 = { left: 0, top: 0, right: 0, gap: 0 },
  ph = function (e) {
    return parseInt(e || "", 10) || 0
  },
  G3 = function (e) {
    var t = window.getComputedStyle(document.body),
      n = t[e === "padding" ? "paddingLeft" : "marginLeft"],
      r = t[e === "padding" ? "paddingTop" : "marginTop"],
      i = t[e === "padding" ? "paddingRight" : "marginRight"]
    return [ph(n), ph(r), ph(i)]
  },
  K3 = function (e) {
    if ((e === void 0 && (e = "margin"), typeof window > "u")) return H3
    var t = G3(e),
      n = document.documentElement.clientWidth,
      r = window.innerWidth
    return {
      left: t[0],
      top: t[1],
      right: t[2],
      gap: Math.max(0, r - n + t[2] - t[0])
    }
  },
  q3 = DE(),
  X3 = function (e, t, n, r) {
    var i = e.left,
      o = e.top,
      a = e.right,
      s = e.gap
    return (
      n === void 0 && (n = "margin"),
      `
  .`
        .concat(
          k3,
          ` {
   overflow: hidden `
        )
        .concat(
          r,
          `;
   padding-right: `
        )
        .concat(s, "px ")
        .concat(
          r,
          `;
  }
  body {
    overflow: hidden `
        )
        .concat(
          r,
          `;
    overscroll-behavior: contain;
    `
        )
        .concat(
          [
            t && "position: relative ".concat(r, ";"),
            n === "margin" &&
              `
    padding-left: `
                .concat(
                  i,
                  `px;
    padding-top: `
                )
                .concat(
                  o,
                  `px;
    padding-right: `
                )
                .concat(
                  a,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                )
                .concat(s, "px ")
                .concat(
                  r,
                  `;
    `
                ),
            n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
          ]
            .filter(Boolean)
            .join(""),
          `
  }
  
  .`
        )
        .concat(
          wc,
          ` {
    right: `
        )
        .concat(s, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(
          Sc,
          ` {
    margin-right: `
        )
        .concat(s, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(wc, " .")
        .concat(
          wc,
          ` {
    right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(Sc, " .")
        .concat(
          Sc,
          ` {
    margin-right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  body {
    `
        )
        .concat(M3, ": ")
        .concat(
          s,
          `px;
  }
`
        )
    )
  },
  Y3 = function (e) {
    var t = e.noRelative,
      n = e.noImportant,
      r = e.gapMode,
      i = r === void 0 ? "margin" : r,
      o = P.useMemo(
        function () {
          return K3(i)
        },
        [i]
      )
    return P.createElement(q3, { styles: X3(o, !t, i, n ? "" : "!important") })
  },
  av = !1
if (typeof window < "u")
  try {
    var Vu = Object.defineProperty({}, "passive", {
      get: function () {
        return (av = !0), !0
      }
    })
    window.addEventListener("test", Vu, Vu),
      window.removeEventListener("test", Vu, Vu)
  } catch {
    av = !1
  }
var po = av ? { passive: !1 } : !1,
  Q3 = function (e) {
    return e.tagName === "TEXTAREA"
  },
  IE = function (e, t) {
    var n = window.getComputedStyle(e)
    return (
      n[t] !== "hidden" &&
      !(n.overflowY === n.overflowX && !Q3(e) && n[t] === "visible")
    )
  },
  Z3 = function (e) {
    return IE(e, "overflowY")
  },
  J3 = function (e) {
    return IE(e, "overflowX")
  },
  jx = function (e, t) {
    var n = t
    do {
      typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host)
      var r = NE(e, n)
      if (r) {
        var i = RE(e, n),
          o = i[1],
          a = i[2]
        if (o > a) return !0
      }
      n = n.parentNode
    } while (n && n !== document.body)
    return !1
  },
  e5 = function (e) {
    var t = e.scrollTop,
      n = e.scrollHeight,
      r = e.clientHeight
    return [t, n, r]
  },
  t5 = function (e) {
    var t = e.scrollLeft,
      n = e.scrollWidth,
      r = e.clientWidth
    return [t, n, r]
  },
  NE = function (e, t) {
    return e === "v" ? Z3(t) : J3(t)
  },
  RE = function (e, t) {
    return e === "v" ? e5(t) : t5(t)
  },
  n5 = function (e, t) {
    return e === "h" && t === "rtl" ? -1 : 1
  },
  r5 = function (e, t, n, r, i) {
    var o = n5(e, window.getComputedStyle(t).direction),
      a = o * r,
      s = n.target,
      l = t.contains(s),
      u = !1,
      f = a > 0,
      c = 0,
      d = 0
    do {
      var p = RE(e, s),
        h = p[0],
        m = p[1],
        b = p[2],
        g = m - b - o * h
      ;(h || g) && NE(e, s) && ((c += g), (d += h)), (s = s.parentNode)
    } while ((!l && s !== document.body) || (l && (t.contains(s) || t === s)))
    return (
      ((f && ((i && c === 0) || (!i && a > c))) ||
        (!f && ((i && d === 0) || (!i && -a > d)))) &&
        (u = !0),
      u
    )
  },
  zu = function (e) {
    return "changedTouches" in e
      ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY]
      : [0, 0]
  },
  Dx = function (e) {
    return [e.deltaX, e.deltaY]
  },
  Ix = function (e) {
    return e && "current" in e ? e.current : e
  },
  i5 = function (e, t) {
    return e[0] === t[0] && e[1] === t[1]
  },
  o5 = function (e) {
    return `
  .block-interactivity-`
      .concat(
        e,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        e,
        ` {pointer-events: all;}
`
      )
  },
  a5 = 0,
  ho = []
function s5(e) {
  var t = P.useRef([]),
    n = P.useRef([0, 0]),
    r = P.useRef(),
    i = P.useState(a5++)[0],
    o = P.useState(function () {
      return DE()
    })[0],
    a = P.useRef(e)
  P.useEffect(
    function () {
      a.current = e
    },
    [e]
  ),
    P.useEffect(
      function () {
        if (e.inert) {
          document.body.classList.add("block-interactivity-".concat(i))
          var m = _3([e.lockRef.current], (e.shards || []).map(Ix), !0).filter(
            Boolean
          )
          return (
            m.forEach(function (b) {
              return b.classList.add("allow-interactivity-".concat(i))
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(i)),
                m.forEach(function (b) {
                  return b.classList.remove("allow-interactivity-".concat(i))
                })
            }
          )
        }
      },
      [e.inert, e.lockRef.current, e.shards]
    )
  var s = P.useCallback(function (m, b) {
      if ("touches" in m && m.touches.length === 2)
        return !a.current.allowPinchZoom
      var g = zu(m),
        v = n.current,
        y = "deltaX" in m ? m.deltaX : v[0] - g[0],
        w = "deltaY" in m ? m.deltaY : v[1] - g[1],
        x,
        S = m.target,
        O = Math.abs(y) > Math.abs(w) ? "h" : "v"
      if ("touches" in m && O === "h" && S.type === "range") return !1
      var $ = jx(O, S)
      if (!$) return !0
      if (($ ? (x = O) : ((x = O === "v" ? "h" : "v"), ($ = jx(O, S))), !$))
        return !1
      if (
        (!r.current && "changedTouches" in m && (y || w) && (r.current = x), !x)
      )
        return !0
      var A = r.current || x
      return r5(A, b, m, A === "h" ? y : w, !0)
    }, []),
    l = P.useCallback(function (m) {
      var b = m
      if (!(!ho.length || ho[ho.length - 1] !== o)) {
        var g = "deltaY" in b ? Dx(b) : zu(b),
          v = t.current.filter(function (x) {
            return x.name === b.type && x.target === b.target && i5(x.delta, g)
          })[0]
        if (v && v.should) {
          b.cancelable && b.preventDefault()
          return
        }
        if (!v) {
          var y = (a.current.shards || [])
              .map(Ix)
              .filter(Boolean)
              .filter(function (x) {
                return x.contains(b.target)
              }),
            w = y.length > 0 ? s(b, y[0]) : !a.current.noIsolation
          w && b.cancelable && b.preventDefault()
        }
      }
    }, []),
    u = P.useCallback(function (m, b, g, v) {
      var y = { name: m, delta: b, target: g, should: v }
      t.current.push(y),
        setTimeout(function () {
          t.current = t.current.filter(function (w) {
            return w !== y
          })
        }, 1)
    }, []),
    f = P.useCallback(function (m) {
      ;(n.current = zu(m)), (r.current = void 0)
    }, []),
    c = P.useCallback(function (m) {
      u(m.type, Dx(m), m.target, s(m, e.lockRef.current))
    }, []),
    d = P.useCallback(function (m) {
      u(m.type, zu(m), m.target, s(m, e.lockRef.current))
    }, [])
  P.useEffect(function () {
    return (
      ho.push(o),
      e.setCallbacks({
        onScrollCapture: c,
        onWheelCapture: c,
        onTouchMoveCapture: d
      }),
      document.addEventListener("wheel", l, po),
      document.addEventListener("touchmove", l, po),
      document.addEventListener("touchstart", f, po),
      function () {
        ;(ho = ho.filter(function (m) {
          return m !== o
        })),
          document.removeEventListener("wheel", l, po),
          document.removeEventListener("touchmove", l, po),
          document.removeEventListener("touchstart", f, po)
      }
    )
  }, [])
  var p = e.removeScrollBar,
    h = e.inert
  return P.createElement(
    P.Fragment,
    null,
    h ? P.createElement(o, { styles: o5(i) }) : null,
    p ? P.createElement(Y3, { gapMode: "margin" }) : null
  )
}
const l5 = L3(jE, s5)
var LE = P.forwardRef(function (e, t) {
  return P.createElement(kd, zn({}, e, { ref: t, sideCar: l5 }))
})
LE.classNames = kd.classNames
const u5 = LE
var c5 = function (e) {
    if (typeof document > "u") return null
    var t = Array.isArray(e) ? e[0] : e
    return t.ownerDocument.body
  },
  mo = new WeakMap(),
  Uu = new WeakMap(),
  Wu = {},
  hh = 0,
  BE = function (e) {
    return e && (e.host || BE(e.parentNode))
  },
  f5 = function (e, t) {
    return t
      .map(function (n) {
        if (e.contains(n)) return n
        var r = BE(n)
        return r && e.contains(r)
          ? r
          : (console.error(
              "aria-hidden",
              n,
              "in not contained inside",
              e,
              ". Doing nothing"
            ),
            null)
      })
      .filter(function (n) {
        return !!n
      })
  },
  d5 = function (e, t, n, r) {
    var i = f5(t, Array.isArray(e) ? e : [e])
    Wu[n] || (Wu[n] = new WeakMap())
    var o = Wu[n],
      a = [],
      s = new Set(),
      l = new Set(i),
      u = function (c) {
        !c || s.has(c) || (s.add(c), u(c.parentNode))
      }
    i.forEach(u)
    var f = function (c) {
      !c ||
        l.has(c) ||
        Array.prototype.forEach.call(c.children, function (d) {
          if (s.has(d)) f(d)
          else {
            var p = d.getAttribute(r),
              h = p !== null && p !== "false",
              m = (mo.get(d) || 0) + 1,
              b = (o.get(d) || 0) + 1
            mo.set(d, m),
              o.set(d, b),
              a.push(d),
              m === 1 && h && Uu.set(d, !0),
              b === 1 && d.setAttribute(n, "true"),
              h || d.setAttribute(r, "true")
          }
        })
    }
    return (
      f(t),
      s.clear(),
      hh++,
      function () {
        a.forEach(function (c) {
          var d = mo.get(c) - 1,
            p = o.get(c) - 1
          mo.set(c, d),
            o.set(c, p),
            d || (Uu.has(c) || c.removeAttribute(r), Uu.delete(c)),
            p || c.removeAttribute(n)
        }),
          hh--,
          hh ||
            ((mo = new WeakMap()),
            (mo = new WeakMap()),
            (Uu = new WeakMap()),
            (Wu = {}))
      }
    )
  },
  p5 = function (e, t, n) {
    n === void 0 && (n = "data-aria-hidden")
    var r = Array.from(Array.isArray(e) ? e : [e]),
      i = t || c5(e)
    return i
      ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))),
        d5(r, i, n, "aria-hidden"))
      : function () {
          return null
        }
  }
const FE = "Dialog",
  [VE, jle] = Ta(FE),
  [h5, In] = VE(FE),
  m5 = (e) => {
    const {
        __scopeDialog: t,
        children: n,
        open: r,
        defaultOpen: i,
        onOpenChange: o,
        modal: a = !0
      } = e,
      s = P.useRef(null),
      l = P.useRef(null),
      [u = !1, f] = _d({ prop: r, defaultProp: i, onChange: o })
    return P.createElement(
      h5,
      {
        scope: t,
        triggerRef: s,
        contentRef: l,
        contentId: Wo(),
        titleId: Wo(),
        descriptionId: Wo(),
        open: u,
        onOpenChange: f,
        onOpenToggle: P.useCallback(() => f((c) => !c), [f]),
        modal: a
      },
      n
    )
  },
  v5 = "DialogTrigger",
  g5 = P.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = In(v5, n),
      o = Jt(t, i.triggerRef)
    return P.createElement(
      dt.button,
      se(
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": i.open,
          "aria-controls": i.contentId,
          "data-state": Wy(i.open)
        },
        r,
        { ref: o, onClick: Be(e.onClick, i.onOpenToggle) }
      )
    )
  }),
  zE = "DialogPortal",
  [y5, UE] = VE(zE, { forceMount: void 0 }),
  b5 = (e) => {
    const { __scopeDialog: t, forceMount: n, children: r, container: i } = e,
      o = In(zE, t)
    return P.createElement(
      y5,
      { scope: t, forceMount: n },
      P.Children.map(r, (a) =>
        P.createElement(
          Ea,
          { present: n || o.open },
          P.createElement(A3, { asChild: !0, container: i }, a)
        )
      )
    )
  },
  sv = "DialogOverlay",
  x5 = P.forwardRef((e, t) => {
    const n = UE(sv, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...i } = e,
      o = In(sv, e.__scopeDialog)
    return o.modal
      ? P.createElement(
          Ea,
          { present: r || o.open },
          P.createElement(w5, se({}, i, { ref: t }))
        )
      : null
  }),
  w5 = P.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = In(sv, n)
    return P.createElement(
      u5,
      { as: ia, allowPinchZoom: !0, shards: [i.contentRef] },
      P.createElement(
        dt.div,
        se({ "data-state": Wy(i.open) }, r, {
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        })
      )
    )
  }),
  ol = "DialogContent",
  S5 = P.forwardRef((e, t) => {
    const n = UE(ol, e.__scopeDialog),
      { forceMount: r = n.forceMount, ...i } = e,
      o = In(ol, e.__scopeDialog)
    return P.createElement(
      Ea,
      { present: r || o.open },
      o.modal
        ? P.createElement(O5, se({}, i, { ref: t }))
        : P.createElement(P5, se({}, i, { ref: t }))
    )
  }),
  O5 = P.forwardRef((e, t) => {
    const n = In(ol, e.__scopeDialog),
      r = P.useRef(null),
      i = Jt(t, n.contentRef, r)
    return (
      P.useEffect(() => {
        const o = r.current
        if (o) return p5(o)
      }, []),
      P.createElement(
        WE,
        se({}, e, {
          ref: i,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Be(e.onCloseAutoFocus, (o) => {
            var a
            o.preventDefault(),
              (a = n.triggerRef.current) === null || a === void 0 || a.focus()
          }),
          onPointerDownOutside: Be(e.onPointerDownOutside, (o) => {
            const a = o.detail.originalEvent,
              s = a.button === 0 && a.ctrlKey === !0
            ;(a.button === 2 || s) && o.preventDefault()
          }),
          onFocusOutside: Be(e.onFocusOutside, (o) => o.preventDefault())
        })
      )
    )
  }),
  P5 = P.forwardRef((e, t) => {
    const n = In(ol, e.__scopeDialog),
      r = P.useRef(!1),
      i = P.useRef(!1)
    return P.createElement(
      WE,
      se({}, e, {
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (o) => {
          var a
          if (
            ((a = e.onCloseAutoFocus) === null || a === void 0 || a.call(e, o),
            !o.defaultPrevented)
          ) {
            var s
            r.current ||
              (s = n.triggerRef.current) === null ||
              s === void 0 ||
              s.focus(),
              o.preventDefault()
          }
          ;(r.current = !1), (i.current = !1)
        },
        onInteractOutside: (o) => {
          var a, s
          ;(a = e.onInteractOutside) === null || a === void 0 || a.call(e, o),
            o.defaultPrevented ||
              ((r.current = !0),
              o.detail.originalEvent.type === "pointerdown" && (i.current = !0))
          const l = o.target
          ;((s = n.triggerRef.current) === null || s === void 0
            ? void 0
            : s.contains(l)) && o.preventDefault(),
            o.detail.originalEvent.type === "focusin" &&
              i.current &&
              o.preventDefault()
        }
      })
    )
  }),
  WE = P.forwardRef((e, t) => {
    const {
        __scopeDialog: n,
        trapFocus: r,
        onOpenAutoFocus: i,
        onCloseAutoFocus: o,
        ...a
      } = e,
      s = In(ol, n),
      l = P.useRef(null),
      u = Jt(t, l)
    return (
      C3(),
      P.createElement(
        P.Fragment,
        null,
        P.createElement(
          b3,
          {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: i,
            onUnmountAutoFocus: o
          },
          P.createElement(
            EE,
            se(
              {
                role: "dialog",
                id: s.contentId,
                "aria-describedby": s.descriptionId,
                "aria-labelledby": s.titleId,
                "data-state": Wy(s.open)
              },
              a,
              { ref: u, onDismiss: () => s.onOpenChange(!1) }
            )
          )
        ),
        !1
      )
    )
  }),
  $5 = "DialogTitle",
  A5 = P.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = In($5, n)
    return P.createElement(dt.h2, se({ id: i.titleId }, r, { ref: t }))
  }),
  T5 = "DialogDescription",
  E5 = P.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = In(T5, n)
    return P.createElement(dt.p, se({ id: i.descriptionId }, r, { ref: t }))
  }),
  C5 = "DialogClose",
  _5 = P.forwardRef((e, t) => {
    const { __scopeDialog: n, ...r } = e,
      i = In(C5, n)
    return P.createElement(
      dt.button,
      se({ type: "button" }, r, {
        ref: t,
        onClick: Be(e.onClick, () => i.onOpenChange(!1))
      })
    )
  })
function Wy(e) {
  return e ? "open" : "closed"
}
const k5 = m5,
  M5 = g5,
  j5 = b5,
  D5 = x5,
  I5 = S5,
  N5 = A5,
  R5 = E5,
  L5 = _5
var HE = E.createContext({
    drawerRef: { current: null },
    overlayRef: { current: null },
    scaleBackground: () => {},
    onPress: () => {},
    onRelease: () => {},
    onDrag: () => {},
    onNestedDrag: () => {},
    onNestedOpenChange: () => {},
    onNestedRelease: () => {},
    openProp: void 0,
    dismissible: !1,
    isOpen: !1,
    keyboardIsOpen: { current: !1 },
    snapPointsOffset: null,
    snapPoints: null,
    modal: !1,
    shouldFade: !1,
    activeSnapPoint: null,
    onOpenChange: () => {},
    setActiveSnapPoint: () => {},
    visible: !1,
    closeDrawer: () => {},
    setVisible: () => {}
  }),
  Hy = () => E.useContext(HE)
function B5(e, { insertAt: t } = {}) {
  if (!e || typeof document > "u") return
  let n = document.head || document.getElementsByTagName("head")[0],
    r = document.createElement("style")
  ;(r.type = "text/css"),
    t === "top" && n.firstChild
      ? n.insertBefore(r, n.firstChild)
      : n.appendChild(r),
    r.styleSheet
      ? (r.styleSheet.cssText = e)
      : r.appendChild(document.createTextNode(e))
}
B5(`[vaul-drawer]{touch-action:none;transform:translate3d(0,100%,0);transition:transform .5s cubic-bezier(.32,.72,0,1)}.vaul-dragging .vaul-scrollable{overflow-y:hidden!important}[vaul-drawer][vaul-drawer-visible=true]{transform:translate3d(0,var(--snap-point-height, 0),0)}[vaul-overlay]{opacity:0;transition:opacity .5s cubic-bezier(.32,.72,0,1)}[vaul-overlay][vaul-drawer-visible=true]{opacity:1}[vaul-drawer]:after{content:"";position:absolute;top:100%;background:inherit;background-color:inherit;left:0;right:0;height:200%}[vaul-overlay][vaul-snap-points=true]:not([vaul-snap-points-overlay="true"]):not([data-state="closed"]){opacity:0}[vaul-overlay][vaul-snap-points-overlay=true]:not([vaul-drawer-visible="false"]){opacity:1}@keyframes fake-animation{}@media (hover: hover) and (pointer: fine){[vaul-drawer]{user-select:none}}
`)
var F5 = typeof window < "u" ? P.useLayoutEffect : P.useEffect
function lv(...e) {
  return (...t) => {
    for (let n of e) typeof n == "function" && n(...t)
  }
}
function V5() {
  return Gy(/^Mac/)
}
function z5() {
  return Gy(/^iPhone/)
}
function U5() {
  return Gy(/^iPad/) || (V5() && navigator.maxTouchPoints > 1)
}
function GE() {
  return z5() || U5()
}
function Gy(e) {
  return typeof window < "u" && window.navigator != null
    ? e.test(window.navigator.platform)
    : void 0
}
var mh = typeof document < "u" && window.visualViewport
function Nx(e) {
  let t = window.getComputedStyle(e)
  return /(auto|scroll)/.test(t.overflow + t.overflowX + t.overflowY)
}
function KE(e) {
  for (Nx(e) && (e = e.parentElement); e && !Nx(e); ) e = e.parentElement
  return e || document.scrollingElement || document.documentElement
}
var W5 = new Set([
    "checkbox",
    "radio",
    "range",
    "color",
    "file",
    "image",
    "button",
    "submit",
    "reset"
  ]),
  Hu = 0,
  vh
function H5(e = {}) {
  let { isDisabled: t } = e
  F5(() => {
    if (!t)
      return (
        Hu++,
        Hu === 1 && (GE() ? (vh = K5()) : (vh = G5())),
        () => {
          Hu--, Hu === 0 && vh()
        }
      )
  }, [t])
}
function G5() {
  return lv(
    lf(
      document.documentElement,
      "paddingRight",
      `${window.innerWidth - document.documentElement.clientWidth}px`
    ),
    lf(document.documentElement, "overflow", "hidden")
  )
}
function K5() {
  let e,
    t = 0,
    n = (c) => {
      ;(e = KE(c.target)),
        !(e === document.documentElement && e === document.body) &&
          (t = c.changedTouches[0].pageY)
    },
    r = (c) => {
      if (!e || e === document.documentElement || e === document.body) {
        c.preventDefault()
        return
      }
      let d = c.changedTouches[0].pageY,
        p = e.scrollTop,
        h = e.scrollHeight - e.clientHeight
      h !== 0 &&
        (((p <= 0 && d > t) || (p >= h && d < t)) && c.preventDefault(),
        (t = d))
    },
    i = (c) => {
      let d = c.target
      uf(d) &&
        d !== document.activeElement &&
        (c.preventDefault(),
        (d.style.transform = "translateY(-2000px)"),
        d.focus(),
        requestAnimationFrame(() => {
          d.style.transform = ""
        }))
    },
    o = (c) => {
      let d = c.target
      uf(d) &&
        ((d.style.transform = "translateY(-2000px)"),
        requestAnimationFrame(() => {
          ;(d.style.transform = ""),
            mh &&
              (mh.height < window.innerHeight
                ? requestAnimationFrame(() => {
                    Rx(d)
                  })
                : mh.addEventListener("resize", () => Rx(d), { once: !0 }))
        }))
    },
    a = () => {
      window.scrollTo(0, 0)
    },
    s = window.pageXOffset,
    l = window.pageYOffset,
    u = lv(
      lf(
        document.documentElement,
        "paddingRight",
        `${window.innerWidth - document.documentElement.clientWidth}px`
      ),
      lf(document.documentElement, "overflow", "hidden")
    )
  window.scrollTo(0, 0)
  let f = lv(
    ns(document, "touchstart", n, { passive: !1, capture: !0 }),
    ns(document, "touchmove", r, { passive: !1, capture: !0 }),
    ns(document, "touchend", i, { passive: !1, capture: !0 }),
    ns(document, "focus", o, !0),
    ns(window, "scroll", a)
  )
  return () => {
    u(), f(), window.scrollTo(s, l)
  }
}
function lf(e, t, n) {
  let r = e.style[t]
  return (
    (e.style[t] = n),
    () => {
      e.style[t] = r
    }
  )
}
function ns(e, t, n, r) {
  return (
    e.addEventListener(t, n, r),
    () => {
      e.removeEventListener(t, n, r)
    }
  )
}
function Rx(e) {
  let t = document.scrollingElement || document.documentElement
  for (; e && e !== t; ) {
    let n = KE(e)
    if (n !== document.documentElement && n !== document.body && n !== e) {
      let r = n.getBoundingClientRect().top,
        i = e.getBoundingClientRect().top,
        o = e.getBoundingClientRect().bottom,
        a = n.getBoundingClientRect().bottom
      o > a && (n.scrollTop += i - r)
    }
    e = n.parentElement
  }
}
function uf(e) {
  return (
    (e instanceof HTMLInputElement && !W5.has(e.type)) ||
    e instanceof HTMLTextAreaElement ||
    (e instanceof HTMLElement && e.isContentEditable)
  )
}
function q5(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t)
}
function X5(...e) {
  return (t) => e.forEach((n) => q5(n, t))
}
function qE(...e) {
  return P.useCallback(X5(...e), e)
}
var Rr = null
function Y5({ isOpen: e, modal: t, nested: n, hasBeenOpened: r }) {
  let [i, o] = E.useState(typeof window < "u" ? window.location.href : ""),
    a = E.useRef(0)
  function s() {
    if (Rr === null && e) {
      Rr = {
        position: document.body.style.position,
        top: document.body.style.top,
        left: document.body.style.left,
        height: document.body.style.height
      }
      let { scrollX: u, innerHeight: f } = window
      document.body.style.setProperty("position", "fixed", "important"),
        (document.body.style.top = `${-a.current}px`),
        (document.body.style.left = `${-u}px`),
        (document.body.style.right = "0px"),
        (document.body.style.height = "auto"),
        setTimeout(
          () =>
            requestAnimationFrame(() => {
              let c = f - window.innerHeight
              c &&
                a.current >= f &&
                (document.body.style.top = `${-(a.current + c)}px`)
            }),
          300
        )
    }
  }
  function l() {
    if (Rr !== null) {
      let u = -parseInt(document.body.style.top, 10),
        f = -parseInt(document.body.style.left, 10)
      ;(document.body.style.position = Rr.position),
        (document.body.style.top = Rr.top),
        (document.body.style.left = Rr.left),
        (document.body.style.height = Rr.height),
        (document.body.style.right = "unset"),
        requestAnimationFrame(() => {
          if (i !== window.location.href) {
            o(window.location.href)
            return
          }
          window.scrollTo(f, u)
        }),
        (Rr = null)
    }
  }
  return (
    E.useEffect(() => {
      function u() {
        a.current = window.scrollY
      }
      return (
        u(),
        window.addEventListener("scroll", u),
        () => {
          window.removeEventListener("scroll", u)
        }
      )
    }, []),
    E.useEffect(() => {
      n ||
        !r ||
        (e
          ? (s(),
            t ||
              setTimeout(() => {
                l()
              }, 500))
          : l())
    }, [e, r, i]),
    { restorePositionSetting: l }
  )
}
var XE = new WeakMap()
function Re(e, t, n = !1) {
  if (!e || !(e instanceof HTMLElement) || !t) return
  let r = {}
  Object.entries(t).forEach(([i, o]) => {
    if (i.startsWith("--")) {
      e.style.setProperty(i, o)
      return
    }
    ;(r[i] = e.style[i]), (e.style[i] = o)
  }),
    !n && XE.set(e, r)
}
function Gu(e, t) {
  if (!e || !(e instanceof HTMLElement)) return
  let n = XE.get(e)
  n &&
    (t
      ? (e.style[t] = n[t])
      : Object.entries(n).forEach(([r, i]) => {
          e.style[r] = i
        }))
}
function Ku(e) {
  let t = window.getComputedStyle(e),
    n = t.transform || t.webkitTransform || t.mozTransform,
    r = n.match(/^matrix3d\((.+)\)$/)
  return r
    ? parseFloat(r[1].split(", ")[13])
    : ((r = n.match(/^matrix\((.+)\)$/)),
      r ? parseFloat(r[1].split(", ")[5]) : null)
}
function Q5(e) {
  return 8 * (Math.log(e + 1) - 2)
}
var we = { DURATION: 0.5, EASE: [0.32, 0.72, 0, 1] },
  YE = 0.4
function QE(e) {
  let t = E.useRef(e)
  return (
    E.useEffect(() => {
      t.current = e
    }),
    E.useMemo(
      () =>
        (...n) => {
          var r
          return (r = t.current) == null ? void 0 : r.call(t, ...n)
        },
      []
    )
  )
}
function Z5({ defaultProp: e, onChange: t }) {
  let n = E.useState(e),
    [r] = n,
    i = E.useRef(r),
    o = QE(t)
  return (
    E.useEffect(() => {
      i.current !== r && (o(r), (i.current = r))
    }, [r, i, o]),
    n
  )
}
function J5({ prop: e, defaultProp: t, onChange: n = () => {} }) {
  let [r, i] = Z5({ defaultProp: t, onChange: n }),
    o = e !== void 0,
    a = o ? e : r,
    s = QE(n),
    l = E.useCallback(
      (u) => {
        if (o) {
          let f = typeof u == "function" ? u(e) : u
          f !== e && s(f)
        } else i(u)
      },
      [o, e, i, s]
    )
  return [a, l]
}
function eB({
  activeSnapPointProp: e,
  setActiveSnapPointProp: t,
  snapPoints: n,
  drawerRef: r,
  overlayRef: i,
  fadeFromIndex: o,
  onSnapPointChange: a
}) {
  let [s, l] = J5({
      prop: e,
      defaultProp: n == null ? void 0 : n[0],
      onChange: t
    }),
    u = E.useMemo(() => s === (n == null ? void 0 : n[n.length - 1]), [n, s]),
    f =
      (n && n.length > 0 && (o || o === 0) && !Number.isNaN(o) && n[o] === s) ||
      !n,
    c = E.useMemo(() => {
      var v
      return (v = n == null ? void 0 : n.findIndex((y) => y === s)) != null
        ? v
        : null
    }, [n, s]),
    d = E.useMemo(() => {
      var v
      return (v =
        n == null
          ? void 0
          : n.map((y) => {
              let w = typeof window < "u",
                x = typeof y == "string",
                S = 0
              x && (S = parseInt(y, 10))
              let O = x ? S : w ? y * window.innerHeight : 0
              return w ? window.innerHeight - O : O
            })) != null
        ? v
        : []
    }, [n]),
    p = E.useMemo(
      () => (c !== null ? (d == null ? void 0 : d[c]) : null),
      [d, c]
    ),
    h = E.useCallback(
      (v) => {
        var y
        let w =
          (y = d == null ? void 0 : d.findIndex((x) => x === v)) != null
            ? y
            : null
        a(w),
          Re(r.current, {
            transition: `transform ${we.DURATION}s cubic-bezier(${we.EASE.join(
              ","
            )})`,
            transform: `translate3d(0, ${v}px, 0)`
          }),
          d && w !== d.length - 1 && w !== o
            ? Re(i.current, {
                transition: `opacity ${
                  we.DURATION
                }s cubic-bezier(${we.EASE.join(",")})`,
                opacity: "0"
              })
            : Re(i.current, {
                transition: `opacity ${
                  we.DURATION
                }s cubic-bezier(${we.EASE.join(",")})`,
                opacity: "1"
              }),
          l(w !== null ? (n == null ? void 0 : n[w]) : null)
      },
      [r.current, n, d, o, i, l]
    )
  E.useEffect(() => {
    var v
    if (e) {
      let y =
        (v = n == null ? void 0 : n.findIndex((w) => w === e)) != null
          ? v
          : null
      d && y && typeof d[y] == "number" && h(d[y])
    }
  }, [e, n, d, h])
  function m({
    draggedDistance: v,
    closeDrawer: y,
    velocity: w,
    dismissible: x
  }) {
    if (o === void 0) return
    let S = p - v,
      O = c === o - 1,
      $ = c === 0,
      A = v > 0
    if (
      (O &&
        Re(i.current, {
          transition: `opacity ${we.DURATION}s cubic-bezier(${we.EASE.join(
            ","
          )})`
        }),
      w > 2 && !A)
    ) {
      x ? y() : h(d[0])
      return
    }
    if (w > 2 && A && d && n) {
      h(d[n.length - 1])
      return
    }
    let C =
      d == null
        ? void 0
        : d.reduce((T, _) =>
            typeof T != "number" || typeof _ != "number"
              ? T
              : Math.abs(_ - S) < Math.abs(T - S)
                ? _
                : T
          )
    if (w > YE && Math.abs(v) < window.innerHeight * 0.4) {
      let T = A ? 1 : -1
      if (T > 0 && u) {
        h(d[n.length - 1])
        return
      }
      if (($ && T < 0 && x && y(), c === null)) return
      h(d[c + T])
      return
    }
    h(C)
  }
  function b({ draggedDistance: v }) {
    if (p === null) return
    let y = p - v
    Re(r.current, { transform: `translate3d(0, ${y}px, 0)` })
  }
  function g(v, y) {
    if (!n || typeof c != "number" || !d || o === void 0) return null
    let w = c === o - 1
    if (c >= o && y) return 0
    if (w && !y) return 1
    if (!f && !w) return null
    let x = w ? c + 1 : c - 1,
      S = w ? d[x] - d[x - 1] : d[x + 1] - d[x],
      O = v / Math.abs(S)
    return w ? 1 - O : O
  }
  return {
    isLastSnapPoint: u,
    activeSnapPoint: s,
    shouldFade: f,
    getPercentageDragged: g,
    setActiveSnapPoint: l,
    activeSnapPointIndex: c,
    onRelease: m,
    onDrag: b,
    snapPointsOffset: d
  }
}
var tB = 0.25,
  nB = 100,
  Lx = 8,
  Ti = 16,
  Bx = 26,
  Fx = "vaul-dragging"
function ZE({
  open: e,
  onOpenChange: t,
  children: n,
  shouldScaleBackground: r,
  onDrag: i,
  onRelease: o,
  snapPoints: a,
  nested: s,
  closeThreshold: l = tB,
  scrollLockTimeout: u = nB,
  dismissible: f = !0,
  fadeFromIndex: c = a && a.length - 1,
  activeSnapPoint: d,
  setActiveSnapPoint: p,
  fixed: h,
  modal: m = !0,
  onClose: b
}) {
  var g
  let [v = !1, y] = E.useState(!1),
    [w, x] = E.useState(!1),
    [S, O] = E.useState(!1),
    [$, A] = E.useState(!1),
    [C, T] = E.useState(!1),
    [_, R] = E.useState(!1),
    M = E.useRef(null),
    D = E.useRef(null),
    N = E.useRef(null),
    L = E.useRef(null),
    k = E.useRef(null),
    I = E.useRef(!1),
    V = E.useRef(null),
    U = E.useRef(0),
    H = E.useRef(!1),
    ee = E.useRef(0),
    X = E.useRef(null),
    de = E.useRef(
      ((g = X.current) == null ? void 0 : g.getBoundingClientRect().height) || 0
    ),
    ue = E.useRef(0),
    We = E.useCallback((te) => {
      a && te === F.length - 1 && (D.current = new Date())
    }, []),
    {
      activeSnapPoint: Qe,
      activeSnapPointIndex: W,
      setActiveSnapPoint: Q,
      onRelease: Z,
      snapPointsOffset: F,
      onDrag: me,
      shouldFade: ae,
      getPercentageDragged: ve
    } = eB({
      snapPoints: a,
      activeSnapPointProp: d,
      setActiveSnapPointProp: p,
      drawerRef: X,
      fadeFromIndex: c,
      overlayRef: M,
      onSnapPointChange: We
    })
  H5({ isDisabled: !v || C || !m || _ || !w })
  let { restorePositionSetting: je } = Y5({
    isOpen: v,
    modal: m,
    nested: s,
    hasBeenOpened: w
  })
  function Ke() {
    return (window.innerWidth - Bx) / window.innerWidth
  }
  function It(te) {
    var ne
    ;(!f && !a) ||
      (X.current && !X.current.contains(te.target)) ||
      ((de.current =
        ((ne = X.current) == null
          ? void 0
          : ne.getBoundingClientRect().height) || 0),
      T(!0),
      (N.current = new Date()),
      GE() &&
        window.addEventListener("touchend", () => (I.current = !1), {
          once: !0
        }),
      te.target.setPointerCapture(te.pointerId),
      (U.current = te.screenY))
  }
  function er(te, ne) {
    var Ne
    let Je = te,
      mt = (Ne = window.getSelection()) == null ? void 0 : Ne.toString(),
      et = X.current ? Ku(X.current) : null,
      Sn = new Date()
    if (D.current && Sn.getTime() - D.current.getTime() < 500) return !1
    if (et > 0) return !0
    if (mt && mt.length > 0) return !1
    if ((k.current && Sn.getTime() - k.current.getTime() < u && et === 0) || ne)
      return (k.current = Sn), !1
    for (; Je; ) {
      if (Je.scrollHeight > Je.clientHeight) {
        if (Je.scrollTop !== 0) return (k.current = new Date()), !1
        if (Je.getAttribute("role") === "dialog") return !0
      }
      Je = Je.parentNode
    }
    return !0
  }
  function wn(te) {
    if (C) {
      let ne = U.current - te.screenY,
        Ne = ne > 0
      if ((a && W === 0 && !f) || (!I.current && !er(te.target, Ne))) return
      if (
        (X.current.classList.add(Fx),
        (I.current = !0),
        Re(X.current, { transition: "none" }),
        Re(M.current, { transition: "none" }),
        a && me({ draggedDistance: ne }),
        Ne && !a)
      ) {
        let tr = Q5(ne)
        Re(X.current, {
          transform: `translate3d(0, ${Math.min(tr * -1, 0)}px, 0)`
        })
        return
      }
      let Je = Math.abs(ne),
        mt = document.querySelector("[vaul-drawer-wrapper]"),
        et = Je / de.current,
        Sn = ve(Je, Ne)
      Sn !== null && (et = Sn)
      let Op = 1 - et
      if (
        ((ae || (c && W === c - 1)) &&
          (i == null || i(te, et),
          Re(M.current, { opacity: `${Op}`, transition: "none" }, !0)),
        mt && M.current && r)
      ) {
        let tr = Math.min(Ke() + et * (1 - Ke()), 1),
          vu = 8 - et * 8,
          DM = Math.max(0, 14 - et * 14)
        Re(
          mt,
          {
            borderRadius: `${vu}px`,
            transform: `scale(${tr}) translate3d(0, ${DM}px, 0)`,
            transition: "none"
          },
          !0
        )
      }
      a || Re(X.current, { transform: `translate3d(0, ${Je}px, 0)` })
    }
  }
  E.useEffect(
    () => () => {
      jr(!1), je()
    },
    []
  ),
    E.useEffect(() => {
      var te
      function ne() {
        var Ne
        if (!X.current) return
        let Je = document.activeElement
        if (uf(Je) || H.current) {
          let mt =
              ((Ne = window.visualViewport) == null ? void 0 : Ne.height) || 0,
            et = window.innerHeight - mt,
            Sn = X.current.getBoundingClientRect().height || 0
          ue.current || (ue.current = Sn)
          let Op = X.current.getBoundingClientRect().top
          if (
            (Math.abs(ee.current - et) > 60 && (H.current = !H.current),
            a && a.length > 0 && F && W)
          ) {
            let tr = F[W] || 0
            et += tr
          }
          if (((ee.current = et), Sn > mt || H.current)) {
            let tr = X.current.getBoundingClientRect().height,
              vu = tr
            tr > mt && (vu = mt - Bx),
              h
                ? (X.current.style.height = `${tr - Math.max(et, 0)}px`)
                : (X.current.style.height = `${Math.max(vu, mt - Op)}px`)
          } else X.current.style.height = `${ue.current}px`
          a && a.length > 0 && !H.current
            ? (X.current.style.bottom = "0px")
            : (X.current.style.bottom = `${Math.max(et, 0)}px`)
        }
      }
      return (
        (te = window.visualViewport) == null ||
          te.addEventListener("resize", ne),
        () => {
          var Ne
          return (Ne = window.visualViewport) == null
            ? void 0
            : Ne.removeEventListener("resize", ne)
        }
      )
    }, [W, a, F])
  function Ze() {
    X.current &&
      (b == null || b(),
      Re(X.current, {
        transform: "translate3d(0, 100%, 0)",
        transition: `transform ${we.DURATION}s cubic-bezier(${we.EASE.join(
          ","
        )})`
      }),
      Re(M.current, {
        opacity: "0",
        transition: `opacity ${we.DURATION}s cubic-bezier(${we.EASE.join(",")})`
      }),
      jr(!1),
      setTimeout(() => {
        O(!1), y(!1)
      }, 300),
      setTimeout(() => {
        a && Q(a[0])
      }, we.DURATION * 1e3))
  }
  E.useEffect(() => {
    if (!v && r) {
      let te = setTimeout(() => {
        Gu(document.body)
      }, 200)
      return () => clearTimeout(te)
    }
  }, [v, r]),
    E.useEffect(() => {
      e ? (y(!0), x(!0)) : Ze()
    }, [e]),
    E.useEffect(() => {
      $ && (t == null || t(v))
    }, [v]),
    E.useEffect(() => {
      A(!0)
    }, [])
  function Rn() {
    if (!X.current) return
    let te = document.querySelector("[vaul-drawer-wrapper]"),
      ne = Ku(X.current)
    Re(X.current, {
      transform: "translate3d(0, 0, 0)",
      transition: `transform ${we.DURATION}s cubic-bezier(${we.EASE.join(",")})`
    }),
      Re(M.current, {
        transition: `opacity ${we.DURATION}s cubic-bezier(${we.EASE.join(
          ","
        )})`,
        opacity: "1"
      }),
      r &&
        ne &&
        ne > 0 &&
        v &&
        Re(
          te,
          {
            borderRadius: `${Lx}px`,
            overflow: "hidden",
            transform: `scale(${Ke()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
            transformOrigin: "top",
            transitionProperty: "transform, border-radius",
            transitionDuration: `${we.DURATION}s`,
            transitionTimingFunction: `cubic-bezier(${we.EASE.join(",")})`
          },
          !0
        )
  }
  function co(te) {
    var ne
    if (!C || !X.current) return
    I.current && uf(te.target) && te.target.blur(),
      X.current.classList.remove(Fx),
      (I.current = !1),
      T(!1),
      (L.current = new Date())
    let Ne = Ku(X.current)
    if (!er(te.target, !1) || !Ne || Number.isNaN(Ne) || N.current === null)
      return
    let Je = L.current.getTime() - N.current.getTime(),
      mt = U.current - te.screenY,
      et = Math.abs(mt) / Je
    if (
      (et > 0.05 &&
        (R(!0),
        setTimeout(() => {
          R(!1)
        }, 200)),
      a)
    ) {
      Z({ draggedDistance: mt, closeDrawer: Ze, velocity: et, dismissible: f }),
        o == null || o(te, !0)
      return
    }
    if (mt > 0) {
      Rn(), o == null || o(te, !0)
      return
    }
    if (et > YE) {
      Ze(), o == null || o(te, !1)
      return
    }
    let Sn = Math.min(
      (ne = X.current.getBoundingClientRect().height) != null ? ne : 0,
      window.innerHeight
    )
    if (Ne >= Sn * l) {
      Ze(), o == null || o(te, !1)
      return
    }
    o == null || o(te, !0), Rn()
  }
  E.useEffect(() => {
    v && ((D.current = new Date()), jr(!0))
  }, [v]),
    E.useEffect(() => {
      S &&
        X.current.querySelectorAll("*").forEach((te) => {
          let ne = te
          ;(ne.scrollHeight > ne.clientHeight ||
            ne.scrollWidth > ne.clientWidth) &&
            ne.classList.add("vaul-scrollable")
        })
    }, [S])
  function jr(te) {
    let ne = document.querySelector("[vaul-drawer-wrapper]")
    !ne ||
      !r ||
      (te
        ? (Re(document.body, { background: "black" }, !0),
          Re(ne, {
            borderRadius: `${Lx}px`,
            overflow: "hidden",
            transform: `scale(${Ke()}) translate3d(0, calc(env(safe-area-inset-top) + 14px), 0)`,
            transformOrigin: "top",
            transitionProperty: "transform, border-radius",
            transitionDuration: `${we.DURATION}s`,
            transitionTimingFunction: `cubic-bezier(${we.EASE.join(",")})`
          }))
        : (Gu(ne, "overflow"),
          Gu(ne, "transform"),
          Gu(ne, "borderRadius"),
          Re(ne, {
            transitionProperty: "transform, border-radius",
            transitionDuration: `${we.DURATION}s`,
            transitionTimingFunction: `cubic-bezier(${we.EASE.join(",")})`
          })))
  }
  function hu(te) {
    let ne = te ? (window.innerWidth - Ti) / window.innerWidth : 1,
      Ne = te ? -Ti : 0
    V.current && window.clearTimeout(V.current),
      Re(X.current, {
        transition: `transform ${we.DURATION}s cubic-bezier(${we.EASE.join(
          ","
        )})`,
        transform: `scale(${ne}) translate3d(0, ${Ne}px, 0)`
      }),
      !te &&
        X.current &&
        (V.current = setTimeout(() => {
          Re(X.current, {
            transition: "none",
            transform: `translate3d(0, ${Ku(X.current)}px, 0)`
          })
        }, 500))
  }
  function mu(te, ne) {
    if (ne < 0) return
    let Ne = (window.innerWidth - Ti) / window.innerWidth,
      Je = Ne + ne * (1 - Ne),
      mt = -Ti + ne * Ti
    Re(X.current, {
      transform: `scale(${Je}) translate3d(0, ${mt}px, 0)`,
      transition: "none"
    })
  }
  function jM(te, ne) {
    let Ne = ne ? (window.innerWidth - Ti) / window.innerWidth : 1,
      Je = ne ? -Ti : 0
    ne &&
      Re(X.current, {
        transition: `transform ${we.DURATION}s cubic-bezier(${we.EASE.join(
          ","
        )})`,
        transform: `scale(${Ne}) translate3d(0, ${Je}px, 0)`
      })
  }
  return E.createElement(
    k5,
    {
      modal: m,
      onOpenChange: (te) => {
        if (e !== void 0) {
          t == null || t(te)
          return
        }
        te ? (x(!0), y(te)) : Ze()
      },
      open: v
    },
    E.createElement(
      HE.Provider,
      {
        value: {
          visible: S,
          activeSnapPoint: Qe,
          snapPoints: a,
          setActiveSnapPoint: Q,
          drawerRef: X,
          overlayRef: M,
          scaleBackground: jr,
          onOpenChange: t,
          onPress: It,
          setVisible: O,
          onRelease: co,
          onDrag: wn,
          dismissible: f,
          isOpen: v,
          shouldFade: ae,
          closeDrawer: Ze,
          onNestedDrag: mu,
          onNestedOpenChange: hu,
          onNestedRelease: jM,
          keyboardIsOpen: H,
          openProp: e,
          modal: m,
          snapPointsOffset: F
        }
      },
      n
    )
  )
}
var JE = E.forwardRef(function ({ children: e, ...t }, n) {
  let {
      overlayRef: r,
      snapPoints: i,
      onRelease: o,
      shouldFade: a,
      isOpen: s,
      visible: l
    } = Hy(),
    u = qE(n, r),
    f = i && i.length > 0
  return E.createElement(D5, {
    onMouseUp: o,
    ref: u,
    "vaul-drawer-visible": l ? "true" : "false",
    "vaul-overlay": "",
    "vaul-snap-points": s && f ? "true" : "false",
    "vaul-snap-points-overlay": s && a ? "true" : "false",
    ...t
  })
})
JE.displayName = "Drawer.Overlay"
var eC = E.forwardRef(function (
  {
    onOpenAutoFocus: e,
    onPointerDownOutside: t,
    onAnimationEnd: n,
    style: r,
    ...i
  },
  o
) {
  let {
      drawerRef: a,
      onPress: s,
      onRelease: l,
      onDrag: u,
      dismissible: f,
      keyboardIsOpen: c,
      snapPointsOffset: d,
      visible: p,
      closeDrawer: h,
      modal: m,
      openProp: b,
      onOpenChange: g,
      setVisible: v
    } = Hy(),
    y = qE(o, a)
  return (
    E.useEffect(() => {
      v(!0)
    }, []),
    E.createElement(I5, {
      onOpenAutoFocus: (w) => {
        e ? e(w) : (w.preventDefault(), a.current.focus())
      },
      onPointerDown: s,
      onPointerDownOutside: (w) => {
        if ((t == null || t(w), !m)) {
          w.preventDefault()
          return
        }
        c.current && (c.current = !1),
          w.preventDefault(),
          g == null || g(!1),
          !(!f || b !== void 0) && h()
      },
      onPointerMove: u,
      onPointerUp: l,
      ref: y,
      style:
        d && d.length > 0 ? { "--snap-point-height": `${d[0]}px`, ...r } : r,
      ...i,
      "vaul-drawer": "",
      "vaul-drawer-visible": p ? "true" : "false"
    })
  )
})
eC.displayName = "Drawer.Content"
function rB({ onDrag: e, onOpenChange: t, ...n }) {
  let { onNestedDrag: r, onNestedOpenChange: i, onNestedRelease: o } = Hy()
  if (!r) throw new Error("Drawer.NestedRoot must be placed in another drawer")
  return E.createElement(ZE, {
    nested: !0,
    onClose: () => {
      i(!1)
    },
    onDrag: (a, s) => {
      r(a, s), e == null || e(a, s)
    },
    onOpenChange: (a) => {
      a && i(a), t == null || t(a)
    },
    onRelease: o,
    ...n
  })
}
var Zn = {
  Root: ZE,
  NestedRoot: rB,
  Content: eC,
  Overlay: JE,
  Trigger: M5,
  Portal: j5,
  Close: L5,
  Title: N5,
  Description: R5
}
const tC = ({ shouldScaleBackground: e = !0, ...t }) =>
  j.jsx(Zn.Root, { shouldScaleBackground: e, ...t })
tC.displayName = "Drawer"
const iB = Zn.Trigger,
  oB = Zn.Portal,
  nC = P.forwardRef(({ className: e, ...t }, n) =>
    j.jsx(Zn.Overlay, {
      ref: n,
      className: ot("fixed inset-0 z-50 bg-black/80", e),
      ...t
    })
  )
nC.displayName = Zn.Overlay.displayName
const rC = P.forwardRef(({ className: e, children: t, ...n }, r) =>
  j.jsxs(oB, {
    children: [
      j.jsx(nC, {}),
      j.jsxs(Zn.Content, {
        ref: r,
        className: ot(
          "bg-background fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border",
          e
        ),
        ...n,
        children: [
          j.jsx("div", {
            className: "bg-muted mx-auto mt-4 h-2 w-[100px] rounded-full"
          }),
          t
        ]
      })
    ]
  })
)
rC.displayName = "DrawerContent"
const aB = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx(Zn.Title, {
    ref: n,
    className: ot("text-lg font-semibold leading-none tracking-tight", e),
    ...t
  })
)
aB.displayName = Zn.Title.displayName
const sB = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx(Zn.Description, {
    ref: n,
    className: ot("text-muted-foreground text-sm", e),
    ...t
  })
)
sB.displayName = Zn.Description.displayName
const lB = () => {
  const [e, t] = P.useState(!1)
  return j.jsxs("nav", {
    className:
      "fixed -top-0 z-[999] flex w-full items-center justify-between scroll-smooth p-2 backdrop-blur-md md:p-3 lg:p-4",
    children: [
      j.jsx(ir, {
        size: "sm",
        variant: "ghost",
        className: "hover:bg-transparent",
        onClick: () => window.scrollTo({ top: 0, behavior: "smooth" }),
        children: j.jsx("img", {
          src: "/icon.svg",
          alt: "icon",
          className: "h-5 w-5 md:h-6 md:w-6 lg:h-7 lg:w-7 "
        })
      }),
      j.jsxs("ul", {
        className:
          "hidden items-end gap-x-2 text-sm md:flex md:gap-x-4 lg:gap-x-5 ",
        children: [
          j.jsx(ir, {
            variant: "ghost",
            size: "sm",
            className: "text-muted-foreground",
            onClick: () => {
              var n
              return (n = document.getElementById("tools")) == null
                ? void 0
                : n.scrollIntoView({ block: "center" })
            },
            children: "Features"
          }),
          j.jsx(ir, {
            variant: "ghost",
            size: "sm",
            className: "text-muted-foreground",
            onClick: () => {
              var n
              return (n = document.getElementById("download")) == null
                ? void 0
                : n.scrollIntoView({ block: "center" })
            },
            children: "Download"
          }),
          j.jsx(ir, {
            variant: "ghost",
            size: "sm",
            className: "text-muted-foreground",
            children: "Pricing"
          })
        ]
      }),
      j.jsxs(tC, {
        open: e,
        onOpenChange: t,
        children: [
          j.jsx(iB, {
            asChild: !0,
            children: j.jsx(ir, {
              size: "sm",
              className: "px-2 py-1 md:hidden",
              variant: "ghost",
              children: j.jsx(a3, {
                className: "h-5 w-5 md:h-6 md:w-6 lg:h-7 lg:w-7 "
              })
            })
          }),
          j.jsx(rC, {
            className: "flex items-center justify-center ",
            children: j.jsxs("div", {
              className: "grid h-full w-full grid-cols-3 p-5",
              children: [
                j.jsx(ir, {
                  variant: "ghost",
                  size: "sm",
                  onClick: () => {
                    t(!1),
                      setTimeout(() => {
                        var n
                        ;(n = document.getElementById("tools")) == null ||
                          n.scrollIntoView({
                            block: "center",
                            inline: "center"
                          })
                      }, 500)
                  },
                  children: "Features"
                }),
                j.jsx(ir, {
                  variant: "ghost",
                  size: "sm",
                  onClick: () => {
                    t(!1),
                      setTimeout(() => {
                        var n
                        ;(n = document.getElementById("download")) == null ||
                          n.scrollIntoView({
                            block: "center",
                            inline: "center"
                          })
                      }, 500)
                  },
                  children: "Download"
                }),
                j.jsx("a", {
                  className: Cd({ size: "sm", variant: "ghost" }),
                  children: "Pricing"
                })
              ]
            })
          })
        ]
      })
    ]
  })
}
var uB = "@vercel/analytics",
  cB = "1.1.1",
  fB = () => {
    window.va ||
      (window.va = function (...t) {
        ;(window.vaq = window.vaq || []).push(t)
      })
  }
function iC() {
  return typeof window < "u"
}
function oC() {
  try {
    const e = "production"
  } catch {}
  return "production"
}
function dB(e = "auto") {
  if (e === "auto") {
    window.vam = oC()
    return
  }
  window.vam = e
}
function pB() {
  return (iC() ? window.vam : oC()) || "production"
}
function gh() {
  return pB() === "development"
}
function hB(e = { debug: !0 }) {
  var t
  if (!iC()) return
  dB(e.mode),
    fB(),
    e.beforeSend &&
      ((t = window.va) == null || t.call(window, "beforeSend", e.beforeSend))
  const n = gh()
    ? "https://va.vercel-scripts.com/v1/script.debug.js"
    : "/_vercel/insights/script.js"
  if (document.head.querySelector(`script[src*="${n}"]`)) return
  const r = document.createElement("script")
  ;(r.src = n),
    (r.defer = !0),
    r.setAttribute("data-sdkn", uB),
    r.setAttribute("data-sdkv", cB),
    (r.onerror = () => {
      const i = gh()
        ? "Please check if any ad blockers are enabled and try again."
        : "Be sure to enable Web Analytics for your project and deploy again. See https://vercel.com/docs/analytics/quickstart for more information."
      console.log(
        `[Vercel Web Analytics] Failed to load script from ${n}. ${i}`
      )
    }),
    gh() && e.debug === !1 && r.setAttribute("data-debug", "false"),
    document.head.appendChild(r)
}
function mB({ beforeSend: e, debug: t = !0, mode: n = "auto" }) {
  return (
    P.useEffect(() => {
      hB({ beforeSend: e, debug: t, mode: n })
    }, [e, t, n]),
    null
  )
}
var vB = "@vercel/speed-insights",
  gB = "1.0.2",
  yB = () => {
    window.si ||
      (window.si = function (...t) {
        ;(window.siq = window.siq || []).push(t)
      })
  }
function bB() {
  return typeof window < "u"
}
function xB() {
  try {
    const e = "production"
  } catch {}
  return "production"
}
function Vx() {
  return xB() === "development"
}
var aC = "https://va.vercel-scripts.com/v1/speed-insights",
  wB = `${aC}/script.js`,
  SB = `${aC}/script.debug.js`,
  OB = "/_vercel/speed-insights/script.js"
function PB(e) {
  var t
  if (!bB() || e.route === null) return null
  yB()
  const r = !!e.dsn ? wB : OB,
    i = e.scriptSrc || (Vx() ? SB : r)
  if (document.head.querySelector(`script[src*="${i}"]`)) return null
  e.beforeSend &&
    ((t = window.si) == null || t.call(window, "beforeSend", e.beforeSend))
  const o = document.createElement("script")
  return (
    (o.src = i),
    (o.defer = !0),
    (o.dataset.sdkn = vB + (e.framework ? `/${e.framework}` : "")),
    (o.dataset.sdkv = gB),
    e.sampleRate && (o.dataset.sampleRate = e.sampleRate.toString()),
    e.route && (o.dataset.route = e.route),
    e.endpoint && (o.dataset.endpoint = e.endpoint),
    e.dsn && (o.dataset.dsn = e.dsn),
    Vx() && e.debug === !1 && (o.dataset.debug = "false"),
    (o.onerror = () => {
      console.log(
        `[Vercel Speed Insights] Failed to load script from ${i}. Please check if any content blockers are enabled and try again.`
      )
    }),
    document.head.appendChild(o),
    {
      setRoute: (a) => {
        o.dataset.route = a ?? void 0
      }
    }
  )
}
function $B(e) {
  const t = P.useRef(null)
  return (
    P.useEffect(() => {
      if (t.current) e.route && t.current(e.route)
      else {
        const n = PB({ framework: e.framework || "react", ...e })
        n && (t.current = n.setRoute)
      }
    }, [e.route]),
    null
  )
}
const AB = { theme: "system", setTheme: () => null },
  TB = P.createContext(AB)
function EB({
  children: e,
  defaultTheme: t = "system",
  storageKey: n = "vite-ui-theme",
  ...r
}) {
  const [i, o] = P.useState(() => localStorage.getItem(n) || t)
  P.useEffect(() => {
    const s = window.document.documentElement
    if ((s.classList.remove("light", "dark"), i === "system")) {
      const l = window.matchMedia("(prefers-color-scheme: dark)").matches
        ? "dark"
        : "light"
      s.classList.add(l)
      return
    }
    s.classList.add(i)
  }, [i])
  const a = {
    theme: i,
    setTheme: (s) => {
      localStorage.setItem(n, s), o(s)
    }
  }
  return j.jsx(TB.Provider, { ...r, value: a, children: e })
}
var CB = Array.isArray,
  Ut = CB,
  _B = typeof gu == "object" && gu && gu.Object === Object && gu,
  sC = _B,
  kB = sC,
  MB = typeof self == "object" && self && self.Object === Object && self,
  jB = kB || MB || Function("return this")(),
  Jn = jB,
  DB = Jn,
  IB = DB.Symbol,
  ru = IB,
  zx = ru,
  lC = Object.prototype,
  NB = lC.hasOwnProperty,
  RB = lC.toString,
  rs = zx ? zx.toStringTag : void 0
function LB(e) {
  var t = NB.call(e, rs),
    n = e[rs]
  try {
    e[rs] = void 0
    var r = !0
  } catch {}
  var i = RB.call(e)
  return r && (t ? (e[rs] = n) : delete e[rs]), i
}
var BB = LB,
  FB = Object.prototype,
  VB = FB.toString
function zB(e) {
  return VB.call(e)
}
var UB = zB,
  Ux = ru,
  WB = BB,
  HB = UB,
  GB = "[object Null]",
  KB = "[object Undefined]",
  Wx = Ux ? Ux.toStringTag : void 0
function qB(e) {
  return e == null
    ? e === void 0
      ? KB
      : GB
    : Wx && Wx in Object(e)
      ? WB(e)
      : HB(e)
}
var Cr = qB
function XB(e) {
  return e != null && typeof e == "object"
}
var _r = XB,
  YB = Cr,
  QB = _r,
  ZB = "[object Symbol]"
function JB(e) {
  return typeof e == "symbol" || (QB(e) && YB(e) == ZB)
}
var Ca = JB,
  eF = Ut,
  tF = Ca,
  nF = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  rF = /^\w*$/
function iF(e, t) {
  if (eF(e)) return !1
  var n = typeof e
  return n == "number" || n == "symbol" || n == "boolean" || e == null || tF(e)
    ? !0
    : rF.test(e) || !nF.test(e) || (t != null && e in Object(t))
}
var Ky = iF
function oF(e) {
  var t = typeof e
  return e != null && (t == "object" || t == "function")
}
var wi = oF
const _a = Pe(wi)
var aF = Cr,
  sF = wi,
  lF = "[object AsyncFunction]",
  uF = "[object Function]",
  cF = "[object GeneratorFunction]",
  fF = "[object Proxy]"
function dF(e) {
  if (!sF(e)) return !1
  var t = aF(e)
  return t == uF || t == cF || t == lF || t == fF
}
var qy = dF
const ce = Pe(qy)
var pF = Jn,
  hF = pF["__core-js_shared__"],
  mF = hF,
  yh = mF,
  Hx = (function () {
    var e = /[^.]+$/.exec((yh && yh.keys && yh.keys.IE_PROTO) || "")
    return e ? "Symbol(src)_1." + e : ""
  })()
function vF(e) {
  return !!Hx && Hx in e
}
var gF = vF,
  yF = Function.prototype,
  bF = yF.toString
function xF(e) {
  if (e != null) {
    try {
      return bF.call(e)
    } catch {}
    try {
      return e + ""
    } catch {}
  }
  return ""
}
var uC = xF,
  wF = qy,
  SF = gF,
  OF = wi,
  PF = uC,
  $F = /[\\^$.*+?()[\]{}|]/g,
  AF = /^\[object .+?Constructor\]$/,
  TF = Function.prototype,
  EF = Object.prototype,
  CF = TF.toString,
  _F = EF.hasOwnProperty,
  kF = RegExp(
    "^" +
      CF.call(_F)
        .replace($F, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?"
        ) +
      "$"
  )
function MF(e) {
  if (!OF(e) || SF(e)) return !1
  var t = wF(e) ? kF : AF
  return t.test(PF(e))
}
var jF = MF
function DF(e, t) {
  return e == null ? void 0 : e[t]
}
var IF = DF,
  NF = jF,
  RF = IF
function LF(e, t) {
  var n = RF(e, t)
  return NF(n) ? n : void 0
}
var so = LF,
  BF = so,
  FF = BF(Object, "create"),
  Md = FF,
  Gx = Md
function VF() {
  ;(this.__data__ = Gx ? Gx(null) : {}), (this.size = 0)
}
var zF = VF
function UF(e) {
  var t = this.has(e) && delete this.__data__[e]
  return (this.size -= t ? 1 : 0), t
}
var WF = UF,
  HF = Md,
  GF = "__lodash_hash_undefined__",
  KF = Object.prototype,
  qF = KF.hasOwnProperty
function XF(e) {
  var t = this.__data__
  if (HF) {
    var n = t[e]
    return n === GF ? void 0 : n
  }
  return qF.call(t, e) ? t[e] : void 0
}
var YF = XF,
  QF = Md,
  ZF = Object.prototype,
  JF = ZF.hasOwnProperty
function e4(e) {
  var t = this.__data__
  return QF ? t[e] !== void 0 : JF.call(t, e)
}
var t4 = e4,
  n4 = Md,
  r4 = "__lodash_hash_undefined__"
function i4(e, t) {
  var n = this.__data__
  return (
    (this.size += this.has(e) ? 0 : 1),
    (n[e] = n4 && t === void 0 ? r4 : t),
    this
  )
}
var o4 = i4,
  a4 = zF,
  s4 = WF,
  l4 = YF,
  u4 = t4,
  c4 = o4
function ka(e) {
  var t = -1,
    n = e == null ? 0 : e.length
  for (this.clear(); ++t < n; ) {
    var r = e[t]
    this.set(r[0], r[1])
  }
}
ka.prototype.clear = a4
ka.prototype.delete = s4
ka.prototype.get = l4
ka.prototype.has = u4
ka.prototype.set = c4
var f4 = ka
function d4() {
  ;(this.__data__ = []), (this.size = 0)
}
var p4 = d4
function h4(e, t) {
  return e === t || (e !== e && t !== t)
}
var Xy = h4,
  m4 = Xy
function v4(e, t) {
  for (var n = e.length; n--; ) if (m4(e[n][0], t)) return n
  return -1
}
var jd = v4,
  g4 = jd,
  y4 = Array.prototype,
  b4 = y4.splice
function x4(e) {
  var t = this.__data__,
    n = g4(t, e)
  if (n < 0) return !1
  var r = t.length - 1
  return n == r ? t.pop() : b4.call(t, n, 1), --this.size, !0
}
var w4 = x4,
  S4 = jd
function O4(e) {
  var t = this.__data__,
    n = S4(t, e)
  return n < 0 ? void 0 : t[n][1]
}
var P4 = O4,
  $4 = jd
function A4(e) {
  return $4(this.__data__, e) > -1
}
var T4 = A4,
  E4 = jd
function C4(e, t) {
  var n = this.__data__,
    r = E4(n, e)
  return r < 0 ? (++this.size, n.push([e, t])) : (n[r][1] = t), this
}
var _4 = C4,
  k4 = p4,
  M4 = w4,
  j4 = P4,
  D4 = T4,
  I4 = _4
function Ma(e) {
  var t = -1,
    n = e == null ? 0 : e.length
  for (this.clear(); ++t < n; ) {
    var r = e[t]
    this.set(r[0], r[1])
  }
}
Ma.prototype.clear = k4
Ma.prototype.delete = M4
Ma.prototype.get = j4
Ma.prototype.has = D4
Ma.prototype.set = I4
var Dd = Ma,
  N4 = so,
  R4 = Jn,
  L4 = N4(R4, "Map"),
  Yy = L4,
  Kx = f4,
  B4 = Dd,
  F4 = Yy
function V4() {
  ;(this.size = 0),
    (this.__data__ = {
      hash: new Kx(),
      map: new (F4 || B4)(),
      string: new Kx()
    })
}
var z4 = V4
function U4(e) {
  var t = typeof e
  return t == "string" || t == "number" || t == "symbol" || t == "boolean"
    ? e !== "__proto__"
    : e === null
}
var W4 = U4,
  H4 = W4
function G4(e, t) {
  var n = e.__data__
  return H4(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map
}
var Id = G4,
  K4 = Id
function q4(e) {
  var t = K4(this, e).delete(e)
  return (this.size -= t ? 1 : 0), t
}
var X4 = q4,
  Y4 = Id
function Q4(e) {
  return Y4(this, e).get(e)
}
var Z4 = Q4,
  J4 = Id
function e6(e) {
  return J4(this, e).has(e)
}
var t6 = e6,
  n6 = Id
function r6(e, t) {
  var n = n6(this, e),
    r = n.size
  return n.set(e, t), (this.size += n.size == r ? 0 : 1), this
}
var i6 = r6,
  o6 = z4,
  a6 = X4,
  s6 = Z4,
  l6 = t6,
  u6 = i6
function ja(e) {
  var t = -1,
    n = e == null ? 0 : e.length
  for (this.clear(); ++t < n; ) {
    var r = e[t]
    this.set(r[0], r[1])
  }
}
ja.prototype.clear = o6
ja.prototype.delete = a6
ja.prototype.get = s6
ja.prototype.has = l6
ja.prototype.set = u6
var Qy = ja,
  cC = Qy,
  c6 = "Expected a function"
function Zy(e, t) {
  if (typeof e != "function" || (t != null && typeof t != "function"))
    throw new TypeError(c6)
  var n = function () {
    var r = arguments,
      i = t ? t.apply(this, r) : r[0],
      o = n.cache
    if (o.has(i)) return o.get(i)
    var a = e.apply(this, r)
    return (n.cache = o.set(i, a) || o), a
  }
  return (n.cache = new (Zy.Cache || cC)()), n
}
Zy.Cache = cC
var f6 = Zy,
  d6 = f6,
  p6 = 500
function h6(e) {
  var t = d6(e, function (r) {
      return n.size === p6 && n.clear(), r
    }),
    n = t.cache
  return t
}
var m6 = h6,
  v6 = m6,
  g6 =
    /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
  y6 = /\\(\\)?/g,
  b6 = v6(function (e) {
    var t = []
    return (
      e.charCodeAt(0) === 46 && t.push(""),
      e.replace(g6, function (n, r, i, o) {
        t.push(i ? o.replace(y6, "$1") : r || n)
      }),
      t
    )
  }),
  x6 = b6
function w6(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e)
  return i
}
var Jy = w6,
  qx = ru,
  S6 = Jy,
  O6 = Ut,
  P6 = Ca,
  $6 = 1 / 0,
  Xx = qx ? qx.prototype : void 0,
  Yx = Xx ? Xx.toString : void 0
function fC(e) {
  if (typeof e == "string") return e
  if (O6(e)) return S6(e, fC) + ""
  if (P6(e)) return Yx ? Yx.call(e) : ""
  var t = e + ""
  return t == "0" && 1 / e == -$6 ? "-0" : t
}
var A6 = fC,
  T6 = A6
function E6(e) {
  return e == null ? "" : T6(e)
}
var dC = E6,
  C6 = Ut,
  _6 = Ky,
  k6 = x6,
  M6 = dC
function j6(e, t) {
  return C6(e) ? e : _6(e, t) ? [e] : k6(M6(e))
}
var pC = j6,
  D6 = Ca,
  I6 = 1 / 0
function N6(e) {
  if (typeof e == "string" || D6(e)) return e
  var t = e + ""
  return t == "0" && 1 / e == -I6 ? "-0" : t
}
var Nd = N6,
  R6 = pC,
  L6 = Nd
function B6(e, t) {
  t = R6(t, e)
  for (var n = 0, r = t.length; e != null && n < r; ) e = e[L6(t[n++])]
  return n && n == r ? e : void 0
}
var e0 = B6,
  F6 = e0
function V6(e, t, n) {
  var r = e == null ? void 0 : F6(e, t)
  return r === void 0 ? n : r
}
var hC = V6
const mn = Pe(hC)
function z6(e) {
  return e == null
}
var U6 = z6
const xe = Pe(U6)
var W6 = Cr,
  H6 = Ut,
  G6 = _r,
  K6 = "[object String]"
function q6(e) {
  return typeof e == "string" || (!H6(e) && G6(e) && W6(e) == K6)
}
var X6 = q6
const iu = Pe(X6)
var mC = { exports: {} },
  ye = {}
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var pt = typeof Symbol == "function" && Symbol.for,
  t0 = pt ? Symbol.for("react.element") : 60103,
  n0 = pt ? Symbol.for("react.portal") : 60106,
  Rd = pt ? Symbol.for("react.fragment") : 60107,
  Ld = pt ? Symbol.for("react.strict_mode") : 60108,
  Bd = pt ? Symbol.for("react.profiler") : 60114,
  Fd = pt ? Symbol.for("react.provider") : 60109,
  Vd = pt ? Symbol.for("react.context") : 60110,
  r0 = pt ? Symbol.for("react.async_mode") : 60111,
  zd = pt ? Symbol.for("react.concurrent_mode") : 60111,
  Ud = pt ? Symbol.for("react.forward_ref") : 60112,
  Wd = pt ? Symbol.for("react.suspense") : 60113,
  Y6 = pt ? Symbol.for("react.suspense_list") : 60120,
  Hd = pt ? Symbol.for("react.memo") : 60115,
  Gd = pt ? Symbol.for("react.lazy") : 60116,
  Q6 = pt ? Symbol.for("react.block") : 60121,
  Z6 = pt ? Symbol.for("react.fundamental") : 60117,
  J6 = pt ? Symbol.for("react.responder") : 60118,
  e8 = pt ? Symbol.for("react.scope") : 60119
function nn(e) {
  if (typeof e == "object" && e !== null) {
    var t = e.$$typeof
    switch (t) {
      case t0:
        switch (((e = e.type), e)) {
          case r0:
          case zd:
          case Rd:
          case Bd:
          case Ld:
          case Wd:
            return e
          default:
            switch (((e = e && e.$$typeof), e)) {
              case Vd:
              case Ud:
              case Gd:
              case Hd:
              case Fd:
                return e
              default:
                return t
            }
        }
      case n0:
        return t
    }
  }
}
function vC(e) {
  return nn(e) === zd
}
ye.AsyncMode = r0
ye.ConcurrentMode = zd
ye.ContextConsumer = Vd
ye.ContextProvider = Fd
ye.Element = t0
ye.ForwardRef = Ud
ye.Fragment = Rd
ye.Lazy = Gd
ye.Memo = Hd
ye.Portal = n0
ye.Profiler = Bd
ye.StrictMode = Ld
ye.Suspense = Wd
ye.isAsyncMode = function (e) {
  return vC(e) || nn(e) === r0
}
ye.isConcurrentMode = vC
ye.isContextConsumer = function (e) {
  return nn(e) === Vd
}
ye.isContextProvider = function (e) {
  return nn(e) === Fd
}
ye.isElement = function (e) {
  return typeof e == "object" && e !== null && e.$$typeof === t0
}
ye.isForwardRef = function (e) {
  return nn(e) === Ud
}
ye.isFragment = function (e) {
  return nn(e) === Rd
}
ye.isLazy = function (e) {
  return nn(e) === Gd
}
ye.isMemo = function (e) {
  return nn(e) === Hd
}
ye.isPortal = function (e) {
  return nn(e) === n0
}
ye.isProfiler = function (e) {
  return nn(e) === Bd
}
ye.isStrictMode = function (e) {
  return nn(e) === Ld
}
ye.isSuspense = function (e) {
  return nn(e) === Wd
}
ye.isValidElementType = function (e) {
  return (
    typeof e == "string" ||
    typeof e == "function" ||
    e === Rd ||
    e === zd ||
    e === Bd ||
    e === Ld ||
    e === Wd ||
    e === Y6 ||
    (typeof e == "object" &&
      e !== null &&
      (e.$$typeof === Gd ||
        e.$$typeof === Hd ||
        e.$$typeof === Fd ||
        e.$$typeof === Vd ||
        e.$$typeof === Ud ||
        e.$$typeof === Z6 ||
        e.$$typeof === J6 ||
        e.$$typeof === e8 ||
        e.$$typeof === Q6))
  )
}
ye.typeOf = nn
mC.exports = ye
var t8 = mC.exports,
  n8 = Cr,
  r8 = _r,
  i8 = "[object Number]"
function o8(e) {
  return typeof e == "number" || (r8(e) && n8(e) == i8)
}
var gC = o8
const a8 = Pe(gC)
var s8 = gC
function l8(e) {
  return s8(e) && e != +e
}
var u8 = l8
const ou = Pe(u8)
var _n = function (t) {
    return t === 0 ? 0 : t > 0 ? 1 : -1
  },
  uv = function (t) {
    return iu(t) && t.indexOf("%") === t.length - 1
  },
  G = function (t) {
    return a8(t) && !ou(t)
  },
  it = function (t) {
    return G(t) || iu(t)
  },
  c8 = 0,
  Kd = function (t) {
    var n = ++c8
    return "".concat(t || "").concat(n)
  },
  aa = function (t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
      i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1
    if (!G(t) && !iu(t)) return r
    var o
    if (uv(t)) {
      var a = t.indexOf("%")
      o = (n * parseFloat(t.slice(0, a))) / 100
    } else o = +t
    return ou(o) && (o = r), i && o > n && (o = n), o
  },
  Fr = function (t) {
    if (!t) return null
    var n = Object.keys(t)
    return n && n.length ? t[n[0]] : null
  },
  f8 = function (t) {
    if (!Array.isArray(t)) return !1
    for (var n = t.length, r = {}, i = 0; i < n; i++)
      if (!r[t[i]]) r[t[i]] = !0
      else return !0
    return !1
  },
  vo = function (t, n) {
    return G(t) && G(n)
      ? function (r) {
          return t + r * (n - t)
        }
      : function () {
          return n
        }
  }
function cv(e, t, n) {
  return !e || !e.length
    ? null
    : e.find(function (r) {
        return r && (typeof t == "function" ? t(r) : mn(r, t)) === n
      })
}
function Ho(e, t) {
  for (var n in e)
    if (
      {}.hasOwnProperty.call(e, n) &&
      (!{}.hasOwnProperty.call(t, n) || e[n] !== t[n])
    )
      return !1
  for (var r in t)
    if ({}.hasOwnProperty.call(t, r) && !{}.hasOwnProperty.call(e, r)) return !1
  return !0
}
function fv(e) {
  "@babel/helpers - typeof"
  return (
    (fv =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    fv(e)
  )
}
var d8 = ["viewBox", "children"],
  p8 = [
    "aria-activedescendant",
    "aria-atomic",
    "aria-autocomplete",
    "aria-busy",
    "aria-checked",
    "aria-colcount",
    "aria-colindex",
    "aria-colspan",
    "aria-controls",
    "aria-current",
    "aria-describedby",
    "aria-details",
    "aria-disabled",
    "aria-errormessage",
    "aria-expanded",
    "aria-flowto",
    "aria-haspopup",
    "aria-hidden",
    "aria-invalid",
    "aria-keyshortcuts",
    "aria-label",
    "aria-labelledby",
    "aria-level",
    "aria-live",
    "aria-modal",
    "aria-multiline",
    "aria-multiselectable",
    "aria-orientation",
    "aria-owns",
    "aria-placeholder",
    "aria-posinset",
    "aria-pressed",
    "aria-readonly",
    "aria-relevant",
    "aria-required",
    "aria-roledescription",
    "aria-rowcount",
    "aria-rowindex",
    "aria-rowspan",
    "aria-selected",
    "aria-setsize",
    "aria-sort",
    "aria-valuemax",
    "aria-valuemin",
    "aria-valuenow",
    "aria-valuetext",
    "className",
    "color",
    "height",
    "id",
    "lang",
    "max",
    "media",
    "method",
    "min",
    "name",
    "style",
    "target",
    "width",
    "role",
    "tabIndex",
    "accentHeight",
    "accumulate",
    "additive",
    "alignmentBaseline",
    "allowReorder",
    "alphabetic",
    "amplitude",
    "arabicForm",
    "ascent",
    "attributeName",
    "attributeType",
    "autoReverse",
    "azimuth",
    "baseFrequency",
    "baselineShift",
    "baseProfile",
    "bbox",
    "begin",
    "bias",
    "by",
    "calcMode",
    "capHeight",
    "clip",
    "clipPath",
    "clipPathUnits",
    "clipRule",
    "colorInterpolation",
    "colorInterpolationFilters",
    "colorProfile",
    "colorRendering",
    "contentScriptType",
    "contentStyleType",
    "cursor",
    "cx",
    "cy",
    "d",
    "decelerate",
    "descent",
    "diffuseConstant",
    "direction",
    "display",
    "divisor",
    "dominantBaseline",
    "dur",
    "dx",
    "dy",
    "edgeMode",
    "elevation",
    "enableBackground",
    "end",
    "exponent",
    "externalResourcesRequired",
    "fill",
    "fillOpacity",
    "fillRule",
    "filter",
    "filterRes",
    "filterUnits",
    "floodColor",
    "floodOpacity",
    "focusable",
    "fontFamily",
    "fontSize",
    "fontSizeAdjust",
    "fontStretch",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "format",
    "from",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyphName",
    "glyphOrientationHorizontal",
    "glyphOrientationVertical",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "hanging",
    "horizAdvX",
    "horizOriginX",
    "href",
    "ideographic",
    "imageRendering",
    "in2",
    "in",
    "intercept",
    "k1",
    "k2",
    "k3",
    "k4",
    "k",
    "kernelMatrix",
    "kernelUnitLength",
    "kerning",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "letterSpacing",
    "lightingColor",
    "limitingConeAngle",
    "local",
    "markerEnd",
    "markerHeight",
    "markerMid",
    "markerStart",
    "markerUnits",
    "markerWidth",
    "mask",
    "maskContentUnits",
    "maskUnits",
    "mathematical",
    "mode",
    "numOctaves",
    "offset",
    "opacity",
    "operator",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "overlinePosition",
    "overlineThickness",
    "paintOrder",
    "panose1",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointerEvents",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "r",
    "radius",
    "refX",
    "refY",
    "renderingIntent",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "restart",
    "result",
    "rotate",
    "rx",
    "ry",
    "seed",
    "shapeRendering",
    "slope",
    "spacing",
    "specularConstant",
    "specularExponent",
    "speed",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stemh",
    "stemv",
    "stitchTiles",
    "stopColor",
    "stopOpacity",
    "strikethroughPosition",
    "strikethroughThickness",
    "string",
    "stroke",
    "strokeDasharray",
    "strokeDashoffset",
    "strokeLinecap",
    "strokeLinejoin",
    "strokeMiterlimit",
    "strokeOpacity",
    "strokeWidth",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textAnchor",
    "textDecoration",
    "textLength",
    "textRendering",
    "to",
    "transform",
    "u1",
    "u2",
    "underlinePosition",
    "underlineThickness",
    "unicode",
    "unicodeBidi",
    "unicodeRange",
    "unitsPerEm",
    "vAlphabetic",
    "values",
    "vectorEffect",
    "version",
    "vertAdvY",
    "vertOriginX",
    "vertOriginY",
    "vHanging",
    "vIdeographic",
    "viewTarget",
    "visibility",
    "vMathematical",
    "widths",
    "wordSpacing",
    "writingMode",
    "x1",
    "x2",
    "x",
    "xChannelSelector",
    "xHeight",
    "xlinkActuate",
    "xlinkArcrole",
    "xlinkHref",
    "xlinkRole",
    "xlinkShow",
    "xlinkTitle",
    "xlinkType",
    "xmlBase",
    "xmlLang",
    "xmlns",
    "xmlnsXlink",
    "xmlSpace",
    "y1",
    "y2",
    "y",
    "yChannelSelector",
    "z",
    "zoomAndPan",
    "ref",
    "key",
    "angle"
  ],
  Qx = ["points", "pathLength"],
  bh = { svg: d8, polygon: Qx, polyline: Qx },
  i0 = [
    "dangerouslySetInnerHTML",
    "onCopy",
    "onCopyCapture",
    "onCut",
    "onCutCapture",
    "onPaste",
    "onPasteCapture",
    "onCompositionEnd",
    "onCompositionEndCapture",
    "onCompositionStart",
    "onCompositionStartCapture",
    "onCompositionUpdate",
    "onCompositionUpdateCapture",
    "onFocus",
    "onFocusCapture",
    "onBlur",
    "onBlurCapture",
    "onChange",
    "onChangeCapture",
    "onBeforeInput",
    "onBeforeInputCapture",
    "onInput",
    "onInputCapture",
    "onReset",
    "onResetCapture",
    "onSubmit",
    "onSubmitCapture",
    "onInvalid",
    "onInvalidCapture",
    "onLoad",
    "onLoadCapture",
    "onError",
    "onErrorCapture",
    "onKeyDown",
    "onKeyDownCapture",
    "onKeyPress",
    "onKeyPressCapture",
    "onKeyUp",
    "onKeyUpCapture",
    "onAbort",
    "onAbortCapture",
    "onCanPlay",
    "onCanPlayCapture",
    "onCanPlayThrough",
    "onCanPlayThroughCapture",
    "onDurationChange",
    "onDurationChangeCapture",
    "onEmptied",
    "onEmptiedCapture",
    "onEncrypted",
    "onEncryptedCapture",
    "onEnded",
    "onEndedCapture",
    "onLoadedData",
    "onLoadedDataCapture",
    "onLoadedMetadata",
    "onLoadedMetadataCapture",
    "onLoadStart",
    "onLoadStartCapture",
    "onPause",
    "onPauseCapture",
    "onPlay",
    "onPlayCapture",
    "onPlaying",
    "onPlayingCapture",
    "onProgress",
    "onProgressCapture",
    "onRateChange",
    "onRateChangeCapture",
    "onSeeked",
    "onSeekedCapture",
    "onSeeking",
    "onSeekingCapture",
    "onStalled",
    "onStalledCapture",
    "onSuspend",
    "onSuspendCapture",
    "onTimeUpdate",
    "onTimeUpdateCapture",
    "onVolumeChange",
    "onVolumeChangeCapture",
    "onWaiting",
    "onWaitingCapture",
    "onAuxClick",
    "onAuxClickCapture",
    "onClick",
    "onClickCapture",
    "onContextMenu",
    "onContextMenuCapture",
    "onDoubleClick",
    "onDoubleClickCapture",
    "onDrag",
    "onDragCapture",
    "onDragEnd",
    "onDragEndCapture",
    "onDragEnter",
    "onDragEnterCapture",
    "onDragExit",
    "onDragExitCapture",
    "onDragLeave",
    "onDragLeaveCapture",
    "onDragOver",
    "onDragOverCapture",
    "onDragStart",
    "onDragStartCapture",
    "onDrop",
    "onDropCapture",
    "onMouseDown",
    "onMouseDownCapture",
    "onMouseEnter",
    "onMouseLeave",
    "onMouseMove",
    "onMouseMoveCapture",
    "onMouseOut",
    "onMouseOutCapture",
    "onMouseOver",
    "onMouseOverCapture",
    "onMouseUp",
    "onMouseUpCapture",
    "onSelect",
    "onSelectCapture",
    "onTouchCancel",
    "onTouchCancelCapture",
    "onTouchEnd",
    "onTouchEndCapture",
    "onTouchMove",
    "onTouchMoveCapture",
    "onTouchStart",
    "onTouchStartCapture",
    "onPointerDown",
    "onPointerDownCapture",
    "onPointerMove",
    "onPointerMoveCapture",
    "onPointerUp",
    "onPointerUpCapture",
    "onPointerCancel",
    "onPointerCancelCapture",
    "onPointerEnter",
    "onPointerEnterCapture",
    "onPointerLeave",
    "onPointerLeaveCapture",
    "onPointerOver",
    "onPointerOverCapture",
    "onPointerOut",
    "onPointerOutCapture",
    "onGotPointerCapture",
    "onGotPointerCaptureCapture",
    "onLostPointerCapture",
    "onLostPointerCaptureCapture",
    "onScroll",
    "onScrollCapture",
    "onWheel",
    "onWheelCapture",
    "onAnimationStart",
    "onAnimationStartCapture",
    "onAnimationEnd",
    "onAnimationEndCapture",
    "onAnimationIteration",
    "onAnimationIterationCapture",
    "onTransitionEnd",
    "onTransitionEndCapture"
  ],
  cf = function (t, n) {
    if (!t || typeof t == "function" || typeof t == "boolean") return null
    var r = t
    if ((P.isValidElement(t) && (r = t.props), !_a(r))) return null
    var i = {}
    return (
      Object.keys(r).forEach(function (o) {
        i0.includes(o) &&
          (i[o] =
            n ||
            function (a) {
              return r[o](r, a)
            })
      }),
      i
    )
  },
  h8 = function (t, n, r) {
    return function (i) {
      return t(n, r, i), null
    }
  },
  ff = function (t, n, r) {
    if (!_a(t) || fv(t) !== "object") return null
    var i = null
    return (
      Object.keys(t).forEach(function (o) {
        var a = t[o]
        i0.includes(o) &&
          typeof a == "function" &&
          (i || (i = {}), (i[o] = h8(a, n, r)))
      }),
      i
    )
  },
  m8 = ["children"],
  v8 = ["children"]
function Zx(e, t) {
  if (e == null) return {}
  var n = g8(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function g8(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
var Jx = {
    click: "onClick",
    mousedown: "onMouseDown",
    mouseup: "onMouseUp",
    mouseover: "onMouseOver",
    mousemove: "onMouseMove",
    mouseout: "onMouseOut",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    touchcancel: "onTouchCancel",
    touchend: "onTouchEnd",
    touchmove: "onTouchMove",
    touchstart: "onTouchStart"
  },
  ai = function (t) {
    return typeof t == "string"
      ? t
      : t
        ? t.displayName || t.name || "Component"
        : ""
  },
  ew = null,
  xh = null,
  o0 = function e(t) {
    if (t === ew && Array.isArray(xh)) return xh
    var n = []
    return (
      P.Children.forEach(t, function (r) {
        xe(r) ||
          (t8.isFragment(r) ? (n = n.concat(e(r.props.children))) : n.push(r))
      }),
      (xh = n),
      (ew = t),
      n
    )
  }
function jn(e, t) {
  var n = [],
    r = []
  return (
    Array.isArray(t)
      ? (r = t.map(function (i) {
          return ai(i)
        }))
      : (r = [ai(t)]),
    o0(e).forEach(function (i) {
      var o = mn(i, "type.displayName") || mn(i, "type.name")
      r.indexOf(o) !== -1 && n.push(i)
    }),
    n
  )
}
function ur(e, t) {
  var n = jn(e, t)
  return n && n[0]
}
var tw = function (t) {
    if (!t || !t.props) return !1
    var n = t.props,
      r = n.width,
      i = n.height
    return !(!G(r) || r <= 0 || !G(i) || i <= 0)
  },
  y8 = [
    "a",
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animate",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "circle",
    "clipPath",
    "color-profile",
    "cursor",
    "defs",
    "desc",
    "ellipse",
    "feBlend",
    "feColormatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "filter",
    "font",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-url",
    "foreignObject",
    "g",
    "glyph",
    "glyphRef",
    "hkern",
    "image",
    "line",
    "lineGradient",
    "marker",
    "mask",
    "metadata",
    "missing-glyph",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "script",
    "set",
    "stop",
    "style",
    "svg",
    "switch",
    "symbol",
    "text",
    "textPath",
    "title",
    "tref",
    "tspan",
    "use",
    "view",
    "vkern"
  ],
  b8 = function (t) {
    return t && t.type && iu(t.type) && y8.indexOf(t.type) >= 0
  },
  x8 = function (t, n, r, i) {
    var o,
      a = (o = bh == null ? void 0 : bh[i]) !== null && o !== void 0 ? o : []
    return (
      (!ce(t) && ((i && a.includes(n)) || p8.includes(n))) ||
      (r && i0.includes(n))
    )
  },
  he = function (t, n, r) {
    if (!t || typeof t == "function" || typeof t == "boolean") return null
    var i = t
    if ((P.isValidElement(t) && (i = t.props), !_a(i))) return null
    var o = {}
    return (
      Object.keys(i).forEach(function (a) {
        var s
        x8((s = i) === null || s === void 0 ? void 0 : s[a], a, n, r) &&
          (o[a] = i[a])
      }),
      o
    )
  },
  yC = function e(t, n) {
    if (t === n) return !0
    var r = P.Children.count(t)
    if (r !== P.Children.count(n)) return !1
    if (r === 0) return !0
    if (r === 1)
      return nw(Array.isArray(t) ? t[0] : t, Array.isArray(n) ? n[0] : n)
    for (var i = 0; i < r; i++) {
      var o = t[i],
        a = n[i]
      if (Array.isArray(o) || Array.isArray(a)) {
        if (!e(o, a)) return !1
      } else if (!nw(o, a)) return !1
    }
    return !0
  },
  nw = function (t, n) {
    if (xe(t) && xe(n)) return !0
    if (!xe(t) && !xe(n)) {
      var r = t.props || {},
        i = r.children,
        o = Zx(r, m8),
        a = n.props || {},
        s = a.children,
        l = Zx(a, v8)
      return i && s ? Ho(o, l) && yC(i, s) : !i && !s ? Ho(o, l) : !1
    }
    return !1
  },
  rw = function (t, n) {
    var r = [],
      i = {}
    return (
      o0(t).forEach(function (o, a) {
        if (b8(o)) r.push(o)
        else if (o) {
          var s = ai(o.type),
            l = n[s] || {},
            u = l.handler,
            f = l.once
          if (u && (!f || !i[s])) {
            var c = u(o, s, a)
            r.push(c), (i[s] = !0)
          }
        }
      }),
      r
    )
  },
  w8 = function (t) {
    var n = t && t.type
    return n && Jx[n] ? Jx[n] : null
  },
  S8 = function (t, n) {
    return o0(n).indexOf(t)
  },
  O8 = [
    "children",
    "width",
    "height",
    "viewBox",
    "className",
    "style",
    "title",
    "desc"
  ]
function dv() {
  return (
    (dv = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    dv.apply(this, arguments)
  )
}
function P8(e, t) {
  if (e == null) return {}
  var n = $8(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function $8(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function pv(e) {
  var t = e.children,
    n = e.width,
    r = e.height,
    i = e.viewBox,
    o = e.className,
    a = e.style,
    s = e.title,
    l = e.desc,
    u = P8(e, O8),
    f = i || { width: n, height: r, x: 0, y: 0 },
    c = Oe("recharts-surface", o)
  return E.createElement(
    "svg",
    dv({}, he(u, !0, "svg"), {
      className: c,
      width: n,
      height: r,
      style: a,
      viewBox: ""
        .concat(f.x, " ")
        .concat(f.y, " ")
        .concat(f.width, " ")
        .concat(f.height)
    }),
    E.createElement("title", null, s),
    E.createElement("desc", null, l),
    t
  )
}
var A8 = ["children", "className"]
function hv() {
  return (
    (hv = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    hv.apply(this, arguments)
  )
}
function T8(e, t) {
  if (e == null) return {}
  var n = E8(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function E8(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
var ct = E.forwardRef(function (e, t) {
    var n = e.children,
      r = e.className,
      i = T8(e, A8),
      o = Oe("recharts-layer", r)
    return E.createElement("g", hv({ className: o }, he(i, !0), { ref: t }), n)
  }),
  qd = function (t, n) {
    for (
      var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2;
      o < r;
      o++
    )
      i[o - 2] = arguments[o]
  }
function C8(e, t, n) {
  var r = -1,
    i = e.length
  t < 0 && (t = -t > i ? 0 : i + t),
    (n = n > i ? i : n),
    n < 0 && (n += i),
    (i = t > n ? 0 : (n - t) >>> 0),
    (t >>>= 0)
  for (var o = Array(i); ++r < i; ) o[r] = e[r + t]
  return o
}
var _8 = C8,
  k8 = _8
function M8(e, t, n) {
  var r = e.length
  return (n = n === void 0 ? r : n), !t && n >= r ? e : k8(e, t, n)
}
var j8 = M8,
  D8 = "\\ud800-\\udfff",
  I8 = "\\u0300-\\u036f",
  N8 = "\\ufe20-\\ufe2f",
  R8 = "\\u20d0-\\u20ff",
  L8 = I8 + N8 + R8,
  B8 = "\\ufe0e\\ufe0f",
  F8 = "\\u200d",
  V8 = RegExp("[" + F8 + D8 + L8 + B8 + "]")
function z8(e) {
  return V8.test(e)
}
var bC = z8
function U8(e) {
  return e.split("")
}
var W8 = U8,
  xC = "\\ud800-\\udfff",
  H8 = "\\u0300-\\u036f",
  G8 = "\\ufe20-\\ufe2f",
  K8 = "\\u20d0-\\u20ff",
  q8 = H8 + G8 + K8,
  X8 = "\\ufe0e\\ufe0f",
  Y8 = "[" + xC + "]",
  mv = "[" + q8 + "]",
  vv = "\\ud83c[\\udffb-\\udfff]",
  Q8 = "(?:" + mv + "|" + vv + ")",
  wC = "[^" + xC + "]",
  SC = "(?:\\ud83c[\\udde6-\\uddff]){2}",
  OC = "[\\ud800-\\udbff][\\udc00-\\udfff]",
  Z8 = "\\u200d",
  PC = Q8 + "?",
  $C = "[" + X8 + "]?",
  J8 = "(?:" + Z8 + "(?:" + [wC, SC, OC].join("|") + ")" + $C + PC + ")*",
  eV = $C + PC + J8,
  tV = "(?:" + [wC + mv + "?", mv, SC, OC, Y8].join("|") + ")",
  nV = RegExp(vv + "(?=" + vv + ")|" + tV + eV, "g")
function rV(e) {
  return e.match(nV) || []
}
var iV = rV,
  oV = W8,
  aV = bC,
  sV = iV
function lV(e) {
  return aV(e) ? sV(e) : oV(e)
}
var uV = lV,
  cV = j8,
  fV = bC,
  dV = uV,
  pV = dC
function hV(e) {
  return function (t) {
    t = pV(t)
    var n = fV(t) ? dV(t) : void 0,
      r = n ? n[0] : t.charAt(0),
      i = n ? cV(n, 1).join("") : t.slice(1)
    return r[e]() + i
  }
}
var mV = hV,
  vV = mV,
  gV = vV("toUpperCase"),
  yV = gV
const Xd = Pe(yV)
function $e(e) {
  return function () {
    return e
  }
}
const AC = Math.cos,
  df = Math.sin,
  Nn = Math.sqrt,
  pf = Math.PI,
  Yd = 2 * pf,
  gv = Math.PI,
  yv = 2 * gv,
  ji = 1e-6,
  bV = yv - ji
function TC(e) {
  this._ += e[0]
  for (let t = 1, n = e.length; t < n; ++t) this._ += arguments[t] + e[t]
}
function xV(e) {
  let t = Math.floor(e)
  if (!(t >= 0)) throw new Error(`invalid digits: ${e}`)
  if (t > 15) return TC
  const n = 10 ** t
  return function (r) {
    this._ += r[0]
    for (let i = 1, o = r.length; i < o; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i]
  }
}
class wV {
  constructor(t) {
    ;(this._x0 = this._y0 = this._x1 = this._y1 = null),
      (this._ = ""),
      (this._append = t == null ? TC : xV(t))
  }
  moveTo(t, n) {
    this._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +n)}`
  }
  closePath() {
    this._x1 !== null &&
      ((this._x1 = this._x0), (this._y1 = this._y0), this._append`Z`)
  }
  lineTo(t, n) {
    this._append`L${(this._x1 = +t)},${(this._y1 = +n)}`
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${(this._x1 = +r)},${(this._y1 = +i)}`
  }
  bezierCurveTo(t, n, r, i, o, a) {
    this._append`C${+t},${+n},${+r},${+i},${(this._x1 = +o)},${(this._y1 = +a)}`
  }
  arcTo(t, n, r, i, o) {
    if (((t = +t), (n = +n), (r = +r), (i = +i), (o = +o), o < 0))
      throw new Error(`negative radius: ${o}`)
    let a = this._x1,
      s = this._y1,
      l = r - t,
      u = i - n,
      f = a - t,
      c = s - n,
      d = f * f + c * c
    if (this._x1 === null) this._append`M${(this._x1 = t)},${(this._y1 = n)}`
    else if (d > ji)
      if (!(Math.abs(c * l - u * f) > ji) || !o)
        this._append`L${(this._x1 = t)},${(this._y1 = n)}`
      else {
        let p = r - a,
          h = i - s,
          m = l * l + u * u,
          b = p * p + h * h,
          g = Math.sqrt(m),
          v = Math.sqrt(d),
          y = o * Math.tan((gv - Math.acos((m + d - b) / (2 * g * v))) / 2),
          w = y / v,
          x = y / g
        Math.abs(w - 1) > ji && this._append`L${t + w * f},${n + w * c}`,
          this._append`A${o},${o},0,0,${+(c * p > f * h)},${(this._x1 =
            t + x * l)},${(this._y1 = n + x * u)}`
      }
  }
  arc(t, n, r, i, o, a) {
    if (((t = +t), (n = +n), (r = +r), (a = !!a), r < 0))
      throw new Error(`negative radius: ${r}`)
    let s = r * Math.cos(i),
      l = r * Math.sin(i),
      u = t + s,
      f = n + l,
      c = 1 ^ a,
      d = a ? i - o : o - i
    this._x1 === null
      ? this._append`M${u},${f}`
      : (Math.abs(this._x1 - u) > ji || Math.abs(this._y1 - f) > ji) &&
        this._append`L${u},${f}`,
      r &&
        (d < 0 && (d = (d % yv) + yv),
        d > bV
          ? this._append`A${r},${r},0,1,${c},${t - s},${
              n - l
            }A${r},${r},0,1,${c},${(this._x1 = u)},${(this._y1 = f)}`
          : d > ji &&
            this._append`A${r},${r},0,${+(d >= gv)},${c},${(this._x1 =
              t + r * Math.cos(o))},${(this._y1 = n + r * Math.sin(o))}`)
  }
  rect(t, n, r, i) {
    this._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 =
      +n)}h${(r = +r)}v${+i}h${-r}Z`
  }
  toString() {
    return this._
  }
}
function a0(e) {
  let t = 3
  return (
    (e.digits = function (n) {
      if (!arguments.length) return t
      if (n == null) t = null
      else {
        const r = Math.floor(n)
        if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`)
        t = r
      }
      return e
    }),
    () => new wV(t)
  )
}
function s0(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e)
}
function EC(e) {
  this._context = e
}
EC.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    this._point = 0
  },
  lineEnd: function () {
    ;(this._line || (this._line !== 0 && this._point === 1)) &&
      this._context.closePath(),
      (this._line = 1 - this._line)
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        ;(this._point = 1),
          this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
        break
      case 1:
        this._point = 2
      default:
        this._context.lineTo(e, t)
        break
    }
  }
}
function Qd(e) {
  return new EC(e)
}
function CC(e) {
  return e[0]
}
function _C(e) {
  return e[1]
}
function kC(e, t) {
  var n = $e(!0),
    r = null,
    i = Qd,
    o = null,
    a = a0(s)
  ;(e = typeof e == "function" ? e : e === void 0 ? CC : $e(e)),
    (t = typeof t == "function" ? t : t === void 0 ? _C : $e(t))
  function s(l) {
    var u,
      f = (l = s0(l)).length,
      c,
      d = !1,
      p
    for (r == null && (o = i((p = a()))), u = 0; u <= f; ++u)
      !(u < f && n((c = l[u]), u, l)) === d &&
        ((d = !d) ? o.lineStart() : o.lineEnd()),
        d && o.point(+e(c, u, l), +t(c, u, l))
    if (p) return (o = null), p + "" || null
  }
  return (
    (s.x = function (l) {
      return arguments.length
        ? ((e = typeof l == "function" ? l : $e(+l)), s)
        : e
    }),
    (s.y = function (l) {
      return arguments.length
        ? ((t = typeof l == "function" ? l : $e(+l)), s)
        : t
    }),
    (s.defined = function (l) {
      return arguments.length
        ? ((n = typeof l == "function" ? l : $e(!!l)), s)
        : n
    }),
    (s.curve = function (l) {
      return arguments.length ? ((i = l), r != null && (o = i(r)), s) : i
    }),
    (s.context = function (l) {
      return arguments.length
        ? (l == null ? (r = o = null) : (o = i((r = l))), s)
        : r
    }),
    s
  )
}
function qu(e, t, n) {
  var r = null,
    i = $e(!0),
    o = null,
    a = Qd,
    s = null,
    l = a0(u)
  ;(e = typeof e == "function" ? e : e === void 0 ? CC : $e(+e)),
    (t = typeof t == "function" ? t : $e(t === void 0 ? 0 : +t)),
    (n = typeof n == "function" ? n : n === void 0 ? _C : $e(+n))
  function u(c) {
    var d,
      p,
      h,
      m = (c = s0(c)).length,
      b,
      g = !1,
      v,
      y = new Array(m),
      w = new Array(m)
    for (o == null && (s = a((v = l()))), d = 0; d <= m; ++d) {
      if (!(d < m && i((b = c[d]), d, c)) === g)
        if ((g = !g)) (p = d), s.areaStart(), s.lineStart()
        else {
          for (s.lineEnd(), s.lineStart(), h = d - 1; h >= p; --h)
            s.point(y[h], w[h])
          s.lineEnd(), s.areaEnd()
        }
      g &&
        ((y[d] = +e(b, d, c)),
        (w[d] = +t(b, d, c)),
        s.point(r ? +r(b, d, c) : y[d], n ? +n(b, d, c) : w[d]))
    }
    if (v) return (s = null), v + "" || null
  }
  function f() {
    return kC().defined(i).curve(a).context(o)
  }
  return (
    (u.x = function (c) {
      return arguments.length
        ? ((e = typeof c == "function" ? c : $e(+c)), (r = null), u)
        : e
    }),
    (u.x0 = function (c) {
      return arguments.length
        ? ((e = typeof c == "function" ? c : $e(+c)), u)
        : e
    }),
    (u.x1 = function (c) {
      return arguments.length
        ? ((r = c == null ? null : typeof c == "function" ? c : $e(+c)), u)
        : r
    }),
    (u.y = function (c) {
      return arguments.length
        ? ((t = typeof c == "function" ? c : $e(+c)), (n = null), u)
        : t
    }),
    (u.y0 = function (c) {
      return arguments.length
        ? ((t = typeof c == "function" ? c : $e(+c)), u)
        : t
    }),
    (u.y1 = function (c) {
      return arguments.length
        ? ((n = c == null ? null : typeof c == "function" ? c : $e(+c)), u)
        : n
    }),
    (u.lineX0 = u.lineY0 =
      function () {
        return f().x(e).y(t)
      }),
    (u.lineY1 = function () {
      return f().x(e).y(n)
    }),
    (u.lineX1 = function () {
      return f().x(r).y(t)
    }),
    (u.defined = function (c) {
      return arguments.length
        ? ((i = typeof c == "function" ? c : $e(!!c)), u)
        : i
    }),
    (u.curve = function (c) {
      return arguments.length ? ((a = c), o != null && (s = a(o)), u) : a
    }),
    (u.context = function (c) {
      return arguments.length
        ? (c == null ? (o = s = null) : (s = a((o = c))), u)
        : o
    }),
    u
  )
}
class MC {
  constructor(t, n) {
    ;(this._context = t), (this._x = n)
  }
  areaStart() {
    this._line = 0
  }
  areaEnd() {
    this._line = NaN
  }
  lineStart() {
    this._point = 0
  }
  lineEnd() {
    ;(this._line || (this._line !== 0 && this._point === 1)) &&
      this._context.closePath(),
      (this._line = 1 - this._line)
  }
  point(t, n) {
    switch (((t = +t), (n = +n), this._point)) {
      case 0: {
        ;(this._point = 1),
          this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)
        break
      }
      case 1:
        this._point = 2
      default: {
        this._x
          ? this._context.bezierCurveTo(
              (this._x0 = (this._x0 + t) / 2),
              this._y0,
              this._x0,
              n,
              t,
              n
            )
          : this._context.bezierCurveTo(
              this._x0,
              (this._y0 = (this._y0 + n) / 2),
              t,
              this._y0,
              t,
              n
            )
        break
      }
    }
    ;(this._x0 = t), (this._y0 = n)
  }
}
function SV(e) {
  return new MC(e, !0)
}
function OV(e) {
  return new MC(e, !1)
}
const l0 = {
    draw(e, t) {
      const n = Nn(t / pf)
      e.moveTo(n, 0), e.arc(0, 0, n, 0, Yd)
    }
  },
  PV = {
    draw(e, t) {
      const n = Nn(t / 5) / 2
      e.moveTo(-3 * n, -n),
        e.lineTo(-n, -n),
        e.lineTo(-n, -3 * n),
        e.lineTo(n, -3 * n),
        e.lineTo(n, -n),
        e.lineTo(3 * n, -n),
        e.lineTo(3 * n, n),
        e.lineTo(n, n),
        e.lineTo(n, 3 * n),
        e.lineTo(-n, 3 * n),
        e.lineTo(-n, n),
        e.lineTo(-3 * n, n),
        e.closePath()
    }
  },
  jC = Nn(1 / 3),
  $V = jC * 2,
  AV = {
    draw(e, t) {
      const n = Nn(t / $V),
        r = n * jC
      e.moveTo(0, -n),
        e.lineTo(r, 0),
        e.lineTo(0, n),
        e.lineTo(-r, 0),
        e.closePath()
    }
  },
  TV = {
    draw(e, t) {
      const n = Nn(t),
        r = -n / 2
      e.rect(r, r, n, n)
    }
  },
  EV = 0.8908130915292852,
  DC = df(pf / 10) / df((7 * pf) / 10),
  CV = df(Yd / 10) * DC,
  _V = -AC(Yd / 10) * DC,
  kV = {
    draw(e, t) {
      const n = Nn(t * EV),
        r = CV * n,
        i = _V * n
      e.moveTo(0, -n), e.lineTo(r, i)
      for (let o = 1; o < 5; ++o) {
        const a = (Yd * o) / 5,
          s = AC(a),
          l = df(a)
        e.lineTo(l * n, -s * n), e.lineTo(s * r - l * i, l * r + s * i)
      }
      e.closePath()
    }
  },
  wh = Nn(3),
  MV = {
    draw(e, t) {
      const n = -Nn(t / (wh * 3))
      e.moveTo(0, n * 2),
        e.lineTo(-wh * n, -n),
        e.lineTo(wh * n, -n),
        e.closePath()
    }
  },
  on = -0.5,
  an = Nn(3) / 2,
  bv = 1 / Nn(12),
  jV = (bv / 2 + 1) * 3,
  DV = {
    draw(e, t) {
      const n = Nn(t / jV),
        r = n / 2,
        i = n * bv,
        o = r,
        a = n * bv + n,
        s = -o,
        l = a
      e.moveTo(r, i),
        e.lineTo(o, a),
        e.lineTo(s, l),
        e.lineTo(on * r - an * i, an * r + on * i),
        e.lineTo(on * o - an * a, an * o + on * a),
        e.lineTo(on * s - an * l, an * s + on * l),
        e.lineTo(on * r + an * i, on * i - an * r),
        e.lineTo(on * o + an * a, on * a - an * o),
        e.lineTo(on * s + an * l, on * l - an * s),
        e.closePath()
    }
  }
function IV(e, t) {
  let n = null,
    r = a0(i)
  ;(e = typeof e == "function" ? e : $e(e || l0)),
    (t = typeof t == "function" ? t : $e(t === void 0 ? 64 : +t))
  function i() {
    let o
    if (
      (n || (n = o = r()),
      e.apply(this, arguments).draw(n, +t.apply(this, arguments)),
      o)
    )
      return (n = null), o + "" || null
  }
  return (
    (i.type = function (o) {
      return arguments.length
        ? ((e = typeof o == "function" ? o : $e(o)), i)
        : e
    }),
    (i.size = function (o) {
      return arguments.length
        ? ((t = typeof o == "function" ? o : $e(+o)), i)
        : t
    }),
    (i.context = function (o) {
      return arguments.length ? ((n = o ?? null), i) : n
    }),
    i
  )
}
function hf() {}
function mf(e, t, n) {
  e._context.bezierCurveTo(
    (2 * e._x0 + e._x1) / 3,
    (2 * e._y0 + e._y1) / 3,
    (e._x0 + 2 * e._x1) / 3,
    (e._y0 + 2 * e._y1) / 3,
    (e._x0 + 4 * e._x1 + t) / 6,
    (e._y0 + 4 * e._y1 + n) / 6
  )
}
function IC(e) {
  this._context = e
}
IC.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;(this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0)
  },
  lineEnd: function () {
    switch (this._point) {
      case 3:
        mf(this, this._x1, this._y1)
      case 2:
        this._context.lineTo(this._x1, this._y1)
        break
    }
    ;(this._line || (this._line !== 0 && this._point === 1)) &&
      this._context.closePath(),
      (this._line = 1 - this._line)
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        ;(this._point = 1),
          this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
        break
      case 1:
        this._point = 2
        break
      case 2:
        ;(this._point = 3),
          this._context.lineTo(
            (5 * this._x0 + this._x1) / 6,
            (5 * this._y0 + this._y1) / 6
          )
      default:
        mf(this, e, t)
        break
    }
    ;(this._x0 = this._x1),
      (this._x1 = e),
      (this._y0 = this._y1),
      (this._y1 = t)
  }
}
function NV(e) {
  return new IC(e)
}
function NC(e) {
  this._context = e
}
NC.prototype = {
  areaStart: hf,
  areaEnd: hf,
  lineStart: function () {
    ;(this._x0 =
      this._x1 =
      this._x2 =
      this._x3 =
      this._x4 =
      this._y0 =
      this._y1 =
      this._y2 =
      this._y3 =
      this._y4 =
        NaN),
      (this._point = 0)
  },
  lineEnd: function () {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath()
        break
      }
      case 2: {
        this._context.moveTo(
          (this._x2 + 2 * this._x3) / 3,
          (this._y2 + 2 * this._y3) / 3
        ),
          this._context.lineTo(
            (this._x3 + 2 * this._x2) / 3,
            (this._y3 + 2 * this._y2) / 3
          ),
          this._context.closePath()
        break
      }
      case 3: {
        this.point(this._x2, this._y2),
          this.point(this._x3, this._y3),
          this.point(this._x4, this._y4)
        break
      }
    }
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        ;(this._point = 1), (this._x2 = e), (this._y2 = t)
        break
      case 1:
        ;(this._point = 2), (this._x3 = e), (this._y3 = t)
        break
      case 2:
        ;(this._point = 3),
          (this._x4 = e),
          (this._y4 = t),
          this._context.moveTo(
            (this._x0 + 4 * this._x1 + e) / 6,
            (this._y0 + 4 * this._y1 + t) / 6
          )
        break
      default:
        mf(this, e, t)
        break
    }
    ;(this._x0 = this._x1),
      (this._x1 = e),
      (this._y0 = this._y1),
      (this._y1 = t)
  }
}
function RV(e) {
  return new NC(e)
}
function RC(e) {
  this._context = e
}
RC.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;(this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0)
  },
  lineEnd: function () {
    ;(this._line || (this._line !== 0 && this._point === 3)) &&
      this._context.closePath(),
      (this._line = 1 - this._line)
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        this._point = 1
        break
      case 1:
        this._point = 2
        break
      case 2:
        this._point = 3
        var n = (this._x0 + 4 * this._x1 + e) / 6,
          r = (this._y0 + 4 * this._y1 + t) / 6
        this._line ? this._context.lineTo(n, r) : this._context.moveTo(n, r)
        break
      case 3:
        this._point = 4
      default:
        mf(this, e, t)
        break
    }
    ;(this._x0 = this._x1),
      (this._x1 = e),
      (this._y0 = this._y1),
      (this._y1 = t)
  }
}
function LV(e) {
  return new RC(e)
}
function LC(e) {
  this._context = e
}
LC.prototype = {
  areaStart: hf,
  areaEnd: hf,
  lineStart: function () {
    this._point = 0
  },
  lineEnd: function () {
    this._point && this._context.closePath()
  },
  point: function (e, t) {
    ;(e = +e),
      (t = +t),
      this._point
        ? this._context.lineTo(e, t)
        : ((this._point = 1), this._context.moveTo(e, t))
  }
}
function BV(e) {
  return new LC(e)
}
function iw(e) {
  return e < 0 ? -1 : 1
}
function ow(e, t, n) {
  var r = e._x1 - e._x0,
    i = t - e._x1,
    o = (e._y1 - e._y0) / (r || (i < 0 && -0)),
    a = (n - e._y1) / (i || (r < 0 && -0)),
    s = (o * i + a * r) / (r + i)
  return (
    (iw(o) + iw(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(s)) || 0
  )
}
function aw(e, t) {
  var n = e._x1 - e._x0
  return n ? ((3 * (e._y1 - e._y0)) / n - t) / 2 : t
}
function Sh(e, t, n) {
  var r = e._x0,
    i = e._y0,
    o = e._x1,
    a = e._y1,
    s = (o - r) / 3
  e._context.bezierCurveTo(r + s, i + s * t, o - s, a - s * n, o, a)
}
function vf(e) {
  this._context = e
}
vf.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;(this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN),
      (this._point = 0)
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1)
        break
      case 3:
        Sh(this, this._t0, aw(this, this._t0))
        break
    }
    ;(this._line || (this._line !== 0 && this._point === 1)) &&
      this._context.closePath(),
      (this._line = 1 - this._line)
  },
  point: function (e, t) {
    var n = NaN
    if (((e = +e), (t = +t), !(e === this._x1 && t === this._y1))) {
      switch (this._point) {
        case 0:
          ;(this._point = 1),
            this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
          break
        case 1:
          this._point = 2
          break
        case 2:
          ;(this._point = 3), Sh(this, aw(this, (n = ow(this, e, t))), n)
          break
        default:
          Sh(this, this._t0, (n = ow(this, e, t)))
          break
      }
      ;(this._x0 = this._x1),
        (this._x1 = e),
        (this._y0 = this._y1),
        (this._y1 = t),
        (this._t0 = n)
    }
  }
}
function BC(e) {
  this._context = new FC(e)
}
;(BC.prototype = Object.create(vf.prototype)).point = function (e, t) {
  vf.prototype.point.call(this, t, e)
}
function FC(e) {
  this._context = e
}
FC.prototype = {
  moveTo: function (e, t) {
    this._context.moveTo(t, e)
  },
  closePath: function () {
    this._context.closePath()
  },
  lineTo: function (e, t) {
    this._context.lineTo(t, e)
  },
  bezierCurveTo: function (e, t, n, r, i, o) {
    this._context.bezierCurveTo(t, e, r, n, o, i)
  }
}
function FV(e) {
  return new vf(e)
}
function VV(e) {
  return new BC(e)
}
function VC(e) {
  this._context = e
}
VC.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;(this._x = []), (this._y = [])
  },
  lineEnd: function () {
    var e = this._x,
      t = this._y,
      n = e.length
    if (n)
      if (
        (this._line
          ? this._context.lineTo(e[0], t[0])
          : this._context.moveTo(e[0], t[0]),
        n === 2)
      )
        this._context.lineTo(e[1], t[1])
      else
        for (var r = sw(e), i = sw(t), o = 0, a = 1; a < n; ++o, ++a)
          this._context.bezierCurveTo(
            r[0][o],
            i[0][o],
            r[1][o],
            i[1][o],
            e[a],
            t[a]
          )
    ;(this._line || (this._line !== 0 && n === 1)) && this._context.closePath(),
      (this._line = 1 - this._line),
      (this._x = this._y = null)
  },
  point: function (e, t) {
    this._x.push(+e), this._y.push(+t)
  }
}
function sw(e) {
  var t,
    n = e.length - 1,
    r,
    i = new Array(n),
    o = new Array(n),
    a = new Array(n)
  for (i[0] = 0, o[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < n - 1; ++t)
    (i[t] = 1), (o[t] = 4), (a[t] = 4 * e[t] + 2 * e[t + 1])
  for (
    i[n - 1] = 2, o[n - 1] = 7, a[n - 1] = 8 * e[n - 1] + e[n], t = 1;
    t < n;
    ++t
  )
    (r = i[t] / o[t - 1]), (o[t] -= r), (a[t] -= r * a[t - 1])
  for (i[n - 1] = a[n - 1] / o[n - 1], t = n - 2; t >= 0; --t)
    i[t] = (a[t] - i[t + 1]) / o[t]
  for (o[n - 1] = (e[n] + i[n - 1]) / 2, t = 0; t < n - 1; ++t)
    o[t] = 2 * e[t + 1] - i[t + 1]
  return [i, o]
}
function zV(e) {
  return new VC(e)
}
function Zd(e, t) {
  ;(this._context = e), (this._t = t)
}
Zd.prototype = {
  areaStart: function () {
    this._line = 0
  },
  areaEnd: function () {
    this._line = NaN
  },
  lineStart: function () {
    ;(this._x = this._y = NaN), (this._point = 0)
  },
  lineEnd: function () {
    0 < this._t &&
      this._t < 1 &&
      this._point === 2 &&
      this._context.lineTo(this._x, this._y),
      (this._line || (this._line !== 0 && this._point === 1)) &&
        this._context.closePath(),
      this._line >= 0 &&
        ((this._t = 1 - this._t), (this._line = 1 - this._line))
  },
  point: function (e, t) {
    switch (((e = +e), (t = +t), this._point)) {
      case 0:
        ;(this._point = 1),
          this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t)
        break
      case 1:
        this._point = 2
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t)
        else {
          var n = this._x * (1 - this._t) + e * this._t
          this._context.lineTo(n, this._y), this._context.lineTo(n, t)
        }
        break
      }
    }
    ;(this._x = e), (this._y = t)
  }
}
function UV(e) {
  return new Zd(e, 0.5)
}
function WV(e) {
  return new Zd(e, 0)
}
function HV(e) {
  return new Zd(e, 1)
}
function sa(e, t) {
  if ((a = e.length) > 1)
    for (var n = 1, r, i, o = e[t[0]], a, s = o.length; n < a; ++n)
      for (i = o, o = e[t[n]], r = 0; r < s; ++r)
        o[r][1] += o[r][0] = isNaN(i[r][1]) ? i[r][0] : i[r][1]
}
function xv(e) {
  for (var t = e.length, n = new Array(t); --t >= 0; ) n[t] = t
  return n
}
function GV(e, t) {
  return e[t]
}
function KV(e) {
  const t = []
  return (t.key = e), t
}
function qV() {
  var e = $e([]),
    t = xv,
    n = sa,
    r = GV
  function i(o) {
    var a = Array.from(e.apply(this, arguments), KV),
      s,
      l = a.length,
      u = -1,
      f
    for (const c of o)
      for (s = 0, ++u; s < l; ++s)
        (a[s][u] = [0, +r(c, a[s].key, u, o)]).data = c
    for (s = 0, f = s0(t(a)); s < l; ++s) a[f[s]].index = s
    return n(a, f), a
  }
  return (
    (i.keys = function (o) {
      return arguments.length
        ? ((e = typeof o == "function" ? o : $e(Array.from(o))), i)
        : e
    }),
    (i.value = function (o) {
      return arguments.length
        ? ((r = typeof o == "function" ? o : $e(+o)), i)
        : r
    }),
    (i.order = function (o) {
      return arguments.length
        ? ((t =
            o == null ? xv : typeof o == "function" ? o : $e(Array.from(o))),
          i)
        : t
    }),
    (i.offset = function (o) {
      return arguments.length ? ((n = o ?? sa), i) : n
    }),
    i
  )
}
function XV(e, t) {
  if ((r = e.length) > 0) {
    for (var n, r, i = 0, o = e[0].length, a; i < o; ++i) {
      for (a = n = 0; n < r; ++n) a += e[n][i][1] || 0
      if (a) for (n = 0; n < r; ++n) e[n][i][1] /= a
    }
    sa(e, t)
  }
}
function YV(e, t) {
  if ((i = e.length) > 0) {
    for (var n = 0, r = e[t[0]], i, o = r.length; n < o; ++n) {
      for (var a = 0, s = 0; a < i; ++a) s += e[a][n][1] || 0
      r[n][1] += r[n][0] = -s / 2
    }
    sa(e, t)
  }
}
function QV(e, t) {
  if (!(!((a = e.length) > 0) || !((o = (i = e[t[0]]).length) > 0))) {
    for (var n = 0, r = 1, i, o, a; r < o; ++r) {
      for (var s = 0, l = 0, u = 0; s < a; ++s) {
        for (
          var f = e[t[s]],
            c = f[r][1] || 0,
            d = f[r - 1][1] || 0,
            p = (c - d) / 2,
            h = 0;
          h < s;
          ++h
        ) {
          var m = e[t[h]],
            b = m[r][1] || 0,
            g = m[r - 1][1] || 0
          p += b - g
        }
        ;(l += c), (u += p * c)
      }
      ;(i[r - 1][1] += i[r - 1][0] = n), l && (n -= u / l)
    }
    ;(i[r - 1][1] += i[r - 1][0] = n), sa(e, t)
  }
}
function al(e) {
  "@babel/helpers - typeof"
  return (
    (al =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    al(e)
  )
}
var ZV = ["type", "size", "sizeType"]
function wv() {
  return (
    (wv = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    wv.apply(this, arguments)
  )
}
function lw(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function uw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? lw(Object(n), !0).forEach(function (r) {
          JV(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : lw(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function JV(e, t, n) {
  return (
    (t = ez(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function ez(e) {
  var t = tz(e, "string")
  return al(t) === "symbol" ? t : String(t)
}
function tz(e, t) {
  if (al(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (al(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function nz(e, t) {
  if (e == null) return {}
  var n = rz(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function rz(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
var zC = {
    symbolCircle: l0,
    symbolCross: PV,
    symbolDiamond: AV,
    symbolSquare: TV,
    symbolStar: kV,
    symbolTriangle: MV,
    symbolWye: DV
  },
  iz = Math.PI / 180,
  oz = function (t) {
    var n = "symbol".concat(Xd(t))
    return zC[n] || l0
  },
  az = function (t, n, r) {
    if (n === "area") return t
    switch (r) {
      case "cross":
        return (5 * t * t) / 9
      case "diamond":
        return (0.5 * t * t) / Math.sqrt(3)
      case "square":
        return t * t
      case "star": {
        var i = 18 * iz
        return (
          1.25 *
          t *
          t *
          (Math.tan(i) - Math.tan(i * 2) * Math.pow(Math.tan(i), 2))
        )
      }
      case "triangle":
        return (Math.sqrt(3) * t * t) / 4
      case "wye":
        return ((21 - 10 * Math.sqrt(3)) * t * t) / 8
      default:
        return (Math.PI * t * t) / 4
    }
  },
  sz = function (t, n) {
    zC["symbol".concat(Xd(t))] = n
  },
  u0 = function (t) {
    var n = t.type,
      r = n === void 0 ? "circle" : n,
      i = t.size,
      o = i === void 0 ? 64 : i,
      a = t.sizeType,
      s = a === void 0 ? "area" : a,
      l = nz(t, ZV),
      u = uw(uw({}, l), {}, { type: r, size: o, sizeType: s }),
      f = function () {
        var b = oz(r),
          g = IV()
            .type(b)
            .size(az(o, s, r))
        return g()
      },
      c = u.className,
      d = u.cx,
      p = u.cy,
      h = he(u, !0)
    return d === +d && p === +p && o === +o
      ? E.createElement(
          "path",
          wv({}, h, {
            className: Oe("recharts-symbols", c),
            transform: "translate(".concat(d, ", ").concat(p, ")"),
            d: f()
          })
        )
      : null
  }
u0.registerSymbol = sz
function la(e) {
  "@babel/helpers - typeof"
  return (
    (la =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    la(e)
  )
}
function Sv() {
  return (
    (Sv = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Sv.apply(this, arguments)
  )
}
function cw(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function lz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? cw(Object(n), !0).forEach(function (r) {
          sl(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : cw(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function uz(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function fw(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, UC(r.key), r)
  }
}
function cz(e, t, n) {
  return (
    t && fw(e.prototype, t),
    n && fw(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function fz(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 }
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && Ov(e, t)
}
function Ov(e, t) {
  return (
    (Ov = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r
        }),
    Ov(e, t)
  )
}
function dz(e) {
  var t = mz()
  return function () {
    var r = gf(e),
      i
    if (t) {
      var o = gf(this).constructor
      i = Reflect.construct(r, arguments, o)
    } else i = r.apply(this, arguments)
    return pz(this, i)
  }
}
function pz(e, t) {
  if (t && (la(t) === "object" || typeof t == "function")) return t
  if (t !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return hz(e)
}
function hz(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return e
}
function mz() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function gf(e) {
  return (
    (gf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n)
        }),
    gf(e)
  )
}
function sl(e, t, n) {
  return (
    (t = UC(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function UC(e) {
  var t = vz(e, "string")
  return la(t) === "symbol" ? t : String(t)
}
function vz(e, t) {
  if (la(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (la(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var sn = 32,
  c0 = (function (e) {
    fz(n, e)
    var t = dz(n)
    function n() {
      return uz(this, n), t.apply(this, arguments)
    }
    return (
      cz(n, [
        {
          key: "renderIcon",
          value: function (i) {
            var o = this.props.inactiveColor,
              a = sn / 2,
              s = sn / 6,
              l = sn / 3,
              u = i.inactive ? o : i.color
            if (i.type === "plainline")
              return E.createElement("line", {
                strokeWidth: 4,
                fill: "none",
                stroke: u,
                strokeDasharray: i.payload.strokeDasharray,
                x1: 0,
                y1: a,
                x2: sn,
                y2: a,
                className: "recharts-legend-icon"
              })
            if (i.type === "line")
              return E.createElement("path", {
                strokeWidth: 4,
                fill: "none",
                stroke: u,
                d: "M0,"
                  .concat(a, "h")
                  .concat(
                    l,
                    `
            A`
                  )
                  .concat(s, ",")
                  .concat(s, ",0,1,1,")
                  .concat(2 * l, ",")
                  .concat(
                    a,
                    `
            H`
                  )
                  .concat(sn, "M")
                  .concat(2 * l, ",")
                  .concat(
                    a,
                    `
            A`
                  )
                  .concat(s, ",")
                  .concat(s, ",0,1,1,")
                  .concat(l, ",")
                  .concat(a),
                className: "recharts-legend-icon"
              })
            if (i.type === "rect")
              return E.createElement("path", {
                stroke: "none",
                fill: u,
                d: "M0,"
                  .concat(sn / 8, "h")
                  .concat(sn, "v")
                  .concat((sn * 3) / 4, "h")
                  .concat(-sn, "z"),
                className: "recharts-legend-icon"
              })
            if (E.isValidElement(i.legendIcon)) {
              var f = lz({}, i)
              return delete f.legendIcon, E.cloneElement(i.legendIcon, f)
            }
            return E.createElement(u0, {
              fill: u,
              cx: a,
              cy: a,
              size: sn,
              sizeType: "diameter",
              type: i.type
            })
          }
        },
        {
          key: "renderItems",
          value: function () {
            var i = this,
              o = this.props,
              a = o.payload,
              s = o.iconSize,
              l = o.layout,
              u = o.formatter,
              f = o.inactiveColor,
              c = { x: 0, y: 0, width: sn, height: sn },
              d = {
                display: l === "horizontal" ? "inline-block" : "block",
                marginRight: 10
              },
              p = {
                display: "inline-block",
                verticalAlign: "middle",
                marginRight: 4
              }
            return a.map(function (h, m) {
              var b,
                g = h.formatter || u,
                v = Oe(
                  ((b = { "recharts-legend-item": !0 }),
                  sl(b, "legend-item-".concat(m), !0),
                  sl(b, "inactive", h.inactive),
                  b)
                )
              if (h.type === "none") return null
              var y = ce(h.value) ? null : h.value
              qd(
                !ce(h.value),
                `The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name="Name of my Data"/>`
              )
              var w = h.inactive ? f : h.color
              return E.createElement(
                "li",
                Sv(
                  { className: v, style: d, key: "legend-item-".concat(m) },
                  ff(i.props, h, m)
                ),
                E.createElement(
                  pv,
                  { width: s, height: s, viewBox: c, style: p },
                  i.renderIcon(h)
                ),
                E.createElement(
                  "span",
                  {
                    className: "recharts-legend-item-text",
                    style: { color: w }
                  },
                  g ? g(y, h, m) : y
                )
              )
            })
          }
        },
        {
          key: "render",
          value: function () {
            var i = this.props,
              o = i.payload,
              a = i.layout,
              s = i.align
            if (!o || !o.length) return null
            var l = {
              padding: 0,
              margin: 0,
              textAlign: a === "horizontal" ? s : "left"
            }
            return E.createElement(
              "ul",
              { className: "recharts-default-legend", style: l },
              this.renderItems()
            )
          }
        }
      ]),
      n
    )
  })(P.PureComponent)
sl(c0, "displayName", "Legend")
sl(c0, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "middle",
  inactiveColor: "#ccc"
})
var gz = Dd
function yz() {
  ;(this.__data__ = new gz()), (this.size = 0)
}
var bz = yz
function xz(e) {
  var t = this.__data__,
    n = t.delete(e)
  return (this.size = t.size), n
}
var wz = xz
function Sz(e) {
  return this.__data__.get(e)
}
var Oz = Sz
function Pz(e) {
  return this.__data__.has(e)
}
var $z = Pz,
  Az = Dd,
  Tz = Yy,
  Ez = Qy,
  Cz = 200
function _z(e, t) {
  var n = this.__data__
  if (n instanceof Az) {
    var r = n.__data__
    if (!Tz || r.length < Cz - 1)
      return r.push([e, t]), (this.size = ++n.size), this
    n = this.__data__ = new Ez(r)
  }
  return n.set(e, t), (this.size = n.size), this
}
var kz = _z,
  Mz = Dd,
  jz = bz,
  Dz = wz,
  Iz = Oz,
  Nz = $z,
  Rz = kz
function Da(e) {
  var t = (this.__data__ = new Mz(e))
  this.size = t.size
}
Da.prototype.clear = jz
Da.prototype.delete = Dz
Da.prototype.get = Iz
Da.prototype.has = Nz
Da.prototype.set = Rz
var WC = Da,
  Lz = "__lodash_hash_undefined__"
function Bz(e) {
  return this.__data__.set(e, Lz), this
}
var Fz = Bz
function Vz(e) {
  return this.__data__.has(e)
}
var zz = Vz,
  Uz = Qy,
  Wz = Fz,
  Hz = zz
function yf(e) {
  var t = -1,
    n = e == null ? 0 : e.length
  for (this.__data__ = new Uz(); ++t < n; ) this.add(e[t])
}
yf.prototype.add = yf.prototype.push = Wz
yf.prototype.has = Hz
var HC = yf
function Gz(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e)) return !0
  return !1
}
var GC = Gz
function Kz(e, t) {
  return e.has(t)
}
var KC = Kz,
  qz = HC,
  Xz = GC,
  Yz = KC,
  Qz = 1,
  Zz = 2
function Jz(e, t, n, r, i, o) {
  var a = n & Qz,
    s = e.length,
    l = t.length
  if (s != l && !(a && l > s)) return !1
  var u = o.get(e),
    f = o.get(t)
  if (u && f) return u == t && f == e
  var c = -1,
    d = !0,
    p = n & Zz ? new qz() : void 0
  for (o.set(e, t), o.set(t, e); ++c < s; ) {
    var h = e[c],
      m = t[c]
    if (r) var b = a ? r(m, h, c, t, e, o) : r(h, m, c, e, t, o)
    if (b !== void 0) {
      if (b) continue
      d = !1
      break
    }
    if (p) {
      if (
        !Xz(t, function (g, v) {
          if (!Yz(p, v) && (h === g || i(h, g, n, r, o))) return p.push(v)
        })
      ) {
        d = !1
        break
      }
    } else if (!(h === m || i(h, m, n, r, o))) {
      d = !1
      break
    }
  }
  return o.delete(e), o.delete(t), d
}
var qC = Jz,
  e7 = Jn,
  t7 = e7.Uint8Array,
  n7 = t7
function r7(e) {
  var t = -1,
    n = Array(e.size)
  return (
    e.forEach(function (r, i) {
      n[++t] = [i, r]
    }),
    n
  )
}
var i7 = r7
function o7(e) {
  var t = -1,
    n = Array(e.size)
  return (
    e.forEach(function (r) {
      n[++t] = r
    }),
    n
  )
}
var f0 = o7,
  dw = ru,
  pw = n7,
  a7 = Xy,
  s7 = qC,
  l7 = i7,
  u7 = f0,
  c7 = 1,
  f7 = 2,
  d7 = "[object Boolean]",
  p7 = "[object Date]",
  h7 = "[object Error]",
  m7 = "[object Map]",
  v7 = "[object Number]",
  g7 = "[object RegExp]",
  y7 = "[object Set]",
  b7 = "[object String]",
  x7 = "[object Symbol]",
  w7 = "[object ArrayBuffer]",
  S7 = "[object DataView]",
  hw = dw ? dw.prototype : void 0,
  Oh = hw ? hw.valueOf : void 0
function O7(e, t, n, r, i, o, a) {
  switch (n) {
    case S7:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1
      ;(e = e.buffer), (t = t.buffer)
    case w7:
      return !(e.byteLength != t.byteLength || !o(new pw(e), new pw(t)))
    case d7:
    case p7:
    case v7:
      return a7(+e, +t)
    case h7:
      return e.name == t.name && e.message == t.message
    case g7:
    case b7:
      return e == t + ""
    case m7:
      var s = l7
    case y7:
      var l = r & c7
      if ((s || (s = u7), e.size != t.size && !l)) return !1
      var u = a.get(e)
      if (u) return u == t
      ;(r |= f7), a.set(e, t)
      var f = s7(s(e), s(t), r, i, o, a)
      return a.delete(e), f
    case x7:
      if (Oh) return Oh.call(e) == Oh.call(t)
  }
  return !1
}
var P7 = O7
function $7(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; ) e[i + n] = t[n]
  return e
}
var XC = $7,
  A7 = XC,
  T7 = Ut
function E7(e, t, n) {
  var r = t(e)
  return T7(e) ? r : A7(r, n(e))
}
var C7 = E7
function _7(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, o = []; ++n < r; ) {
    var a = e[n]
    t(a, n, e) && (o[i++] = a)
  }
  return o
}
var k7 = _7
function M7() {
  return []
}
var j7 = M7,
  D7 = k7,
  I7 = j7,
  N7 = Object.prototype,
  R7 = N7.propertyIsEnumerable,
  mw = Object.getOwnPropertySymbols,
  L7 = mw
    ? function (e) {
        return e == null
          ? []
          : ((e = Object(e)),
            D7(mw(e), function (t) {
              return R7.call(e, t)
            }))
      }
    : I7,
  B7 = L7
function F7(e, t) {
  for (var n = -1, r = Array(e); ++n < e; ) r[n] = t(n)
  return r
}
var V7 = F7,
  z7 = Cr,
  U7 = _r,
  W7 = "[object Arguments]"
function H7(e) {
  return U7(e) && z7(e) == W7
}
var G7 = H7,
  vw = G7,
  K7 = _r,
  YC = Object.prototype,
  q7 = YC.hasOwnProperty,
  X7 = YC.propertyIsEnumerable,
  Y7 = vw(
    (function () {
      return arguments
    })()
  )
    ? vw
    : function (e) {
        return K7(e) && q7.call(e, "callee") && !X7.call(e, "callee")
      },
  d0 = Y7,
  bf = { exports: {} }
function Q7() {
  return !1
}
var Z7 = Q7
bf.exports
;(function (e, t) {
  var n = Jn,
    r = Z7,
    i = t && !t.nodeType && t,
    o = i && !0 && e && !e.nodeType && e,
    a = o && o.exports === i,
    s = a ? n.Buffer : void 0,
    l = s ? s.isBuffer : void 0,
    u = l || r
  e.exports = u
})(bf, bf.exports)
var QC = bf.exports,
  J7 = 9007199254740991,
  eU = /^(?:0|[1-9]\d*)$/
function tU(e, t) {
  var n = typeof e
  return (
    (t = t ?? J7),
    !!t &&
      (n == "number" || (n != "symbol" && eU.test(e))) &&
      e > -1 &&
      e % 1 == 0 &&
      e < t
  )
}
var p0 = tU,
  nU = 9007199254740991
function rU(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= nU
}
var h0 = rU,
  iU = Cr,
  oU = h0,
  aU = _r,
  sU = "[object Arguments]",
  lU = "[object Array]",
  uU = "[object Boolean]",
  cU = "[object Date]",
  fU = "[object Error]",
  dU = "[object Function]",
  pU = "[object Map]",
  hU = "[object Number]",
  mU = "[object Object]",
  vU = "[object RegExp]",
  gU = "[object Set]",
  yU = "[object String]",
  bU = "[object WeakMap]",
  xU = "[object ArrayBuffer]",
  wU = "[object DataView]",
  SU = "[object Float32Array]",
  OU = "[object Float64Array]",
  PU = "[object Int8Array]",
  $U = "[object Int16Array]",
  AU = "[object Int32Array]",
  TU = "[object Uint8Array]",
  EU = "[object Uint8ClampedArray]",
  CU = "[object Uint16Array]",
  _U = "[object Uint32Array]",
  Ce = {}
Ce[SU] =
  Ce[OU] =
  Ce[PU] =
  Ce[$U] =
  Ce[AU] =
  Ce[TU] =
  Ce[EU] =
  Ce[CU] =
  Ce[_U] =
    !0
Ce[sU] =
  Ce[lU] =
  Ce[xU] =
  Ce[uU] =
  Ce[wU] =
  Ce[cU] =
  Ce[fU] =
  Ce[dU] =
  Ce[pU] =
  Ce[hU] =
  Ce[mU] =
  Ce[vU] =
  Ce[gU] =
  Ce[yU] =
  Ce[bU] =
    !1
function kU(e) {
  return aU(e) && oU(e.length) && !!Ce[iU(e)]
}
var MU = kU
function jU(e) {
  return function (t) {
    return e(t)
  }
}
var ZC = jU,
  xf = { exports: {} }
xf.exports
;(function (e, t) {
  var n = sC,
    r = t && !t.nodeType && t,
    i = r && !0 && e && !e.nodeType && e,
    o = i && i.exports === r,
    a = o && n.process,
    s = (function () {
      try {
        var l = i && i.require && i.require("util").types
        return l || (a && a.binding && a.binding("util"))
      } catch {}
    })()
  e.exports = s
})(xf, xf.exports)
var DU = xf.exports,
  IU = MU,
  NU = ZC,
  gw = DU,
  yw = gw && gw.isTypedArray,
  RU = yw ? NU(yw) : IU,
  JC = RU,
  LU = V7,
  BU = d0,
  FU = Ut,
  VU = QC,
  zU = p0,
  UU = JC,
  WU = Object.prototype,
  HU = WU.hasOwnProperty
function GU(e, t) {
  var n = FU(e),
    r = !n && BU(e),
    i = !n && !r && VU(e),
    o = !n && !r && !i && UU(e),
    a = n || r || i || o,
    s = a ? LU(e.length, String) : [],
    l = s.length
  for (var u in e)
    (t || HU.call(e, u)) &&
      !(
        a &&
        (u == "length" ||
          (i && (u == "offset" || u == "parent")) ||
          (o && (u == "buffer" || u == "byteLength" || u == "byteOffset")) ||
          zU(u, l))
      ) &&
      s.push(u)
  return s
}
var KU = GU,
  qU = Object.prototype
function XU(e) {
  var t = e && e.constructor,
    n = (typeof t == "function" && t.prototype) || qU
  return e === n
}
var YU = XU
function QU(e, t) {
  return function (n) {
    return e(t(n))
  }
}
var e_ = QU,
  ZU = e_,
  JU = ZU(Object.keys, Object),
  e9 = JU,
  t9 = YU,
  n9 = e9,
  r9 = Object.prototype,
  i9 = r9.hasOwnProperty
function o9(e) {
  if (!t9(e)) return n9(e)
  var t = []
  for (var n in Object(e)) i9.call(e, n) && n != "constructor" && t.push(n)
  return t
}
var a9 = o9,
  s9 = qy,
  l9 = h0
function u9(e) {
  return e != null && l9(e.length) && !s9(e)
}
var au = u9,
  c9 = KU,
  f9 = a9,
  d9 = au
function p9(e) {
  return d9(e) ? c9(e) : f9(e)
}
var Jd = p9,
  h9 = C7,
  m9 = B7,
  v9 = Jd
function g9(e) {
  return h9(e, v9, m9)
}
var y9 = g9,
  bw = y9,
  b9 = 1,
  x9 = Object.prototype,
  w9 = x9.hasOwnProperty
function S9(e, t, n, r, i, o) {
  var a = n & b9,
    s = bw(e),
    l = s.length,
    u = bw(t),
    f = u.length
  if (l != f && !a) return !1
  for (var c = l; c--; ) {
    var d = s[c]
    if (!(a ? d in t : w9.call(t, d))) return !1
  }
  var p = o.get(e),
    h = o.get(t)
  if (p && h) return p == t && h == e
  var m = !0
  o.set(e, t), o.set(t, e)
  for (var b = a; ++c < l; ) {
    d = s[c]
    var g = e[d],
      v = t[d]
    if (r) var y = a ? r(v, g, d, t, e, o) : r(g, v, d, e, t, o)
    if (!(y === void 0 ? g === v || i(g, v, n, r, o) : y)) {
      m = !1
      break
    }
    b || (b = d == "constructor")
  }
  if (m && !b) {
    var w = e.constructor,
      x = t.constructor
    w != x &&
      "constructor" in e &&
      "constructor" in t &&
      !(
        typeof w == "function" &&
        w instanceof w &&
        typeof x == "function" &&
        x instanceof x
      ) &&
      (m = !1)
  }
  return o.delete(e), o.delete(t), m
}
var O9 = S9,
  P9 = so,
  $9 = Jn,
  A9 = P9($9, "DataView"),
  T9 = A9,
  E9 = so,
  C9 = Jn,
  _9 = E9(C9, "Promise"),
  k9 = _9,
  M9 = so,
  j9 = Jn,
  D9 = M9(j9, "Set"),
  t_ = D9,
  I9 = so,
  N9 = Jn,
  R9 = I9(N9, "WeakMap"),
  L9 = R9,
  Pv = T9,
  $v = Yy,
  Av = k9,
  Tv = t_,
  Ev = L9,
  n_ = Cr,
  Ia = uC,
  xw = "[object Map]",
  B9 = "[object Object]",
  ww = "[object Promise]",
  Sw = "[object Set]",
  Ow = "[object WeakMap]",
  Pw = "[object DataView]",
  F9 = Ia(Pv),
  V9 = Ia($v),
  z9 = Ia(Av),
  U9 = Ia(Tv),
  W9 = Ia(Ev),
  Di = n_
;((Pv && Di(new Pv(new ArrayBuffer(1))) != Pw) ||
  ($v && Di(new $v()) != xw) ||
  (Av && Di(Av.resolve()) != ww) ||
  (Tv && Di(new Tv()) != Sw) ||
  (Ev && Di(new Ev()) != Ow)) &&
  (Di = function (e) {
    var t = n_(e),
      n = t == B9 ? e.constructor : void 0,
      r = n ? Ia(n) : ""
    if (r)
      switch (r) {
        case F9:
          return Pw
        case V9:
          return xw
        case z9:
          return ww
        case U9:
          return Sw
        case W9:
          return Ow
      }
    return t
  })
var H9 = Di,
  Ph = WC,
  G9 = qC,
  K9 = P7,
  q9 = O9,
  $w = H9,
  Aw = Ut,
  Tw = QC,
  X9 = JC,
  Y9 = 1,
  Ew = "[object Arguments]",
  Cw = "[object Array]",
  Xu = "[object Object]",
  Q9 = Object.prototype,
  _w = Q9.hasOwnProperty
function Z9(e, t, n, r, i, o) {
  var a = Aw(e),
    s = Aw(t),
    l = a ? Cw : $w(e),
    u = s ? Cw : $w(t)
  ;(l = l == Ew ? Xu : l), (u = u == Ew ? Xu : u)
  var f = l == Xu,
    c = u == Xu,
    d = l == u
  if (d && Tw(e)) {
    if (!Tw(t)) return !1
    ;(a = !0), (f = !1)
  }
  if (d && !f)
    return (
      o || (o = new Ph()),
      a || X9(e) ? G9(e, t, n, r, i, o) : K9(e, t, l, n, r, i, o)
    )
  if (!(n & Y9)) {
    var p = f && _w.call(e, "__wrapped__"),
      h = c && _w.call(t, "__wrapped__")
    if (p || h) {
      var m = p ? e.value() : e,
        b = h ? t.value() : t
      return o || (o = new Ph()), i(m, b, n, r, o)
    }
  }
  return d ? (o || (o = new Ph()), q9(e, t, n, r, i, o)) : !1
}
var J9 = Z9,
  eW = J9,
  kw = _r
function r_(e, t, n, r, i) {
  return e === t
    ? !0
    : e == null || t == null || (!kw(e) && !kw(t))
      ? e !== e && t !== t
      : eW(e, t, n, r, r_, i)
}
var m0 = r_,
  tW = WC,
  nW = m0,
  rW = 1,
  iW = 2
function oW(e, t, n, r) {
  var i = n.length,
    o = i,
    a = !r
  if (e == null) return !o
  for (e = Object(e); i--; ) {
    var s = n[i]
    if (a && s[2] ? s[1] !== e[s[0]] : !(s[0] in e)) return !1
  }
  for (; ++i < o; ) {
    s = n[i]
    var l = s[0],
      u = e[l],
      f = s[1]
    if (a && s[2]) {
      if (u === void 0 && !(l in e)) return !1
    } else {
      var c = new tW()
      if (r) var d = r(u, f, l, e, t, c)
      if (!(d === void 0 ? nW(f, u, rW | iW, r, c) : d)) return !1
    }
  }
  return !0
}
var aW = oW,
  sW = wi
function lW(e) {
  return e === e && !sW(e)
}
var i_ = lW,
  uW = i_,
  cW = Jd
function fW(e) {
  for (var t = cW(e), n = t.length; n--; ) {
    var r = t[n],
      i = e[r]
    t[n] = [r, i, uW(i)]
  }
  return t
}
var dW = fW
function pW(e, t) {
  return function (n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n))
  }
}
var o_ = pW,
  hW = aW,
  mW = dW,
  vW = o_
function gW(e) {
  var t = mW(e)
  return t.length == 1 && t[0][2]
    ? vW(t[0][0], t[0][1])
    : function (n) {
        return n === e || hW(n, e, t)
      }
}
var yW = gW
function bW(e, t) {
  return e != null && t in Object(e)
}
var xW = bW,
  wW = pC,
  SW = d0,
  OW = Ut,
  PW = p0,
  $W = h0,
  AW = Nd
function TW(e, t, n) {
  t = wW(t, e)
  for (var r = -1, i = t.length, o = !1; ++r < i; ) {
    var a = AW(t[r])
    if (!(o = e != null && n(e, a))) break
    e = e[a]
  }
  return o || ++r != i
    ? o
    : ((i = e == null ? 0 : e.length),
      !!i && $W(i) && PW(a, i) && (OW(e) || SW(e)))
}
var EW = TW,
  CW = xW,
  _W = EW
function kW(e, t) {
  return e != null && _W(e, t, CW)
}
var MW = kW,
  jW = m0,
  DW = hC,
  IW = MW,
  NW = Ky,
  RW = i_,
  LW = o_,
  BW = Nd,
  FW = 1,
  VW = 2
function zW(e, t) {
  return NW(e) && RW(t)
    ? LW(BW(e), t)
    : function (n) {
        var r = DW(n, e)
        return r === void 0 && r === t ? IW(n, e) : jW(t, r, FW | VW)
      }
}
var UW = zW
function WW(e) {
  return e
}
var Na = WW
function HW(e) {
  return function (t) {
    return t == null ? void 0 : t[e]
  }
}
var GW = HW,
  KW = e0
function qW(e) {
  return function (t) {
    return KW(t, e)
  }
}
var XW = qW,
  YW = GW,
  QW = XW,
  ZW = Ky,
  JW = Nd
function eH(e) {
  return ZW(e) ? YW(JW(e)) : QW(e)
}
var tH = eH,
  nH = yW,
  rH = UW,
  iH = Na,
  oH = Ut,
  aH = tH
function sH(e) {
  return typeof e == "function"
    ? e
    : e == null
      ? iH
      : typeof e == "object"
        ? oH(e)
          ? rH(e[0], e[1])
          : nH(e)
        : aH(e)
}
var Si = sH
function lH(e, t, n, r) {
  for (var i = e.length, o = n + (r ? 1 : -1); r ? o-- : ++o < i; )
    if (t(e[o], o, e)) return o
  return -1
}
var a_ = lH
function uH(e) {
  return e !== e
}
var cH = uH
function fH(e, t, n) {
  for (var r = n - 1, i = e.length; ++r < i; ) if (e[r] === t) return r
  return -1
}
var dH = fH,
  pH = a_,
  hH = cH,
  mH = dH
function vH(e, t, n) {
  return t === t ? mH(e, t, n) : pH(e, hH, n)
}
var gH = vH,
  yH = gH
function bH(e, t) {
  var n = e == null ? 0 : e.length
  return !!n && yH(e, t, 0) > -1
}
var xH = bH
function wH(e, t, n) {
  for (var r = -1, i = e == null ? 0 : e.length; ++r < i; )
    if (n(t, e[r])) return !0
  return !1
}
var SH = wH
function OH() {}
var PH = OH,
  $h = t_,
  $H = PH,
  AH = f0,
  TH = 1 / 0,
  EH =
    $h && 1 / AH(new $h([, -0]))[1] == TH
      ? function (e) {
          return new $h(e)
        }
      : $H,
  CH = EH,
  _H = HC,
  kH = xH,
  MH = SH,
  jH = KC,
  DH = CH,
  IH = f0,
  NH = 200
function RH(e, t, n) {
  var r = -1,
    i = kH,
    o = e.length,
    a = !0,
    s = [],
    l = s
  if (n) (a = !1), (i = MH)
  else if (o >= NH) {
    var u = t ? null : DH(e)
    if (u) return IH(u)
    ;(a = !1), (i = jH), (l = new _H())
  } else l = t ? [] : s
  e: for (; ++r < o; ) {
    var f = e[r],
      c = t ? t(f) : f
    if (((f = n || f !== 0 ? f : 0), a && c === c)) {
      for (var d = l.length; d--; ) if (l[d] === c) continue e
      t && l.push(c), s.push(f)
    } else i(l, c, n) || (l !== s && l.push(c), s.push(f))
  }
  return s
}
var LH = RH,
  BH = Si,
  FH = LH
function VH(e, t) {
  return e && e.length ? FH(e, BH(t)) : []
}
var zH = VH
const Mw = Pe(zH)
function s_(e, t, n) {
  return t === !0 ? Mw(e, n) : ce(t) ? Mw(e, t) : e
}
function ua(e) {
  "@babel/helpers - typeof"
  return (
    (ua =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    ua(e)
  )
}
var UH = ["ref"]
function jw(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Ei(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? jw(Object(n), !0).forEach(function (r) {
          ep(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : jw(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function WH(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function Dw(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, u_(r.key), r)
  }
}
function HH(e, t, n) {
  return (
    t && Dw(e.prototype, t),
    n && Dw(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function GH(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 }
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && Cv(e, t)
}
function Cv(e, t) {
  return (
    (Cv = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r
        }),
    Cv(e, t)
  )
}
function KH(e) {
  var t = XH()
  return function () {
    var r = wf(e),
      i
    if (t) {
      var o = wf(this).constructor
      i = Reflect.construct(r, arguments, o)
    } else i = r.apply(this, arguments)
    return qH(this, i)
  }
}
function qH(e, t) {
  if (t && (ua(t) === "object" || typeof t == "function")) return t
  if (t !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return l_(e)
}
function l_(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return e
}
function XH() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function wf(e) {
  return (
    (wf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n)
        }),
    wf(e)
  )
}
function ep(e, t, n) {
  return (
    (t = u_(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function u_(e) {
  var t = YH(e, "string")
  return ua(t) === "symbol" ? t : String(t)
}
function YH(e, t) {
  if (ua(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (ua(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function QH(e, t) {
  if (e == null) return {}
  var n = ZH(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function ZH(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function JH(e) {
  return e.value
}
function eG(e, t) {
  if (E.isValidElement(e)) return E.cloneElement(e, t)
  if (typeof e == "function") return E.createElement(e, t)
  t.ref
  var n = QH(t, UH)
  return E.createElement(c0, n)
}
var Iw = 1,
  ll = (function (e) {
    GH(n, e)
    var t = KH(n)
    function n() {
      var r
      WH(this, n)
      for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)
        o[a] = arguments[a]
      return (
        (r = t.call.apply(t, [this].concat(o))),
        ep(l_(r), "lastBoundingBox", { width: -1, height: -1 }),
        r
      )
    }
    return (
      HH(
        n,
        [
          {
            key: "componentDidMount",
            value: function () {
              this.updateBBox()
            }
          },
          {
            key: "componentDidUpdate",
            value: function () {
              this.updateBBox()
            }
          },
          {
            key: "getBBox",
            value: function () {
              return this.wrapperNode && this.wrapperNode.getBoundingClientRect
                ? this.wrapperNode.getBoundingClientRect()
                : null
            }
          },
          {
            key: "updateBBox",
            value: function () {
              var i = this.props.onBBoxUpdate
              if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
                var o = this.wrapperNode.getBoundingClientRect()
                ;(Math.abs(o.width - this.lastBoundingBox.width) > Iw ||
                  Math.abs(o.height - this.lastBoundingBox.height) > Iw) &&
                  ((this.lastBoundingBox.width = o.width),
                  (this.lastBoundingBox.height = o.height),
                  i && i(o))
              } else
                (this.lastBoundingBox.width !== -1 ||
                  this.lastBoundingBox.height !== -1) &&
                  ((this.lastBoundingBox.width = -1),
                  (this.lastBoundingBox.height = -1),
                  i && i(null))
            }
          },
          {
            key: "getBBoxSnapshot",
            value: function () {
              return this.lastBoundingBox.width >= 0 &&
                this.lastBoundingBox.height >= 0
                ? Ei({}, this.lastBoundingBox)
                : { width: 0, height: 0 }
            }
          },
          {
            key: "getDefaultPosition",
            value: function (i) {
              var o = this.props,
                a = o.layout,
                s = o.align,
                l = o.verticalAlign,
                u = o.margin,
                f = o.chartWidth,
                c = o.chartHeight,
                d,
                p
              if (
                !i ||
                ((i.left === void 0 || i.left === null) &&
                  (i.right === void 0 || i.right === null))
              )
                if (s === "center" && a === "vertical") {
                  var h = this.getBBoxSnapshot()
                  d = { left: ((f || 0) - h.width) / 2 }
                } else
                  d =
                    s === "right"
                      ? { right: (u && u.right) || 0 }
                      : { left: (u && u.left) || 0 }
              if (
                !i ||
                ((i.top === void 0 || i.top === null) &&
                  (i.bottom === void 0 || i.bottom === null))
              )
                if (l === "middle") {
                  var m = this.getBBoxSnapshot()
                  p = { top: ((c || 0) - m.height) / 2 }
                } else
                  p =
                    l === "bottom"
                      ? { bottom: (u && u.bottom) || 0 }
                      : { top: (u && u.top) || 0 }
              return Ei(Ei({}, d), p)
            }
          },
          {
            key: "render",
            value: function () {
              var i = this,
                o = this.props,
                a = o.content,
                s = o.width,
                l = o.height,
                u = o.wrapperStyle,
                f = o.payloadUniqBy,
                c = o.payload,
                d = Ei(
                  Ei(
                    {
                      position: "absolute",
                      width: s || "auto",
                      height: l || "auto"
                    },
                    this.getDefaultPosition(u)
                  ),
                  u
                )
              return E.createElement(
                "div",
                {
                  className: "recharts-legend-wrapper",
                  style: d,
                  ref: function (h) {
                    i.wrapperNode = h
                  }
                },
                eG(a, Ei(Ei({}, this.props), {}, { payload: s_(c, f, JH) }))
              )
            }
          }
        ],
        [
          {
            key: "getWithHeight",
            value: function (i, o) {
              var a = i.props.layout
              return a === "vertical" && G(i.props.height)
                ? { height: i.props.height }
                : a === "horizontal"
                  ? { width: i.props.width || o }
                  : null
            }
          }
        ]
      ),
      n
    )
  })(P.PureComponent)
ep(ll, "displayName", "Legend")
ep(ll, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "bottom"
})
var Nw = ru,
  tG = d0,
  nG = Ut,
  Rw = Nw ? Nw.isConcatSpreadable : void 0
function rG(e) {
  return nG(e) || tG(e) || !!(Rw && e && e[Rw])
}
var iG = rG,
  oG = XC,
  aG = iG
function c_(e, t, n, r, i) {
  var o = -1,
    a = e.length
  for (n || (n = aG), i || (i = []); ++o < a; ) {
    var s = e[o]
    t > 0 && n(s)
      ? t > 1
        ? c_(s, t - 1, n, r, i)
        : oG(i, s)
      : r || (i[i.length] = s)
  }
  return i
}
var f_ = c_
function sG(e) {
  return function (t, n, r) {
    for (var i = -1, o = Object(t), a = r(t), s = a.length; s--; ) {
      var l = a[e ? s : ++i]
      if (n(o[l], l, o) === !1) break
    }
    return t
  }
}
var lG = sG,
  uG = lG,
  cG = uG(),
  fG = cG,
  dG = fG,
  pG = Jd
function hG(e, t) {
  return e && dG(e, t, pG)
}
var d_ = hG,
  mG = au
function vG(e, t) {
  return function (n, r) {
    if (n == null) return n
    if (!mG(n)) return e(n, r)
    for (
      var i = n.length, o = t ? i : -1, a = Object(n);
      (t ? o-- : ++o < i) && r(a[o], o, a) !== !1;

    );
    return n
  }
}
var gG = vG,
  yG = d_,
  bG = gG,
  xG = bG(yG),
  v0 = xG,
  wG = v0,
  SG = au
function OG(e, t) {
  var n = -1,
    r = SG(e) ? Array(e.length) : []
  return (
    wG(e, function (i, o, a) {
      r[++n] = t(i, o, a)
    }),
    r
  )
}
var p_ = OG
function PG(e, t) {
  var n = e.length
  for (e.sort(t); n--; ) e[n] = e[n].value
  return e
}
var $G = PG,
  Lw = Ca
function AG(e, t) {
  if (e !== t) {
    var n = e !== void 0,
      r = e === null,
      i = e === e,
      o = Lw(e),
      a = t !== void 0,
      s = t === null,
      l = t === t,
      u = Lw(t)
    if (
      (!s && !u && !o && e > t) ||
      (o && a && l && !s && !u) ||
      (r && a && l) ||
      (!n && l) ||
      !i
    )
      return 1
    if (
      (!r && !o && !u && e < t) ||
      (u && n && i && !r && !o) ||
      (s && n && i) ||
      (!a && i) ||
      !l
    )
      return -1
  }
  return 0
}
var TG = AG,
  EG = TG
function CG(e, t, n) {
  for (
    var r = -1, i = e.criteria, o = t.criteria, a = i.length, s = n.length;
    ++r < a;

  ) {
    var l = EG(i[r], o[r])
    if (l) {
      if (r >= s) return l
      var u = n[r]
      return l * (u == "desc" ? -1 : 1)
    }
  }
  return e.index - t.index
}
var _G = CG,
  Ah = Jy,
  kG = e0,
  MG = Si,
  jG = p_,
  DG = $G,
  IG = ZC,
  NG = _G,
  RG = Na,
  LG = Ut
function BG(e, t, n) {
  t.length
    ? (t = Ah(t, function (o) {
        return LG(o)
          ? function (a) {
              return kG(a, o.length === 1 ? o[0] : o)
            }
          : o
      }))
    : (t = [RG])
  var r = -1
  t = Ah(t, IG(MG))
  var i = jG(e, function (o, a, s) {
    var l = Ah(t, function (u) {
      return u(o)
    })
    return { criteria: l, index: ++r, value: o }
  })
  return DG(i, function (o, a) {
    return NG(o, a, n)
  })
}
var FG = BG
function VG(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t)
    case 1:
      return e.call(t, n[0])
    case 2:
      return e.call(t, n[0], n[1])
    case 3:
      return e.call(t, n[0], n[1], n[2])
  }
  return e.apply(t, n)
}
var zG = VG,
  UG = zG,
  Bw = Math.max
function WG(e, t, n) {
  return (
    (t = Bw(t === void 0 ? e.length - 1 : t, 0)),
    function () {
      for (
        var r = arguments, i = -1, o = Bw(r.length - t, 0), a = Array(o);
        ++i < o;

      )
        a[i] = r[t + i]
      i = -1
      for (var s = Array(t + 1); ++i < t; ) s[i] = r[i]
      return (s[t] = n(a)), UG(e, this, s)
    }
  )
}
var HG = WG
function GG(e) {
  return function () {
    return e
  }
}
var KG = GG,
  qG = so,
  XG = (function () {
    try {
      var e = qG(Object, "defineProperty")
      return e({}, "", {}), e
    } catch {}
  })(),
  h_ = XG,
  YG = KG,
  Fw = h_,
  QG = Na,
  ZG = Fw
    ? function (e, t) {
        return Fw(e, "toString", {
          configurable: !0,
          enumerable: !1,
          value: YG(t),
          writable: !0
        })
      }
    : QG,
  JG = ZG,
  eK = 800,
  tK = 16,
  nK = Date.now
function rK(e) {
  var t = 0,
    n = 0
  return function () {
    var r = nK(),
      i = tK - (r - n)
    if (((n = r), i > 0)) {
      if (++t >= eK) return arguments[0]
    } else t = 0
    return e.apply(void 0, arguments)
  }
}
var iK = rK,
  oK = JG,
  aK = iK,
  sK = aK(oK),
  lK = sK,
  uK = Na,
  cK = HG,
  fK = lK
function dK(e, t) {
  return fK(cK(e, t, uK), e + "")
}
var pK = dK,
  hK = Xy,
  mK = au,
  vK = p0,
  gK = wi
function yK(e, t, n) {
  if (!gK(n)) return !1
  var r = typeof t
  return (r == "number" ? mK(n) && vK(t, n.length) : r == "string" && t in n)
    ? hK(n[t], e)
    : !1
}
var tp = yK,
  bK = f_,
  xK = FG,
  wK = pK,
  Vw = tp,
  SK = wK(function (e, t) {
    if (e == null) return []
    var n = t.length
    return (
      n > 1 && Vw(e, t[0], t[1])
        ? (t = [])
        : n > 2 && Vw(t[0], t[1], t[2]) && (t = [t[0]]),
      xK(e, bK(t, 1), [])
    )
  }),
  OK = SK
const g0 = Pe(OK)
function ul(e) {
  "@babel/helpers - typeof"
  return (
    (ul =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    ul(e)
  )
}
function PK(e, t) {
  return EK(e) || TK(e, t) || AK(e, t) || $K()
}
function $K() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function AK(e, t) {
  if (e) {
    if (typeof e == "string") return zw(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return zw(e, t)
  }
}
function zw(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function TK(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function EK(e) {
  if (Array.isArray(e)) return e
}
function Uw(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Th(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? Uw(Object(n), !0).forEach(function (r) {
          CK(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : Uw(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function CK(e, t, n) {
  return (
    (t = _K(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function _K(e) {
  var t = kK(e, "string")
  return ul(t) === "symbol" ? t : String(t)
}
function kK(e, t) {
  if (ul(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (ul(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function MK(e) {
  return Array.isArray(e) && it(e[0]) && it(e[1]) ? e.join(" ~ ") : e
}
var jK = function (t) {
    var n = t.separator,
      r = n === void 0 ? " : " : n,
      i = t.contentStyle,
      o = i === void 0 ? {} : i,
      a = t.itemStyle,
      s = a === void 0 ? {} : a,
      l = t.labelStyle,
      u = l === void 0 ? {} : l,
      f = t.payload,
      c = t.formatter,
      d = t.itemSorter,
      p = t.wrapperClassName,
      h = t.labelClassName,
      m = t.label,
      b = t.labelFormatter,
      g = function () {
        if (f && f.length) {
          var A = { padding: 0, margin: 0 },
            C = (d ? g0(f, d) : f).map(function (T, _) {
              if (T.type === "none") return null
              var R = Th(
                  {
                    display: "block",
                    paddingTop: 4,
                    paddingBottom: 4,
                    color: T.color || "#000"
                  },
                  s
                ),
                M = T.formatter || c || MK,
                D = T.value,
                N = T.name,
                L = D,
                k = N
              if (M && L != null && k != null) {
                var I = M(D, N, T, _, f)
                if (Array.isArray(I)) {
                  var V = PK(I, 2)
                  ;(L = V[0]), (k = V[1])
                } else L = I
              }
              return E.createElement(
                "li",
                {
                  className: "recharts-tooltip-item",
                  key: "tooltip-item-".concat(_),
                  style: R
                },
                it(k)
                  ? E.createElement(
                      "span",
                      { className: "recharts-tooltip-item-name" },
                      k
                    )
                  : null,
                it(k)
                  ? E.createElement(
                      "span",
                      { className: "recharts-tooltip-item-separator" },
                      r
                    )
                  : null,
                E.createElement(
                  "span",
                  { className: "recharts-tooltip-item-value" },
                  L
                ),
                E.createElement(
                  "span",
                  { className: "recharts-tooltip-item-unit" },
                  T.unit || ""
                )
              )
            })
          return E.createElement(
            "ul",
            { className: "recharts-tooltip-item-list", style: A },
            C
          )
        }
        return null
      },
      v = Th(
        {
          margin: 0,
          padding: 10,
          backgroundColor: "#fff",
          border: "1px solid #ccc",
          whiteSpace: "nowrap"
        },
        o
      ),
      y = Th({ margin: 0 }, u),
      w = !xe(m),
      x = w ? m : "",
      S = Oe("recharts-default-tooltip", p),
      O = Oe("recharts-tooltip-label", h)
    return (
      w && b && f !== void 0 && f !== null && (x = b(m, f)),
      E.createElement(
        "div",
        { className: S, style: v },
        E.createElement(
          "p",
          { className: O, style: y },
          E.isValidElement(x) ? x : "".concat(x)
        ),
        g()
      )
    )
  },
  m_ = { exports: {} },
  DK = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  IK = DK,
  NK = IK
function v_() {}
function g_() {}
g_.resetWarningCache = v_
var RK = function () {
  function e(r, i, o, a, s, l) {
    if (l !== NK) {
      var u = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      )
      throw ((u.name = "Invariant Violation"), u)
    }
  }
  e.isRequired = e
  function t() {
    return e
  }
  var n = {
    array: e,
    bigint: e,
    bool: e,
    func: e,
    number: e,
    object: e,
    string: e,
    symbol: e,
    any: e,
    arrayOf: t,
    element: e,
    elementType: e,
    instanceOf: t,
    node: e,
    objectOf: t,
    oneOf: t,
    oneOfType: t,
    shape: t,
    exact: t,
    checkPropTypes: g_,
    resetWarningCache: v_
  }
  return (n.PropTypes = n), n
}
m_.exports = RK()
var LK = m_.exports
const ie = Pe(LK)
var BK = Object.getOwnPropertyNames,
  FK = Object.getOwnPropertySymbols,
  VK = Object.prototype.hasOwnProperty
function Ww(e, t) {
  return function (r, i, o) {
    return e(r, i, o) && t(r, i, o)
  }
}
function Yu(e) {
  return function (n, r, i) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return e(n, r, i)
    var o = i.cache,
      a = o.get(n),
      s = o.get(r)
    if (a && s) return a === r && s === n
    o.set(n, r), o.set(r, n)
    var l = e(n, r, i)
    return o.delete(n), o.delete(r), l
  }
}
function Hw(e) {
  return BK(e).concat(FK(e))
}
var y_ =
  Object.hasOwn ||
  function (e, t) {
    return VK.call(e, t)
  }
function Ra(e, t) {
  return e || t ? e === t : e === t || (e !== e && t !== t)
}
var b_ = "_owner",
  Gw = Object.getOwnPropertyDescriptor,
  Kw = Object.keys
function zK(e, t, n) {
  var r = e.length
  if (t.length !== r) return !1
  for (; r-- > 0; ) if (!n.equals(e[r], t[r], r, r, e, t, n)) return !1
  return !0
}
function UK(e, t) {
  return Ra(e.getTime(), t.getTime())
}
function qw(e, t, n) {
  if (e.size !== t.size) return !1
  for (var r = {}, i = e.entries(), o = 0, a, s; (a = i.next()) && !a.done; ) {
    for (var l = t.entries(), u = !1, f = 0; (s = l.next()) && !s.done; ) {
      var c = a.value,
        d = c[0],
        p = c[1],
        h = s.value,
        m = h[0],
        b = h[1]
      !u &&
        !r[f] &&
        (u = n.equals(d, m, o, f, e, t, n) && n.equals(p, b, d, m, e, t, n)) &&
        (r[f] = !0),
        f++
    }
    if (!u) return !1
    o++
  }
  return !0
}
function WK(e, t, n) {
  var r = Kw(e),
    i = r.length
  if (Kw(t).length !== i) return !1
  for (var o; i-- > 0; )
    if (
      ((o = r[i]),
      (o === b_ && (e.$$typeof || t.$$typeof) && e.$$typeof !== t.$$typeof) ||
        !y_(t, o) ||
        !n.equals(e[o], t[o], o, o, e, t, n))
    )
      return !1
  return !0
}
function is(e, t, n) {
  var r = Hw(e),
    i = r.length
  if (Hw(t).length !== i) return !1
  for (var o, a, s; i-- > 0; )
    if (
      ((o = r[i]),
      (o === b_ && (e.$$typeof || t.$$typeof) && e.$$typeof !== t.$$typeof) ||
        !y_(t, o) ||
        !n.equals(e[o], t[o], o, o, e, t, n) ||
        ((a = Gw(e, o)),
        (s = Gw(t, o)),
        (a || s) &&
          (!a ||
            !s ||
            a.configurable !== s.configurable ||
            a.enumerable !== s.enumerable ||
            a.writable !== s.writable)))
    )
      return !1
  return !0
}
function HK(e, t) {
  return Ra(e.valueOf(), t.valueOf())
}
function GK(e, t) {
  return e.source === t.source && e.flags === t.flags
}
function Xw(e, t, n) {
  if (e.size !== t.size) return !1
  for (var r = {}, i = e.values(), o, a; (o = i.next()) && !o.done; ) {
    for (var s = t.values(), l = !1, u = 0; (a = s.next()) && !a.done; )
      !l &&
        !r[u] &&
        (l = n.equals(o.value, a.value, o.value, a.value, e, t, n)) &&
        (r[u] = !0),
        u++
    if (!l) return !1
  }
  return !0
}
function KK(e, t) {
  var n = e.length
  if (t.length !== n) return !1
  for (; n-- > 0; ) if (e[n] !== t[n]) return !1
  return !0
}
var qK = "[object Arguments]",
  XK = "[object Boolean]",
  YK = "[object Date]",
  QK = "[object Map]",
  ZK = "[object Number]",
  JK = "[object Object]",
  eq = "[object RegExp]",
  tq = "[object Set]",
  nq = "[object String]",
  rq = Array.isArray,
  Yw =
    typeof ArrayBuffer == "function" && ArrayBuffer.isView
      ? ArrayBuffer.isView
      : null,
  Qw = Object.assign,
  iq = Object.prototype.toString.call.bind(Object.prototype.toString)
function oq(e) {
  var t = e.areArraysEqual,
    n = e.areDatesEqual,
    r = e.areMapsEqual,
    i = e.areObjectsEqual,
    o = e.arePrimitiveWrappersEqual,
    a = e.areRegExpsEqual,
    s = e.areSetsEqual,
    l = e.areTypedArraysEqual
  return function (f, c, d) {
    if (f === c) return !0
    if (f == null || c == null || typeof f != "object" || typeof c != "object")
      return f !== f && c !== c
    var p = f.constructor
    if (p !== c.constructor) return !1
    if (p === Object) return i(f, c, d)
    if (rq(f)) return t(f, c, d)
    if (Yw != null && Yw(f)) return l(f, c, d)
    if (p === Date) return n(f, c, d)
    if (p === RegExp) return a(f, c, d)
    if (p === Map) return r(f, c, d)
    if (p === Set) return s(f, c, d)
    var h = iq(f)
    return h === YK
      ? n(f, c, d)
      : h === eq
        ? a(f, c, d)
        : h === QK
          ? r(f, c, d)
          : h === tq
            ? s(f, c, d)
            : h === JK
              ? typeof f.then != "function" &&
                typeof c.then != "function" &&
                i(f, c, d)
              : h === qK
                ? i(f, c, d)
                : h === XK || h === ZK || h === nq
                  ? o(f, c, d)
                  : !1
  }
}
function aq(e) {
  var t = e.circular,
    n = e.createCustomConfig,
    r = e.strict,
    i = {
      areArraysEqual: r ? is : zK,
      areDatesEqual: UK,
      areMapsEqual: r ? Ww(qw, is) : qw,
      areObjectsEqual: r ? is : WK,
      arePrimitiveWrappersEqual: HK,
      areRegExpsEqual: GK,
      areSetsEqual: r ? Ww(Xw, is) : Xw,
      areTypedArraysEqual: r ? is : KK
    }
  if ((n && (i = Qw({}, i, n(i))), t)) {
    var o = Yu(i.areArraysEqual),
      a = Yu(i.areMapsEqual),
      s = Yu(i.areObjectsEqual),
      l = Yu(i.areSetsEqual)
    i = Qw({}, i, {
      areArraysEqual: o,
      areMapsEqual: a,
      areObjectsEqual: s,
      areSetsEqual: l
    })
  }
  return i
}
function sq(e) {
  return function (t, n, r, i, o, a, s) {
    return e(t, n, s)
  }
}
function lq(e) {
  var t = e.circular,
    n = e.comparator,
    r = e.createState,
    i = e.equals,
    o = e.strict
  if (r)
    return function (l, u) {
      var f = r(),
        c = f.cache,
        d = c === void 0 ? (t ? new WeakMap() : void 0) : c,
        p = f.meta
      return n(l, u, { cache: d, equals: i, meta: p, strict: o })
    }
  if (t)
    return function (l, u) {
      return n(l, u, {
        cache: new WeakMap(),
        equals: i,
        meta: void 0,
        strict: o
      })
    }
  var a = { cache: void 0, equals: i, meta: void 0, strict: o }
  return function (l, u) {
    return n(l, u, a)
  }
}
var uq = Oi()
Oi({ strict: !0 })
Oi({ circular: !0 })
Oi({ circular: !0, strict: !0 })
Oi({
  createInternalComparator: function () {
    return Ra
  }
})
Oi({
  strict: !0,
  createInternalComparator: function () {
    return Ra
  }
})
Oi({
  circular: !0,
  createInternalComparator: function () {
    return Ra
  }
})
Oi({
  circular: !0,
  createInternalComparator: function () {
    return Ra
  },
  strict: !0
})
function Oi(e) {
  e === void 0 && (e = {})
  var t = e.circular,
    n = t === void 0 ? !1 : t,
    r = e.createInternalComparator,
    i = e.createState,
    o = e.strict,
    a = o === void 0 ? !1 : o,
    s = aq(e),
    l = oq(s),
    u = r ? r(l) : sq(l)
  return lq({
    circular: n,
    comparator: l,
    createState: i,
    equals: u,
    strict: a
  })
}
function cq(e) {
  typeof requestAnimationFrame < "u" && requestAnimationFrame(e)
}
function Zw(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    n = -1,
    r = function i(o) {
      n < 0 && (n = o), o - n > t ? (e(o), (n = -1)) : cq(i)
    }
  requestAnimationFrame(r)
}
function _v(e) {
  "@babel/helpers - typeof"
  return (
    (_v =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    _v(e)
  )
}
function fq(e) {
  return mq(e) || hq(e) || pq(e) || dq()
}
function dq() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function pq(e, t) {
  if (e) {
    if (typeof e == "string") return Jw(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Jw(e, t)
  }
}
function Jw(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function hq(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function mq(e) {
  if (Array.isArray(e)) return e
}
function vq() {
  var e = {},
    t = function () {
      return null
    },
    n = !1,
    r = function i(o) {
      if (!n) {
        if (Array.isArray(o)) {
          if (!o.length) return
          var a = o,
            s = fq(a),
            l = s[0],
            u = s.slice(1)
          if (typeof l == "number") {
            Zw(i.bind(null, u), l)
            return
          }
          i(l), Zw(i.bind(null, u))
          return
        }
        _v(o) === "object" && ((e = o), t(e)), typeof o == "function" && o()
      }
    }
  return {
    stop: function () {
      n = !0
    },
    start: function (o) {
      ;(n = !1), r(o)
    },
    subscribe: function (o) {
      return (
        (t = o),
        function () {
          t = function () {
            return null
          }
        }
      )
    }
  }
}
function cl(e) {
  "@babel/helpers - typeof"
  return (
    (cl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    cl(e)
  )
}
function eS(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function ca(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? eS(Object(n), !0).forEach(function (r) {
          Sf(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : eS(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Sf(e, t, n) {
  return (
    (t = gq(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function gq(e) {
  var t = yq(e, "string")
  return cl(t) === "symbol" ? t : String(t)
}
function yq(e, t) {
  if (cl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (cl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var bq = ["Webkit", "Moz", "O", "ms"],
  xq = ["-webkit-", "-moz-", "-o-", "-ms-"],
  wq = ["transform", "transformOrigin", "transition"],
  Sq = function (t, n) {
    return [Object.keys(t), Object.keys(n)].reduce(function (r, i) {
      return r.filter(function (o) {
        return i.includes(o)
      })
    })
  },
  Oq = function (t) {
    return t
  },
  Pq = function (t) {
    return t.replace(/([A-Z])/g, function (n) {
      return "-".concat(n.toLowerCase())
    })
  },
  $q = function (t, n) {
    if (wq.indexOf(t) === -1) return Sf({}, t, Number.isNaN(n) ? 0 : n)
    var r = t === "transition",
      i = t.replace(/(\w)/, function (a) {
        return a.toUpperCase()
      }),
      o = n
    return bq.reduce(function (a, s, l) {
      return (
        r &&
          (o = n.replace(
            /(transform|transform-origin)/gim,
            "".concat(xq[l], "$1")
          )),
        ca(ca({}, a), {}, Sf({}, s + i, o))
      )
    }, {})
  },
  Ds = function (t, n) {
    return Object.keys(n).reduce(function (r, i) {
      return ca(ca({}, r), {}, Sf({}, i, t(i, n[i])))
    }, {})
  },
  y0 = function (t) {
    return Object.keys(t).reduce(function (n, r) {
      return ca(ca({}, n), $q(r, n[r]))
    }, t)
  },
  tS = function (t, n, r) {
    return t
      .map(function (i) {
        return "".concat(Pq(i), " ").concat(n, "ms ").concat(r)
      })
      .join(",")
  }
function Aq(e, t) {
  return Cq(e) || Eq(e, t) || x_(e, t) || Tq()
}
function Tq() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Eq(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function Cq(e) {
  if (Array.isArray(e)) return e
}
function _q(e) {
  return jq(e) || Mq(e) || x_(e) || kq()
}
function kq() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function x_(e, t) {
  if (e) {
    if (typeof e == "string") return kv(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return kv(e, t)
  }
}
function Mq(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function jq(e) {
  if (Array.isArray(e)) return kv(e)
}
function kv(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
var Of = 1e-4,
  w_ = function (t, n) {
    return [0, 3 * t, 3 * n - 6 * t, 3 * t - 3 * n + 1]
  },
  S_ = function (t, n) {
    return t
      .map(function (r, i) {
        return r * Math.pow(n, i)
      })
      .reduce(function (r, i) {
        return r + i
      })
  },
  nS = function (t, n) {
    return function (r) {
      var i = w_(t, n)
      return S_(i, r)
    }
  },
  Dq = function (t, n) {
    return function (r) {
      var i = w_(t, n),
        o = [].concat(
          _q(
            i
              .map(function (a, s) {
                return a * s
              })
              .slice(1)
          ),
          [0]
        )
      return S_(o, r)
    }
  },
  rS = function () {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r]
    var i = n[0],
      o = n[1],
      a = n[2],
      s = n[3]
    if (n.length === 1)
      switch (n[0]) {
        case "linear":
          ;(i = 0), (o = 0), (a = 1), (s = 1)
          break
        case "ease":
          ;(i = 0.25), (o = 0.1), (a = 0.25), (s = 1)
          break
        case "ease-in":
          ;(i = 0.42), (o = 0), (a = 1), (s = 1)
          break
        case "ease-out":
          ;(i = 0.42), (o = 0), (a = 0.58), (s = 1)
          break
        case "ease-in-out":
          ;(i = 0), (o = 0), (a = 0.58), (s = 1)
          break
        default: {
          var l = n[0].split("(")
          if (
            l[0] === "cubic-bezier" &&
            l[1].split(")")[0].split(",").length === 4
          ) {
            var u = l[1]
                .split(")")[0]
                .split(",")
                .map(function (b) {
                  return parseFloat(b)
                }),
              f = Aq(u, 4)
            ;(i = f[0]), (o = f[1]), (a = f[2]), (s = f[3])
          }
        }
      }
    var c = nS(i, a),
      d = nS(o, s),
      p = Dq(i, a),
      h = function (g) {
        return g > 1 ? 1 : g < 0 ? 0 : g
      },
      m = function (g) {
        for (var v = g > 1 ? 1 : g, y = v, w = 0; w < 8; ++w) {
          var x = c(y) - v,
            S = p(y)
          if (Math.abs(x - v) < Of || S < Of) return d(y)
          y = h(y - x / S)
        }
        return d(y)
      }
    return (m.isStepper = !1), m
  },
  Iq = function () {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      n = t.stiff,
      r = n === void 0 ? 100 : n,
      i = t.damping,
      o = i === void 0 ? 8 : i,
      a = t.dt,
      s = a === void 0 ? 17 : a,
      l = function (f, c, d) {
        var p = -(f - c) * r,
          h = d * o,
          m = d + ((p - h) * s) / 1e3,
          b = (d * s) / 1e3 + f
        return Math.abs(b - c) < Of && Math.abs(m) < Of ? [c, 0] : [b, m]
      }
    return (l.isStepper = !0), (l.dt = s), l
  },
  Nq = function () {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r]
    var i = n[0]
    if (typeof i == "string")
      switch (i) {
        case "ease":
        case "ease-in-out":
        case "ease-out":
        case "ease-in":
        case "linear":
          return rS(i)
        case "spring":
          return Iq()
        default:
          if (i.split("(")[0] === "cubic-bezier") return rS(i)
      }
    return typeof i == "function" ? i : null
  }
function fl(e) {
  "@babel/helpers - typeof"
  return (
    (fl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    fl(e)
  )
}
function iS(e) {
  return Bq(e) || Lq(e) || O_(e) || Rq()
}
function Rq() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Lq(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function Bq(e) {
  if (Array.isArray(e)) return jv(e)
}
function oS(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function vt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? oS(Object(n), !0).forEach(function (r) {
          Mv(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : oS(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Mv(e, t, n) {
  return (
    (t = Fq(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Fq(e) {
  var t = Vq(e, "string")
  return fl(t) === "symbol" ? t : String(t)
}
function Vq(e, t) {
  if (fl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (fl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function zq(e, t) {
  return Hq(e) || Wq(e, t) || O_(e, t) || Uq()
}
function Uq() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function O_(e, t) {
  if (e) {
    if (typeof e == "string") return jv(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return jv(e, t)
  }
}
function jv(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function Wq(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function Hq(e) {
  if (Array.isArray(e)) return e
}
var Pf = function (t, n, r) {
    return t + (n - t) * r
  },
  Dv = function (t) {
    var n = t.from,
      r = t.to
    return n !== r
  },
  Gq = function e(t, n, r) {
    var i = Ds(function (o, a) {
      if (Dv(a)) {
        var s = t(a.from, a.to, a.velocity),
          l = zq(s, 2),
          u = l[0],
          f = l[1]
        return vt(vt({}, a), {}, { from: u, velocity: f })
      }
      return a
    }, n)
    return r < 1
      ? Ds(function (o, a) {
          return Dv(a)
            ? vt(
                vt({}, a),
                {},
                {
                  velocity: Pf(a.velocity, i[o].velocity, r),
                  from: Pf(a.from, i[o].from, r)
                }
              )
            : a
        }, n)
      : e(t, i, r - 1)
  }
const Kq = function (e, t, n, r, i) {
  var o = Sq(e, t),
    a = o.reduce(function (b, g) {
      return vt(vt({}, b), {}, Mv({}, g, [e[g], t[g]]))
    }, {}),
    s = o.reduce(function (b, g) {
      return vt(vt({}, b), {}, Mv({}, g, { from: e[g], velocity: 0, to: t[g] }))
    }, {}),
    l = -1,
    u,
    f,
    c = function () {
      return null
    },
    d = function () {
      return Ds(function (g, v) {
        return v.from
      }, s)
    },
    p = function () {
      return !Object.values(s).filter(Dv).length
    },
    h = function (g) {
      u || (u = g)
      var v = g - u,
        y = v / n.dt
      ;(s = Gq(n, s, y)),
        i(vt(vt(vt({}, e), t), d())),
        (u = g),
        p() || (l = requestAnimationFrame(c))
    },
    m = function (g) {
      f || (f = g)
      var v = (g - f) / r,
        y = Ds(function (x, S) {
          return Pf.apply(void 0, iS(S).concat([n(v)]))
        }, a)
      if ((i(vt(vt(vt({}, e), t), y)), v < 1)) l = requestAnimationFrame(c)
      else {
        var w = Ds(function (x, S) {
          return Pf.apply(void 0, iS(S).concat([n(1)]))
        }, a)
        i(vt(vt(vt({}, e), t), w))
      }
    }
  return (
    (c = n.isStepper ? h : m),
    function () {
      return (
        requestAnimationFrame(c),
        function () {
          cancelAnimationFrame(l)
        }
      )
    }
  )
}
function fa(e) {
  "@babel/helpers - typeof"
  return (
    (fa =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    fa(e)
  )
}
var qq = [
  "children",
  "begin",
  "duration",
  "attributeName",
  "easing",
  "isActive",
  "steps",
  "from",
  "to",
  "canBegin",
  "onAnimationEnd",
  "shouldReAnimate",
  "onAnimationReStart"
]
function Xq(e, t) {
  if (e == null) return {}
  var n = Yq(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function Yq(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function Eh(e) {
  return eX(e) || Jq(e) || Zq(e) || Qq()
}
function Qq() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Zq(e, t) {
  if (e) {
    if (typeof e == "string") return Iv(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Iv(e, t)
  }
}
function Jq(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function eX(e) {
  if (Array.isArray(e)) return Iv(e)
}
function Iv(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function aS(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Pn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? aS(Object(n), !0).forEach(function (r) {
          bs(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : aS(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function bs(e, t, n) {
  return (
    (t = P_(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function tX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function sS(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, P_(r.key), r)
  }
}
function nX(e, t, n) {
  return (
    t && sS(e.prototype, t),
    n && sS(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function P_(e) {
  var t = rX(e, "string")
  return fa(t) === "symbol" ? t : String(t)
}
function rX(e, t) {
  if (fa(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (fa(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function iX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 }
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && Nv(e, t)
}
function Nv(e, t) {
  return (
    (Nv = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r
        }),
    Nv(e, t)
  )
}
function oX(e) {
  var t = aX()
  return function () {
    var r = $f(e),
      i
    if (t) {
      var o = $f(this).constructor
      i = Reflect.construct(r, arguments, o)
    } else i = r.apply(this, arguments)
    return Rv(this, i)
  }
}
function Rv(e, t) {
  if (t && (fa(t) === "object" || typeof t == "function")) return t
  if (t !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return Lv(e)
}
function Lv(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return e
}
function aX() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function $f(e) {
  return (
    ($f = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n)
        }),
    $f(e)
  )
}
var pi = (function (e) {
  iX(n, e)
  var t = oX(n)
  function n(r, i) {
    var o
    tX(this, n), (o = t.call(this, r, i))
    var a = o.props,
      s = a.isActive,
      l = a.attributeName,
      u = a.from,
      f = a.to,
      c = a.steps,
      d = a.children,
      p = a.duration
    if (
      ((o.handleStyleChange = o.handleStyleChange.bind(Lv(o))),
      (o.changeStyle = o.changeStyle.bind(Lv(o))),
      !s || p <= 0)
    )
      return (
        (o.state = { style: {} }),
        typeof d == "function" && (o.state = { style: f }),
        Rv(o)
      )
    if (c && c.length) o.state = { style: c[0].style }
    else if (u) {
      if (typeof d == "function") return (o.state = { style: u }), Rv(o)
      o.state = { style: l ? bs({}, l, u) : u }
    } else o.state = { style: {} }
    return o
  }
  return (
    nX(n, [
      {
        key: "componentDidMount",
        value: function () {
          var i = this.props,
            o = i.isActive,
            a = i.canBegin
          ;(this.mounted = !0), !(!o || !a) && this.runAnimation(this.props)
        }
      },
      {
        key: "componentDidUpdate",
        value: function (i) {
          var o = this.props,
            a = o.isActive,
            s = o.canBegin,
            l = o.attributeName,
            u = o.shouldReAnimate,
            f = o.to,
            c = o.from,
            d = this.state.style
          if (s) {
            if (!a) {
              var p = { style: l ? bs({}, l, f) : f }
              this.state &&
                d &&
                ((l && d[l] !== f) || (!l && d !== f)) &&
                this.setState(p)
              return
            }
            if (!(uq(i.to, f) && i.canBegin && i.isActive)) {
              var h = !i.canBegin || !i.isActive
              this.manager && this.manager.stop(),
                this.stopJSAnimation && this.stopJSAnimation()
              var m = h || u ? c : i.to
              if (this.state && d) {
                var b = { style: l ? bs({}, l, m) : m }
                ;((l && [l] !== m) || (!l && d !== m)) && this.setState(b)
              }
              this.runAnimation(
                Pn(Pn({}, this.props), {}, { from: m, begin: 0 })
              )
            }
          }
        }
      },
      {
        key: "componentWillUnmount",
        value: function () {
          this.mounted = !1
          var i = this.props.onAnimationEnd
          this.unSubscribe && this.unSubscribe(),
            this.manager && (this.manager.stop(), (this.manager = null)),
            this.stopJSAnimation && this.stopJSAnimation(),
            i && i()
        }
      },
      {
        key: "handleStyleChange",
        value: function (i) {
          this.changeStyle(i)
        }
      },
      {
        key: "changeStyle",
        value: function (i) {
          this.mounted && this.setState({ style: i })
        }
      },
      {
        key: "runJSAnimation",
        value: function (i) {
          var o = this,
            a = i.from,
            s = i.to,
            l = i.duration,
            u = i.easing,
            f = i.begin,
            c = i.onAnimationEnd,
            d = i.onAnimationStart,
            p = Kq(a, s, Nq(u), l, this.changeStyle),
            h = function () {
              o.stopJSAnimation = p()
            }
          this.manager.start([d, f, h, l, c])
        }
      },
      {
        key: "runStepAnimation",
        value: function (i) {
          var o = this,
            a = i.steps,
            s = i.begin,
            l = i.onAnimationStart,
            u = a[0],
            f = u.style,
            c = u.duration,
            d = c === void 0 ? 0 : c,
            p = function (m, b, g) {
              if (g === 0) return m
              var v = b.duration,
                y = b.easing,
                w = y === void 0 ? "ease" : y,
                x = b.style,
                S = b.properties,
                O = b.onAnimationEnd,
                $ = g > 0 ? a[g - 1] : b,
                A = S || Object.keys(x)
              if (typeof w == "function" || w === "spring")
                return [].concat(Eh(m), [
                  o.runJSAnimation.bind(o, {
                    from: $.style,
                    to: x,
                    duration: v,
                    easing: w
                  }),
                  v
                ])
              var C = tS(A, v, w),
                T = Pn(Pn(Pn({}, $.style), x), {}, { transition: C })
              return [].concat(Eh(m), [T, v, O]).filter(Oq)
            }
          return this.manager.start(
            [l].concat(Eh(a.reduce(p, [f, Math.max(d, s)])), [i.onAnimationEnd])
          )
        }
      },
      {
        key: "runAnimation",
        value: function (i) {
          this.manager || (this.manager = vq())
          var o = i.begin,
            a = i.duration,
            s = i.attributeName,
            l = i.to,
            u = i.easing,
            f = i.onAnimationStart,
            c = i.onAnimationEnd,
            d = i.steps,
            p = i.children,
            h = this.manager
          if (
            ((this.unSubscribe = h.subscribe(this.handleStyleChange)),
            typeof u == "function" || typeof p == "function" || u === "spring")
          ) {
            this.runJSAnimation(i)
            return
          }
          if (d.length > 1) {
            this.runStepAnimation(i)
            return
          }
          var m = s ? bs({}, s, l) : l,
            b = tS(Object.keys(m), a, u)
          h.start([f, o, Pn(Pn({}, m), {}, { transition: b }), a, c])
        }
      },
      {
        key: "render",
        value: function () {
          var i = this.props,
            o = i.children
          i.begin
          var a = i.duration
          i.attributeName, i.easing
          var s = i.isActive
          i.steps,
            i.from,
            i.to,
            i.canBegin,
            i.onAnimationEnd,
            i.shouldReAnimate,
            i.onAnimationReStart
          var l = Xq(i, qq),
            u = P.Children.count(o),
            f = y0(this.state.style)
          if (typeof o == "function") return o(f)
          if (!s || u === 0 || a <= 0) return o
          var c = function (p) {
            var h = p.props,
              m = h.style,
              b = m === void 0 ? {} : m,
              g = h.className,
              v = P.cloneElement(
                p,
                Pn(Pn({}, l), {}, { style: Pn(Pn({}, b), f), className: g })
              )
            return v
          }
          return u === 1
            ? c(P.Children.only(o))
            : E.createElement(
                "div",
                null,
                P.Children.map(o, function (d) {
                  return c(d)
                })
              )
        }
      }
    ]),
    n
  )
})(P.PureComponent)
pi.displayName = "Animate"
pi.defaultProps = {
  begin: 0,
  duration: 1e3,
  from: "",
  to: "",
  attributeName: "",
  easing: "ease",
  isActive: !0,
  canBegin: !0,
  steps: [],
  onAnimationEnd: function () {},
  onAnimationStart: function () {}
}
pi.propTypes = {
  from: ie.oneOfType([ie.object, ie.string]),
  to: ie.oneOfType([ie.object, ie.string]),
  attributeName: ie.string,
  duration: ie.number,
  begin: ie.number,
  easing: ie.oneOfType([ie.string, ie.func]),
  steps: ie.arrayOf(
    ie.shape({
      duration: ie.number.isRequired,
      style: ie.object.isRequired,
      easing: ie.oneOfType([
        ie.oneOf(["ease", "ease-in", "ease-out", "ease-in-out", "linear"]),
        ie.func
      ]),
      properties: ie.arrayOf("string"),
      onAnimationEnd: ie.func
    })
  ),
  children: ie.oneOfType([ie.node, ie.func]),
  isActive: ie.bool,
  canBegin: ie.bool,
  onAnimationEnd: ie.func,
  shouldReAnimate: ie.bool,
  onAnimationStart: ie.func,
  onAnimationReStart: ie.func
}
Number.isFinite === void 0 &&
  (Number.isFinite = function (e) {
    return typeof e == "number" && isFinite(e)
  })
ie.object, ie.object, ie.object, ie.element
ie.object, ie.object, ie.object, ie.oneOfType([ie.array, ie.element]), ie.any
function dl(e) {
  "@babel/helpers - typeof"
  return (
    (dl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    dl(e)
  )
}
function Qu(e, t, n) {
  return (
    (t = sX(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function sX(e) {
  var t = lX(e, "string")
  return dl(t) === "symbol" ? t : String(t)
}
function lX(e, t) {
  if (dl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (dl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var os = "recharts-tooltip-wrapper",
  uX = { visibility: "hidden" }
function cX(e) {
  var t,
    n = e.coordinate,
    r = e.translateX,
    i = e.translateY
  return Oe(
    os,
    ((t = {}),
    Qu(t, "".concat(os, "-right"), G(r) && n && G(n.x) && r >= n.x),
    Qu(t, "".concat(os, "-left"), G(r) && n && G(n.x) && r < n.x),
    Qu(t, "".concat(os, "-bottom"), G(i) && n && G(n.y) && i >= n.y),
    Qu(t, "".concat(os, "-top"), G(i) && n && G(n.y) && i < n.y),
    t)
  )
}
function lS(e) {
  var t = e.allowEscapeViewBox,
    n = e.coordinate,
    r = e.key,
    i = e.offsetTopLeft,
    o = e.position,
    a = e.reverseDirection,
    s = e.tooltipDimension,
    l = e.viewBox,
    u = e.viewBoxDimension
  if (o && G(o[r])) return o[r]
  var f = n[r] - s - i,
    c = n[r] + i
  if (t[r]) return a[r] ? f : c
  if (a[r]) {
    var d = f,
      p = l[r]
    return d < p ? Math.max(c, l[r]) : Math.max(f, l[r])
  }
  var h = c + s,
    m = l[r] + u
  return h > m ? Math.max(f, l[r]) : Math.max(c, l[r])
}
function fX(e) {
  var t = e.translateX,
    n = e.translateY,
    r = e.useTranslate3d
  return y0({
    transform: r
      ? "translate3d(".concat(t, "px, ").concat(n, "px, 0)")
      : "translate(".concat(t, "px, ").concat(n, "px)")
  })
}
function dX(e) {
  var t = e.allowEscapeViewBox,
    n = e.coordinate,
    r = e.offsetTopLeft,
    i = e.position,
    o = e.reverseDirection,
    a = e.tooltipBox,
    s = e.useTranslate3d,
    l = e.viewBox,
    u,
    f,
    c
  return (
    a.height > 0 && a.width > 0 && n
      ? ((f = lS({
          allowEscapeViewBox: t,
          coordinate: n,
          key: "x",
          offsetTopLeft: r,
          position: i,
          reverseDirection: o,
          tooltipDimension: a.width,
          viewBox: l,
          viewBoxDimension: l.width
        })),
        (c = lS({
          allowEscapeViewBox: t,
          coordinate: n,
          key: "y",
          offsetTopLeft: r,
          position: i,
          reverseDirection: o,
          tooltipDimension: a.height,
          viewBox: l,
          viewBoxDimension: l.height
        })),
        (u = fX({ translateX: f, translateY: c, useTranslate3d: s })))
      : (u = uX),
    {
      cssProperties: u,
      cssClasses: cX({ translateX: f, translateY: c, coordinate: n })
    }
  )
}
function da(e) {
  "@babel/helpers - typeof"
  return (
    (da =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    da(e)
  )
}
function uS(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Ch(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? uS(Object(n), !0).forEach(function (r) {
          Pc(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : uS(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function pX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function cS(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, $_(r.key), r)
  }
}
function hX(e, t, n) {
  return (
    t && cS(e.prototype, t),
    n && cS(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function mX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 }
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && Bv(e, t)
}
function Bv(e, t) {
  return (
    (Bv = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r
        }),
    Bv(e, t)
  )
}
function vX(e) {
  var t = yX()
  return function () {
    var r = Af(e),
      i
    if (t) {
      var o = Af(this).constructor
      i = Reflect.construct(r, arguments, o)
    } else i = r.apply(this, arguments)
    return gX(this, i)
  }
}
function gX(e, t) {
  if (t && (da(t) === "object" || typeof t == "function")) return t
  if (t !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return Oc(e)
}
function Oc(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return e
}
function yX() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function Af(e) {
  return (
    (Af = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n)
        }),
    Af(e)
  )
}
function Pc(e, t, n) {
  return (
    (t = $_(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function $_(e) {
  var t = bX(e, "string")
  return da(t) === "symbol" ? t : String(t)
}
function bX(e, t) {
  if (da(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (da(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var fS = 1,
  xX = (function (e) {
    mX(n, e)
    var t = vX(n)
    function n() {
      var r
      pX(this, n)
      for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)
        o[a] = arguments[a]
      return (
        (r = t.call.apply(t, [this].concat(o))),
        Pc(Oc(r), "state", {
          dismissed: !1,
          dismissedAtCoordinate: { x: 0, y: 0 }
        }),
        Pc(Oc(r), "lastBoundingBox", { width: -1, height: -1 }),
        Pc(Oc(r), "handleKeyDown", function (s) {
          if (s.key === "Escape") {
            var l, u, f, c
            r.setState({
              dismissed: !0,
              dismissedAtCoordinate: {
                x:
                  (l =
                    (u = r.props.coordinate) === null || u === void 0
                      ? void 0
                      : u.x) !== null && l !== void 0
                    ? l
                    : 0,
                y:
                  (f =
                    (c = r.props.coordinate) === null || c === void 0
                      ? void 0
                      : c.y) !== null && f !== void 0
                    ? f
                    : 0
              }
            })
          }
        }),
        r
      )
    }
    return (
      hX(n, [
        {
          key: "updateBBox",
          value: function () {
            if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
              var i = this.wrapperNode.getBoundingClientRect()
              ;(Math.abs(i.width - this.lastBoundingBox.width) > fS ||
                Math.abs(i.height - this.lastBoundingBox.height) > fS) &&
                ((this.lastBoundingBox.width = i.width),
                (this.lastBoundingBox.height = i.height))
            } else
              (this.lastBoundingBox.width !== -1 ||
                this.lastBoundingBox.height !== -1) &&
                ((this.lastBoundingBox.width = -1),
                (this.lastBoundingBox.height = -1))
          }
        },
        {
          key: "componentDidMount",
          value: function () {
            document.addEventListener("keydown", this.handleKeyDown),
              this.updateBBox()
          }
        },
        {
          key: "componentWillUnmount",
          value: function () {
            document.removeEventListener("keydown", this.handleKeyDown)
          }
        },
        {
          key: "componentDidUpdate",
          value: function () {
            var i, o
            this.props.active && this.updateBBox(),
              this.state.dismissed &&
                (((i = this.props.coordinate) === null || i === void 0
                  ? void 0
                  : i.x) !== this.state.dismissedAtCoordinate.x ||
                  ((o = this.props.coordinate) === null || o === void 0
                    ? void 0
                    : o.y) !== this.state.dismissedAtCoordinate.y) &&
                (this.state.dismissed = !1)
          }
        },
        {
          key: "render",
          value: function () {
            var i = this,
              o = this.props,
              a = o.active,
              s = o.allowEscapeViewBox,
              l = o.animationDuration,
              u = o.animationEasing,
              f = o.children,
              c = o.coordinate,
              d = o.hasPayload,
              p = o.isAnimationActive,
              h = o.offset,
              m = o.position,
              b = o.reverseDirection,
              g = o.useTranslate3d,
              v = o.viewBox,
              y = o.wrapperStyle,
              w = dX({
                allowEscapeViewBox: s,
                coordinate: c,
                offsetTopLeft: h,
                position: m,
                reverseDirection: b,
                tooltipBox: {
                  height: this.lastBoundingBox.height,
                  width: this.lastBoundingBox.width
                },
                useTranslate3d: g,
                viewBox: v
              }),
              x = w.cssClasses,
              S = w.cssProperties,
              O = Ch(
                Ch(
                  Ch(
                    {},
                    p &&
                      a &&
                      y0({
                        transition: "transform ".concat(l, "ms ").concat(u)
                      })
                  ),
                  S
                ),
                {},
                {
                  pointerEvents: "none",
                  visibility:
                    !this.state.dismissed && a && d ? "visible" : "hidden",
                  position: "absolute",
                  top: 0,
                  left: 0
                },
                y
              )
            return E.createElement(
              "div",
              {
                tabIndex: -1,
                role: "dialog",
                className: x,
                style: O,
                ref: function (A) {
                  i.wrapperNode = A
                }
              },
              f
            )
          }
        }
      ]),
      n
    )
  })(P.PureComponent),
  wX = function () {
    return !(
      typeof window < "u" &&
      window.document &&
      window.document.createElement &&
      window.setTimeout
    )
  },
  si = {
    isSsr: wX(),
    get: function (t) {
      return si[t]
    },
    set: function (t, n) {
      if (typeof t == "string") si[t] = n
      else {
        var r = Object.keys(t)
        r &&
          r.length &&
          r.forEach(function (i) {
            si[i] = t[i]
          })
      }
    }
  }
function pa(e) {
  "@babel/helpers - typeof"
  return (
    (pa =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    pa(e)
  )
}
function dS(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function pS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? dS(Object(n), !0).forEach(function (r) {
          b0(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : dS(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function SX(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function hS(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, A_(r.key), r)
  }
}
function OX(e, t, n) {
  return (
    t && hS(e.prototype, t),
    n && hS(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function PX(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 }
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && Fv(e, t)
}
function Fv(e, t) {
  return (
    (Fv = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r
        }),
    Fv(e, t)
  )
}
function $X(e) {
  var t = EX()
  return function () {
    var r = Tf(e),
      i
    if (t) {
      var o = Tf(this).constructor
      i = Reflect.construct(r, arguments, o)
    } else i = r.apply(this, arguments)
    return AX(this, i)
  }
}
function AX(e, t) {
  if (t && (pa(t) === "object" || typeof t == "function")) return t
  if (t !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return TX(e)
}
function TX(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return e
}
function EX() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function Tf(e) {
  return (
    (Tf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n)
        }),
    Tf(e)
  )
}
function b0(e, t, n) {
  return (
    (t = A_(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function A_(e) {
  var t = CX(e, "string")
  return pa(t) === "symbol" ? t : String(t)
}
function CX(e, t) {
  if (pa(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (pa(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function _X(e) {
  return e.dataKey
}
function kX(e, t) {
  return E.isValidElement(e)
    ? E.cloneElement(e, t)
    : typeof e == "function"
      ? E.createElement(e, t)
      : E.createElement(jK, t)
}
var Vi = (function (e) {
  PX(n, e)
  var t = $X(n)
  function n() {
    return SX(this, n), t.apply(this, arguments)
  }
  return (
    OX(n, [
      {
        key: "render",
        value: function () {
          var i = this.props,
            o = i.active,
            a = i.allowEscapeViewBox,
            s = i.animationDuration,
            l = i.animationEasing,
            u = i.content,
            f = i.coordinate,
            c = i.filterNull,
            d = i.isAnimationActive,
            p = i.offset,
            h = i.payload,
            m = i.payloadUniqBy,
            b = i.position,
            g = i.reverseDirection,
            v = i.useTranslate3d,
            y = i.viewBox,
            w = i.wrapperStyle,
            x = h ?? []
          c &&
            x.length &&
            (x = s_(
              h.filter(function (O) {
                return O.value != null
              }),
              m,
              _X
            ))
          var S = x.length > 0
          return E.createElement(
            xX,
            {
              allowEscapeViewBox: a,
              animationDuration: s,
              animationEasing: l,
              isAnimationActive: d,
              active: o,
              coordinate: f,
              hasPayload: S,
              offset: p,
              position: b,
              reverseDirection: g,
              useTranslate3d: v,
              viewBox: y,
              wrapperStyle: w
            },
            kX(u, pS(pS({}, this.props), {}, { payload: x }))
          )
        }
      }
    ]),
    n
  )
})(P.PureComponent)
b0(Vi, "displayName", "Tooltip")
b0(Vi, "defaultProps", {
  allowEscapeViewBox: { x: !1, y: !1 },
  animationDuration: 400,
  animationEasing: "ease",
  contentStyle: {},
  coordinate: { x: 0, y: 0 },
  cursor: !0,
  cursorStyle: {},
  filterNull: !0,
  isAnimationActive: !si.isSsr,
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: { x: !1, y: !1 },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: !1,
  viewBox: { x: 0, y: 0, height: 0, width: 0 },
  wrapperStyle: {}
})
var MX = Jn,
  jX = function () {
    return MX.Date.now()
  },
  DX = jX,
  IX = /\s/
function NX(e) {
  for (var t = e.length; t-- && IX.test(e.charAt(t)); );
  return t
}
var RX = NX,
  LX = RX,
  BX = /^\s+/
function FX(e) {
  return e && e.slice(0, LX(e) + 1).replace(BX, "")
}
var VX = FX,
  zX = VX,
  mS = wi,
  UX = Ca,
  vS = NaN,
  WX = /^[-+]0x[0-9a-f]+$/i,
  HX = /^0b[01]+$/i,
  GX = /^0o[0-7]+$/i,
  KX = parseInt
function qX(e) {
  if (typeof e == "number") return e
  if (UX(e)) return vS
  if (mS(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e
    e = mS(t) ? t + "" : t
  }
  if (typeof e != "string") return e === 0 ? e : +e
  e = zX(e)
  var n = HX.test(e)
  return n || GX.test(e) ? KX(e.slice(2), n ? 2 : 8) : WX.test(e) ? vS : +e
}
var T_ = qX,
  XX = wi,
  _h = DX,
  gS = T_,
  YX = "Expected a function",
  QX = Math.max,
  ZX = Math.min
function JX(e, t, n) {
  var r,
    i,
    o,
    a,
    s,
    l,
    u = 0,
    f = !1,
    c = !1,
    d = !0
  if (typeof e != "function") throw new TypeError(YX)
  ;(t = gS(t) || 0),
    XX(n) &&
      ((f = !!n.leading),
      (c = "maxWait" in n),
      (o = c ? QX(gS(n.maxWait) || 0, t) : o),
      (d = "trailing" in n ? !!n.trailing : d))
  function p(S) {
    var O = r,
      $ = i
    return (r = i = void 0), (u = S), (a = e.apply($, O)), a
  }
  function h(S) {
    return (u = S), (s = setTimeout(g, t)), f ? p(S) : a
  }
  function m(S) {
    var O = S - l,
      $ = S - u,
      A = t - O
    return c ? ZX(A, o - $) : A
  }
  function b(S) {
    var O = S - l,
      $ = S - u
    return l === void 0 || O >= t || O < 0 || (c && $ >= o)
  }
  function g() {
    var S = _h()
    if (b(S)) return v(S)
    s = setTimeout(g, m(S))
  }
  function v(S) {
    return (s = void 0), d && r ? p(S) : ((r = i = void 0), a)
  }
  function y() {
    s !== void 0 && clearTimeout(s), (u = 0), (r = l = i = s = void 0)
  }
  function w() {
    return s === void 0 ? a : v(_h())
  }
  function x() {
    var S = _h(),
      O = b(S)
    if (((r = arguments), (i = this), (l = S), O)) {
      if (s === void 0) return h(l)
      if (c) return clearTimeout(s), (s = setTimeout(g, t)), p(l)
    }
    return s === void 0 && (s = setTimeout(g, t)), a
  }
  return (x.cancel = y), (x.flush = w), x
}
var eY = JX,
  tY = eY,
  nY = wi,
  rY = "Expected a function"
function iY(e, t, n) {
  var r = !0,
    i = !0
  if (typeof e != "function") throw new TypeError(rY)
  return (
    nY(n) &&
      ((r = "leading" in n ? !!n.leading : r),
      (i = "trailing" in n ? !!n.trailing : i)),
    tY(e, t, { leading: r, maxWait: t, trailing: i })
  )
}
var oY = iY
const aY = Pe(oY)
var E_ = function (t) {
  return null
}
E_.displayName = "Cell"
function pl(e) {
  "@babel/helpers - typeof"
  return (
    (pl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    pl(e)
  )
}
function yS(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Vv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? yS(Object(n), !0).forEach(function (r) {
          sY(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : yS(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function sY(e, t, n) {
  return (
    (t = lY(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function lY(e) {
  var t = uY(e, "string")
  return pl(t) === "symbol" ? t : String(t)
}
function uY(e, t) {
  if (pl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (pl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var go = { widthCache: {}, cacheCount: 0 },
  cY = 2e3,
  fY = {
    position: "absolute",
    top: "-20000px",
    left: 0,
    padding: 0,
    margin: 0,
    border: "none",
    whiteSpace: "pre"
  },
  bS = "recharts_measurement_span"
function dY(e) {
  var t = Vv({}, e)
  return (
    Object.keys(t).forEach(function (n) {
      t[n] || delete t[n]
    }),
    t
  )
}
var Is = function (t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
    if (t == null || si.isSsr) return { width: 0, height: 0 }
    var r = dY(n),
      i = JSON.stringify({ text: t, copyStyle: r })
    if (go.widthCache[i]) return go.widthCache[i]
    try {
      var o = document.getElementById(bS)
      o ||
        ((o = document.createElement("span")),
        o.setAttribute("id", bS),
        o.setAttribute("aria-hidden", "true"),
        document.body.appendChild(o))
      var a = Vv(Vv({}, fY), r)
      Object.assign(o.style, a), (o.textContent = "".concat(t))
      var s = o.getBoundingClientRect(),
        l = { width: s.width, height: s.height }
      return (
        (go.widthCache[i] = l),
        ++go.cacheCount > cY && ((go.cacheCount = 0), (go.widthCache = {})),
        l
      )
    } catch {
      return { width: 0, height: 0 }
    }
  },
  pY = function (t) {
    return {
      top: t.top + window.scrollY - document.documentElement.clientTop,
      left: t.left + window.scrollX - document.documentElement.clientLeft
    }
  }
function hl(e) {
  "@babel/helpers - typeof"
  return (
    (hl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    hl(e)
  )
}
function Ef(e, t) {
  return gY(e) || vY(e, t) || mY(e, t) || hY()
}
function hY() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function mY(e, t) {
  if (e) {
    if (typeof e == "string") return xS(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return xS(e, t)
  }
}
function xS(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function vY(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function gY(e) {
  if (Array.isArray(e)) return e
}
function yY(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function wS(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, xY(r.key), r)
  }
}
function bY(e, t, n) {
  return (
    t && wS(e.prototype, t),
    n && wS(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function xY(e) {
  var t = wY(e, "string")
  return hl(t) === "symbol" ? t : String(t)
}
function wY(e, t) {
  if (hl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (hl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var SS = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/,
  OS = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/,
  SY = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/,
  OY = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/,
  C_ = {
    cm: 96 / 2.54,
    mm: 96 / 25.4,
    pt: 96 / 72,
    pc: 96 / 6,
    in: 96,
    Q: 96 / (2.54 * 40),
    px: 1
  },
  PY = Object.keys(C_),
  Io = "NaN"
function $Y(e, t) {
  return e * C_[t]
}
var Zu = (function () {
  function e(t, n) {
    yY(this, e),
      (this.num = t),
      (this.unit = n),
      (this.num = t),
      (this.unit = n),
      Number.isNaN(t) && (this.unit = ""),
      n !== "" && !SY.test(n) && ((this.num = NaN), (this.unit = "")),
      PY.includes(n) && ((this.num = $Y(t, n)), (this.unit = "px"))
  }
  return (
    bY(
      e,
      [
        {
          key: "add",
          value: function (n) {
            return this.unit !== n.unit
              ? new e(NaN, "")
              : new e(this.num + n.num, this.unit)
          }
        },
        {
          key: "subtract",
          value: function (n) {
            return this.unit !== n.unit
              ? new e(NaN, "")
              : new e(this.num - n.num, this.unit)
          }
        },
        {
          key: "multiply",
          value: function (n) {
            return this.unit !== "" && n.unit !== "" && this.unit !== n.unit
              ? new e(NaN, "")
              : new e(this.num * n.num, this.unit || n.unit)
          }
        },
        {
          key: "divide",
          value: function (n) {
            return this.unit !== "" && n.unit !== "" && this.unit !== n.unit
              ? new e(NaN, "")
              : new e(this.num / n.num, this.unit || n.unit)
          }
        },
        {
          key: "toString",
          value: function () {
            return "".concat(this.num).concat(this.unit)
          }
        },
        {
          key: "isNaN",
          value: function () {
            return Number.isNaN(this.num)
          }
        }
      ],
      [
        {
          key: "parse",
          value: function (n) {
            var r,
              i = (r = OY.exec(n)) !== null && r !== void 0 ? r : [],
              o = Ef(i, 3),
              a = o[1],
              s = o[2]
            return new e(parseFloat(a), s ?? "")
          }
        }
      ]
    ),
    e
  )
})()
function __(e) {
  if (e.includes(Io)) return Io
  for (var t = e; t.includes("*") || t.includes("/"); ) {
    var n,
      r = (n = SS.exec(t)) !== null && n !== void 0 ? n : [],
      i = Ef(r, 4),
      o = i[1],
      a = i[2],
      s = i[3],
      l = Zu.parse(o ?? ""),
      u = Zu.parse(s ?? ""),
      f = a === "*" ? l.multiply(u) : l.divide(u)
    if (f.isNaN()) return Io
    t = t.replace(SS, f.toString())
  }
  for (; t.includes("+") || /.-\d+(?:\.\d+)?/.test(t); ) {
    var c,
      d = (c = OS.exec(t)) !== null && c !== void 0 ? c : [],
      p = Ef(d, 4),
      h = p[1],
      m = p[2],
      b = p[3],
      g = Zu.parse(h ?? ""),
      v = Zu.parse(b ?? ""),
      y = m === "+" ? g.add(v) : g.subtract(v)
    if (y.isNaN()) return Io
    t = t.replace(OS, y.toString())
  }
  return t
}
var PS = /\(([^()]*)\)/
function AY(e) {
  for (var t = e; t.includes("("); ) {
    var n = PS.exec(t),
      r = Ef(n, 2),
      i = r[1]
    t = t.replace(PS, __(i))
  }
  return t
}
function TY(e) {
  var t = e.replace(/\s+/g, "")
  return (t = AY(t)), (t = __(t)), t
}
function EY(e) {
  try {
    return TY(e)
  } catch {
    return Io
  }
}
function kh(e) {
  var t = EY(e.slice(5, -1))
  return t === Io ? "" : t
}
var CY = [
    "x",
    "y",
    "lineHeight",
    "capHeight",
    "scaleToFit",
    "textAnchor",
    "verticalAnchor",
    "fill"
  ],
  _Y = ["dx", "dy", "angle", "className", "breakAll"]
function zv() {
  return (
    (zv = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    zv.apply(this, arguments)
  )
}
function $S(e, t) {
  if (e == null) return {}
  var n = kY(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function kY(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function AS(e, t) {
  return IY(e) || DY(e, t) || jY(e, t) || MY()
}
function MY() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function jY(e, t) {
  if (e) {
    if (typeof e == "string") return TS(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return TS(e, t)
  }
}
function TS(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function DY(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function IY(e) {
  if (Array.isArray(e)) return e
}
var k_ = /[ \f\n\r\t\v\u2028\u2029]+/,
  M_ = function (t) {
    var n = t.children,
      r = t.breakAll,
      i = t.style
    try {
      var o = []
      xe(n) || (r ? (o = n.toString().split("")) : (o = n.toString().split(k_)))
      var a = o.map(function (l) {
          return { word: l, width: Is(l, i).width }
        }),
        s = r ? 0 : Is("", i).width
      return { wordsWithComputedWidth: a, spaceWidth: s }
    } catch {
      return null
    }
  },
  NY = function (t, n, r, i, o) {
    var a = t.maxLines,
      s = t.children,
      l = t.style,
      u = t.breakAll,
      f = G(a),
      c = s,
      d = function () {
        var D =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []
        return D.reduce(function (N, L) {
          var k = L.word,
            I = L.width,
            V = N[N.length - 1]
          if (V && (i == null || o || V.width + I + r < Number(i)))
            V.words.push(k), (V.width += I + r)
          else {
            var U = { words: [k], width: I }
            N.push(U)
          }
          return N
        }, [])
      },
      p = d(n),
      h = function (D) {
        return D.reduce(function (N, L) {
          return N.width > L.width ? N : L
        })
      }
    if (!f) return p
    for (
      var m = "",
        b = function (D) {
          var N = c.slice(0, D),
            L = M_({
              breakAll: u,
              style: l,
              children: N + m
            }).wordsWithComputedWidth,
            k = d(L),
            I = k.length > a || h(k).width > Number(i)
          return [I, k]
        },
        g = 0,
        v = c.length - 1,
        y = 0,
        w;
      g <= v && y <= c.length - 1;

    ) {
      var x = Math.floor((g + v) / 2),
        S = x - 1,
        O = b(S),
        $ = AS(O, 2),
        A = $[0],
        C = $[1],
        T = b(x),
        _ = AS(T, 1),
        R = _[0]
      if ((!A && !R && (g = x + 1), A && R && (v = x - 1), !A && R)) {
        w = C
        break
      }
      y++
    }
    return w || p
  },
  ES = function (t) {
    var n = xe(t) ? [] : t.toString().split(k_)
    return [{ words: n }]
  },
  RY = function (t) {
    var n = t.width,
      r = t.scaleToFit,
      i = t.children,
      o = t.style,
      a = t.breakAll,
      s = t.maxLines
    if ((n || r) && !si.isSsr) {
      var l,
        u,
        f = M_({ breakAll: a, children: i, style: o })
      if (f) {
        var c = f.wordsWithComputedWidth,
          d = f.spaceWidth
        ;(l = c), (u = d)
      } else return ES(i)
      return NY({ breakAll: a, children: i, maxLines: s, style: o }, l, u, n, r)
    }
    return ES(i)
  },
  CS = "#808080",
  Cf = function (t) {
    var n = t.x,
      r = n === void 0 ? 0 : n,
      i = t.y,
      o = i === void 0 ? 0 : i,
      a = t.lineHeight,
      s = a === void 0 ? "1em" : a,
      l = t.capHeight,
      u = l === void 0 ? "0.71em" : l,
      f = t.scaleToFit,
      c = f === void 0 ? !1 : f,
      d = t.textAnchor,
      p = d === void 0 ? "start" : d,
      h = t.verticalAnchor,
      m = h === void 0 ? "end" : h,
      b = t.fill,
      g = b === void 0 ? CS : b,
      v = $S(t, CY),
      y = P.useMemo(
        function () {
          return RY({
            breakAll: v.breakAll,
            children: v.children,
            maxLines: v.maxLines,
            scaleToFit: c,
            style: v.style,
            width: v.width
          })
        },
        [v.breakAll, v.children, v.maxLines, c, v.style, v.width]
      ),
      w = v.dx,
      x = v.dy,
      S = v.angle,
      O = v.className,
      $ = v.breakAll,
      A = $S(v, _Y)
    if (!it(r) || !it(o)) return null
    var C = r + (G(w) ? w : 0),
      T = o + (G(x) ? x : 0),
      _
    switch (m) {
      case "start":
        _ = kh("calc(".concat(u, ")"))
        break
      case "middle":
        _ = kh(
          "calc("
            .concat((y.length - 1) / 2, " * -")
            .concat(s, " + (")
            .concat(u, " / 2))")
        )
        break
      default:
        _ = kh("calc(".concat(y.length - 1, " * -").concat(s, ")"))
        break
    }
    var R = []
    if (c) {
      var M = y[0].width,
        D = v.width
      R.push("scale(".concat((G(D) ? D / M : 1) / M, ")"))
    }
    return (
      S && R.push("rotate(".concat(S, ", ").concat(C, ", ").concat(T, ")")),
      R.length && (A.transform = R.join(" ")),
      E.createElement(
        "text",
        zv({}, he(A, !0), {
          x: C,
          y: T,
          className: Oe("recharts-text", O),
          textAnchor: p,
          fill: g.includes("url") ? CS : g
        }),
        y.map(function (N, L) {
          var k = N.words.join($ ? "" : " ")
          return E.createElement(
            "tspan",
            { x: C, dy: L === 0 ? _ : s, key: k },
            k
          )
        })
      )
    )
  }
function li(e, t) {
  return e == null || t == null
    ? NaN
    : e < t
      ? -1
      : e > t
        ? 1
        : e >= t
          ? 0
          : NaN
}
function LY(e, t) {
  return e == null || t == null
    ? NaN
    : t < e
      ? -1
      : t > e
        ? 1
        : t >= e
          ? 0
          : NaN
}
function x0(e) {
  let t, n, r
  e.length !== 2
    ? ((t = li), (n = (s, l) => li(e(s), l)), (r = (s, l) => e(s) - l))
    : ((t = e === li || e === LY ? e : BY), (n = e), (r = e))
  function i(s, l, u = 0, f = s.length) {
    if (u < f) {
      if (t(l, l) !== 0) return f
      do {
        const c = (u + f) >>> 1
        n(s[c], l) < 0 ? (u = c + 1) : (f = c)
      } while (u < f)
    }
    return u
  }
  function o(s, l, u = 0, f = s.length) {
    if (u < f) {
      if (t(l, l) !== 0) return f
      do {
        const c = (u + f) >>> 1
        n(s[c], l) <= 0 ? (u = c + 1) : (f = c)
      } while (u < f)
    }
    return u
  }
  function a(s, l, u = 0, f = s.length) {
    const c = i(s, l, u, f - 1)
    return c > u && r(s[c - 1], l) > -r(s[c], l) ? c - 1 : c
  }
  return { left: i, center: a, right: o }
}
function BY() {
  return 0
}
function j_(e) {
  return e === null ? NaN : +e
}
function* FY(e, t) {
  if (t === void 0) for (let n of e) n != null && (n = +n) >= n && (yield n)
  else {
    let n = -1
    for (let r of e) (r = t(r, ++n, e)) != null && (r = +r) >= r && (yield r)
  }
}
const VY = x0(li),
  su = VY.right
x0(j_).center
class _S extends Map {
  constructor(t, n = WY) {
    if (
      (super(),
      Object.defineProperties(this, {
        _intern: { value: new Map() },
        _key: { value: n }
      }),
      t != null)
    )
      for (const [r, i] of t) this.set(r, i)
  }
  get(t) {
    return super.get(kS(this, t))
  }
  has(t) {
    return super.has(kS(this, t))
  }
  set(t, n) {
    return super.set(zY(this, t), n)
  }
  delete(t) {
    return super.delete(UY(this, t))
  }
}
function kS({ _intern: e, _key: t }, n) {
  const r = t(n)
  return e.has(r) ? e.get(r) : n
}
function zY({ _intern: e, _key: t }, n) {
  const r = t(n)
  return e.has(r) ? e.get(r) : (e.set(r, n), n)
}
function UY({ _intern: e, _key: t }, n) {
  const r = t(n)
  return e.has(r) && ((n = e.get(r)), e.delete(r)), n
}
function WY(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e
}
function HY(e = li) {
  if (e === li) return D_
  if (typeof e != "function") throw new TypeError("compare is not a function")
  return (t, n) => {
    const r = e(t, n)
    return r || r === 0 ? r : (e(n, n) === 0) - (e(t, t) === 0)
  }
}
function D_(e, t) {
  return (
    (e == null || !(e >= e)) - (t == null || !(t >= t)) ||
    (e < t ? -1 : e > t ? 1 : 0)
  )
}
const GY = Math.sqrt(50),
  KY = Math.sqrt(10),
  qY = Math.sqrt(2)
function _f(e, t, n) {
  const r = (t - e) / Math.max(0, n),
    i = Math.floor(Math.log10(r)),
    o = r / Math.pow(10, i),
    a = o >= GY ? 10 : o >= KY ? 5 : o >= qY ? 2 : 1
  let s, l, u
  return (
    i < 0
      ? ((u = Math.pow(10, -i) / a),
        (s = Math.round(e * u)),
        (l = Math.round(t * u)),
        s / u < e && ++s,
        l / u > t && --l,
        (u = -u))
      : ((u = Math.pow(10, i) * a),
        (s = Math.round(e / u)),
        (l = Math.round(t / u)),
        s * u < e && ++s,
        l * u > t && --l),
    l < s && 0.5 <= n && n < 2 ? _f(e, t, n * 2) : [s, l, u]
  )
}
function Uv(e, t, n) {
  if (((t = +t), (e = +e), (n = +n), !(n > 0))) return []
  if (e === t) return [e]
  const r = t < e,
    [i, o, a] = r ? _f(t, e, n) : _f(e, t, n)
  if (!(o >= i)) return []
  const s = o - i + 1,
    l = new Array(s)
  if (r)
    if (a < 0) for (let u = 0; u < s; ++u) l[u] = (o - u) / -a
    else for (let u = 0; u < s; ++u) l[u] = (o - u) * a
  else if (a < 0) for (let u = 0; u < s; ++u) l[u] = (i + u) / -a
  else for (let u = 0; u < s; ++u) l[u] = (i + u) * a
  return l
}
function Wv(e, t, n) {
  return (t = +t), (e = +e), (n = +n), _f(e, t, n)[2]
}
function Hv(e, t, n) {
  ;(t = +t), (e = +e), (n = +n)
  const r = t < e,
    i = r ? Wv(t, e, n) : Wv(e, t, n)
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i)
}
function MS(e, t) {
  let n
  if (t === void 0)
    for (const r of e)
      r != null && (n < r || (n === void 0 && r >= r)) && (n = r)
  else {
    let r = -1
    for (let i of e)
      (i = t(i, ++r, e)) != null &&
        (n < i || (n === void 0 && i >= i)) &&
        (n = i)
  }
  return n
}
function jS(e, t) {
  let n
  if (t === void 0)
    for (const r of e)
      r != null && (n > r || (n === void 0 && r >= r)) && (n = r)
  else {
    let r = -1
    for (let i of e)
      (i = t(i, ++r, e)) != null &&
        (n > i || (n === void 0 && i >= i)) &&
        (n = i)
  }
  return n
}
function I_(e, t, n = 0, r = 1 / 0, i) {
  if (
    ((t = Math.floor(t)),
    (n = Math.floor(Math.max(0, n))),
    (r = Math.floor(Math.min(e.length - 1, r))),
    !(n <= t && t <= r))
  )
    return e
  for (i = i === void 0 ? D_ : HY(i); r > n; ) {
    if (r - n > 600) {
      const l = r - n + 1,
        u = t - n + 1,
        f = Math.log(l),
        c = 0.5 * Math.exp((2 * f) / 3),
        d = 0.5 * Math.sqrt((f * c * (l - c)) / l) * (u - l / 2 < 0 ? -1 : 1),
        p = Math.max(n, Math.floor(t - (u * c) / l + d)),
        h = Math.min(r, Math.floor(t + ((l - u) * c) / l + d))
      I_(e, t, p, h, i)
    }
    const o = e[t]
    let a = n,
      s = r
    for (as(e, n, t), i(e[r], o) > 0 && as(e, n, r); a < s; ) {
      for (as(e, a, s), ++a, --s; i(e[a], o) < 0; ) ++a
      for (; i(e[s], o) > 0; ) --s
    }
    i(e[n], o) === 0 ? as(e, n, s) : (++s, as(e, s, r)),
      s <= t && (n = s + 1),
      t <= s && (r = s - 1)
  }
  return e
}
function as(e, t, n) {
  const r = e[t]
  ;(e[t] = e[n]), (e[n] = r)
}
function XY(e, t, n) {
  if (
    ((e = Float64Array.from(FY(e, n))), !(!(r = e.length) || isNaN((t = +t))))
  ) {
    if (t <= 0 || r < 2) return jS(e)
    if (t >= 1) return MS(e)
    var r,
      i = (r - 1) * t,
      o = Math.floor(i),
      a = MS(I_(e, o).subarray(0, o + 1)),
      s = jS(e.subarray(o + 1))
    return a + (s - a) * (i - o)
  }
}
function YY(e, t, n = j_) {
  if (!(!(r = e.length) || isNaN((t = +t)))) {
    if (t <= 0 || r < 2) return +n(e[0], 0, e)
    if (t >= 1) return +n(e[r - 1], r - 1, e)
    var r,
      i = (r - 1) * t,
      o = Math.floor(i),
      a = +n(e[o], o, e),
      s = +n(e[o + 1], o + 1, e)
    return a + (s - a) * (i - o)
  }
}
function QY(e, t, n) {
  ;(e = +e),
    (t = +t),
    (n = (i = arguments.length) < 2 ? ((t = e), (e = 0), 1) : i < 3 ? 1 : +n)
  for (
    var r = -1, i = Math.max(0, Math.ceil((t - e) / n)) | 0, o = new Array(i);
    ++r < i;

  )
    o[r] = e + r * n
  return o
}
function xn(e, t) {
  switch (arguments.length) {
    case 0:
      break
    case 1:
      this.range(e)
      break
    default:
      this.range(t).domain(e)
      break
  }
  return this
}
function kr(e, t) {
  switch (arguments.length) {
    case 0:
      break
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e)
      break
    }
    default: {
      this.domain(e),
        typeof t == "function" ? this.interpolator(t) : this.range(t)
      break
    }
  }
  return this
}
const Gv = Symbol("implicit")
function w0() {
  var e = new _S(),
    t = [],
    n = [],
    r = Gv
  function i(o) {
    let a = e.get(o)
    if (a === void 0) {
      if (r !== Gv) return r
      e.set(o, (a = t.push(o) - 1))
    }
    return n[a % n.length]
  }
  return (
    (i.domain = function (o) {
      if (!arguments.length) return t.slice()
      ;(t = []), (e = new _S())
      for (const a of o) e.has(a) || e.set(a, t.push(a) - 1)
      return i
    }),
    (i.range = function (o) {
      return arguments.length ? ((n = Array.from(o)), i) : n.slice()
    }),
    (i.unknown = function (o) {
      return arguments.length ? ((r = o), i) : r
    }),
    (i.copy = function () {
      return w0(t, n).unknown(r)
    }),
    xn.apply(i, arguments),
    i
  )
}
function ml() {
  var e = w0().unknown(void 0),
    t = e.domain,
    n = e.range,
    r = 0,
    i = 1,
    o,
    a,
    s = !1,
    l = 0,
    u = 0,
    f = 0.5
  delete e.unknown
  function c() {
    var d = t().length,
      p = i < r,
      h = p ? i : r,
      m = p ? r : i
    ;(o = (m - h) / Math.max(1, d - l + u * 2)),
      s && (o = Math.floor(o)),
      (h += (m - h - o * (d - l)) * f),
      (a = o * (1 - l)),
      s && ((h = Math.round(h)), (a = Math.round(a)))
    var b = QY(d).map(function (g) {
      return h + o * g
    })
    return n(p ? b.reverse() : b)
  }
  return (
    (e.domain = function (d) {
      return arguments.length ? (t(d), c()) : t()
    }),
    (e.range = function (d) {
      return arguments.length ? (([r, i] = d), (r = +r), (i = +i), c()) : [r, i]
    }),
    (e.rangeRound = function (d) {
      return ([r, i] = d), (r = +r), (i = +i), (s = !0), c()
    }),
    (e.bandwidth = function () {
      return a
    }),
    (e.step = function () {
      return o
    }),
    (e.round = function (d) {
      return arguments.length ? ((s = !!d), c()) : s
    }),
    (e.padding = function (d) {
      return arguments.length ? ((l = Math.min(1, (u = +d))), c()) : l
    }),
    (e.paddingInner = function (d) {
      return arguments.length ? ((l = Math.min(1, d)), c()) : l
    }),
    (e.paddingOuter = function (d) {
      return arguments.length ? ((u = +d), c()) : u
    }),
    (e.align = function (d) {
      return arguments.length ? ((f = Math.max(0, Math.min(1, d))), c()) : f
    }),
    (e.copy = function () {
      return ml(t(), [r, i]).round(s).paddingInner(l).paddingOuter(u).align(f)
    }),
    xn.apply(c(), arguments)
  )
}
function N_(e) {
  var t = e.copy
  return (
    (e.padding = e.paddingOuter),
    delete e.paddingInner,
    delete e.paddingOuter,
    (e.copy = function () {
      return N_(t())
    }),
    e
  )
}
function Ns() {
  return N_(ml.apply(null, arguments).paddingInner(1))
}
function S0(e, t, n) {
  ;(e.prototype = t.prototype = n), (n.constructor = e)
}
function R_(e, t) {
  var n = Object.create(e.prototype)
  for (var r in t) n[r] = t[r]
  return n
}
function lu() {}
var vl = 0.7,
  kf = 1 / vl,
  Go = "\\s*([+-]?\\d+)\\s*",
  gl = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
  Kn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
  ZY = /^#([0-9a-f]{3,8})$/,
  JY = new RegExp(`^rgb\\(${Go},${Go},${Go}\\)$`),
  eQ = new RegExp(`^rgb\\(${Kn},${Kn},${Kn}\\)$`),
  tQ = new RegExp(`^rgba\\(${Go},${Go},${Go},${gl}\\)$`),
  nQ = new RegExp(`^rgba\\(${Kn},${Kn},${Kn},${gl}\\)$`),
  rQ = new RegExp(`^hsl\\(${gl},${Kn},${Kn}\\)$`),
  iQ = new RegExp(`^hsla\\(${gl},${Kn},${Kn},${gl}\\)$`),
  DS = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }
S0(lu, yl, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e)
  },
  displayable() {
    return this.rgb().displayable()
  },
  hex: IS,
  formatHex: IS,
  formatHex8: oQ,
  formatHsl: aQ,
  formatRgb: NS,
  toString: NS
})
function IS() {
  return this.rgb().formatHex()
}
function oQ() {
  return this.rgb().formatHex8()
}
function aQ() {
  return L_(this).formatHsl()
}
function NS() {
  return this.rgb().formatRgb()
}
function yl(e) {
  var t, n
  return (
    (e = (e + "").trim().toLowerCase()),
    (t = ZY.exec(e))
      ? ((n = t[1].length),
        (t = parseInt(t[1], 16)),
        n === 6
          ? RS(t)
          : n === 3
            ? new Lt(
                ((t >> 8) & 15) | ((t >> 4) & 240),
                ((t >> 4) & 15) | (t & 240),
                ((t & 15) << 4) | (t & 15),
                1
              )
            : n === 8
              ? Ju(
                  (t >> 24) & 255,
                  (t >> 16) & 255,
                  (t >> 8) & 255,
                  (t & 255) / 255
                )
              : n === 4
                ? Ju(
                    ((t >> 12) & 15) | ((t >> 8) & 240),
                    ((t >> 8) & 15) | ((t >> 4) & 240),
                    ((t >> 4) & 15) | (t & 240),
                    (((t & 15) << 4) | (t & 15)) / 255
                  )
                : null)
      : (t = JY.exec(e))
        ? new Lt(t[1], t[2], t[3], 1)
        : (t = eQ.exec(e))
          ? new Lt(
              (t[1] * 255) / 100,
              (t[2] * 255) / 100,
              (t[3] * 255) / 100,
              1
            )
          : (t = tQ.exec(e))
            ? Ju(t[1], t[2], t[3], t[4])
            : (t = nQ.exec(e))
              ? Ju(
                  (t[1] * 255) / 100,
                  (t[2] * 255) / 100,
                  (t[3] * 255) / 100,
                  t[4]
                )
              : (t = rQ.exec(e))
                ? FS(t[1], t[2] / 100, t[3] / 100, 1)
                : (t = iQ.exec(e))
                  ? FS(t[1], t[2] / 100, t[3] / 100, t[4])
                  : DS.hasOwnProperty(e)
                    ? RS(DS[e])
                    : e === "transparent"
                      ? new Lt(NaN, NaN, NaN, 0)
                      : null
  )
}
function RS(e) {
  return new Lt((e >> 16) & 255, (e >> 8) & 255, e & 255, 1)
}
function Ju(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new Lt(e, t, n, r)
}
function sQ(e) {
  return (
    e instanceof lu || (e = yl(e)),
    e ? ((e = e.rgb()), new Lt(e.r, e.g, e.b, e.opacity)) : new Lt()
  )
}
function Kv(e, t, n, r) {
  return arguments.length === 1 ? sQ(e) : new Lt(e, t, n, r ?? 1)
}
function Lt(e, t, n, r) {
  ;(this.r = +e), (this.g = +t), (this.b = +n), (this.opacity = +r)
}
S0(
  Lt,
  Kv,
  R_(lu, {
    brighter(e) {
      return (
        (e = e == null ? kf : Math.pow(kf, e)),
        new Lt(this.r * e, this.g * e, this.b * e, this.opacity)
      )
    },
    darker(e) {
      return (
        (e = e == null ? vl : Math.pow(vl, e)),
        new Lt(this.r * e, this.g * e, this.b * e, this.opacity)
      )
    },
    rgb() {
      return this
    },
    clamp() {
      return new Lt(Ki(this.r), Ki(this.g), Ki(this.b), Mf(this.opacity))
    },
    displayable() {
      return (
        -0.5 <= this.r &&
        this.r < 255.5 &&
        -0.5 <= this.g &&
        this.g < 255.5 &&
        -0.5 <= this.b &&
        this.b < 255.5 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    hex: LS,
    formatHex: LS,
    formatHex8: lQ,
    formatRgb: BS,
    toString: BS
  })
)
function LS() {
  return `#${zi(this.r)}${zi(this.g)}${zi(this.b)}`
}
function lQ() {
  return `#${zi(this.r)}${zi(this.g)}${zi(this.b)}${zi(
    (isNaN(this.opacity) ? 1 : this.opacity) * 255
  )}`
}
function BS() {
  const e = Mf(this.opacity)
  return `${e === 1 ? "rgb(" : "rgba("}${Ki(this.r)}, ${Ki(this.g)}, ${Ki(
    this.b
  )}${e === 1 ? ")" : `, ${e})`}`
}
function Mf(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e))
}
function Ki(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0))
}
function zi(e) {
  return (e = Ki(e)), (e < 16 ? "0" : "") + e.toString(16)
}
function FS(e, t, n, r) {
  return (
    r <= 0
      ? (e = t = n = NaN)
      : n <= 0 || n >= 1
        ? (e = t = NaN)
        : t <= 0 && (e = NaN),
    new Cn(e, t, n, r)
  )
}
function L_(e) {
  if (e instanceof Cn) return new Cn(e.h, e.s, e.l, e.opacity)
  if ((e instanceof lu || (e = yl(e)), !e)) return new Cn()
  if (e instanceof Cn) return e
  e = e.rgb()
  var t = e.r / 255,
    n = e.g / 255,
    r = e.b / 255,
    i = Math.min(t, n, r),
    o = Math.max(t, n, r),
    a = NaN,
    s = o - i,
    l = (o + i) / 2
  return (
    s
      ? (t === o
          ? (a = (n - r) / s + (n < r) * 6)
          : n === o
            ? (a = (r - t) / s + 2)
            : (a = (t - n) / s + 4),
        (s /= l < 0.5 ? o + i : 2 - o - i),
        (a *= 60))
      : (s = l > 0 && l < 1 ? 0 : a),
    new Cn(a, s, l, e.opacity)
  )
}
function uQ(e, t, n, r) {
  return arguments.length === 1 ? L_(e) : new Cn(e, t, n, r ?? 1)
}
function Cn(e, t, n, r) {
  ;(this.h = +e), (this.s = +t), (this.l = +n), (this.opacity = +r)
}
S0(
  Cn,
  uQ,
  R_(lu, {
    brighter(e) {
      return (
        (e = e == null ? kf : Math.pow(kf, e)),
        new Cn(this.h, this.s, this.l * e, this.opacity)
      )
    },
    darker(e) {
      return (
        (e = e == null ? vl : Math.pow(vl, e)),
        new Cn(this.h, this.s, this.l * e, this.opacity)
      )
    },
    rgb() {
      var e = (this.h % 360) + (this.h < 0) * 360,
        t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
        n = this.l,
        r = n + (n < 0.5 ? n : 1 - n) * t,
        i = 2 * n - r
      return new Lt(
        Mh(e >= 240 ? e - 240 : e + 120, i, r),
        Mh(e, i, r),
        Mh(e < 120 ? e + 240 : e - 120, i, r),
        this.opacity
      )
    },
    clamp() {
      return new Cn(VS(this.h), ec(this.s), ec(this.l), Mf(this.opacity))
    },
    displayable() {
      return (
        ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
        0 <= this.l &&
        this.l <= 1 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    formatHsl() {
      const e = Mf(this.opacity)
      return `${e === 1 ? "hsl(" : "hsla("}${VS(this.h)}, ${
        ec(this.s) * 100
      }%, ${ec(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`
    }
  })
)
function VS(e) {
  return (e = (e || 0) % 360), e < 0 ? e + 360 : e
}
function ec(e) {
  return Math.max(0, Math.min(1, e || 0))
}
function Mh(e, t, n) {
  return (
    (e < 60
      ? t + ((n - t) * e) / 60
      : e < 180
        ? n
        : e < 240
          ? t + ((n - t) * (240 - e)) / 60
          : t) * 255
  )
}
const O0 = (e) => () => e
function cQ(e, t) {
  return function (n) {
    return e + n * t
  }
}
function fQ(e, t, n) {
  return (
    (e = Math.pow(e, n)),
    (t = Math.pow(t, n) - e),
    (n = 1 / n),
    function (r) {
      return Math.pow(e + r * t, n)
    }
  )
}
function dQ(e) {
  return (e = +e) == 1
    ? B_
    : function (t, n) {
        return n - t ? fQ(t, n, e) : O0(isNaN(t) ? n : t)
      }
}
function B_(e, t) {
  var n = t - e
  return n ? cQ(e, n) : O0(isNaN(e) ? t : e)
}
const zS = (function e(t) {
  var n = dQ(t)
  function r(i, o) {
    var a = n((i = Kv(i)).r, (o = Kv(o)).r),
      s = n(i.g, o.g),
      l = n(i.b, o.b),
      u = B_(i.opacity, o.opacity)
    return function (f) {
      return (
        (i.r = a(f)), (i.g = s(f)), (i.b = l(f)), (i.opacity = u(f)), i + ""
      )
    }
  }
  return (r.gamma = e), r
})(1)
function pQ(e, t) {
  t || (t = [])
  var n = e ? Math.min(t.length, e.length) : 0,
    r = t.slice(),
    i
  return function (o) {
    for (i = 0; i < n; ++i) r[i] = e[i] * (1 - o) + t[i] * o
    return r
  }
}
function hQ(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView)
}
function mQ(e, t) {
  var n = t ? t.length : 0,
    r = e ? Math.min(n, e.length) : 0,
    i = new Array(r),
    o = new Array(n),
    a
  for (a = 0; a < r; ++a) i[a] = La(e[a], t[a])
  for (; a < n; ++a) o[a] = t[a]
  return function (s) {
    for (a = 0; a < r; ++a) o[a] = i[a](s)
    return o
  }
}
function vQ(e, t) {
  var n = new Date()
  return (
    (e = +e),
    (t = +t),
    function (r) {
      return n.setTime(e * (1 - r) + t * r), n
    }
  )
}
function jf(e, t) {
  return (
    (e = +e),
    (t = +t),
    function (n) {
      return e * (1 - n) + t * n
    }
  )
}
function gQ(e, t) {
  var n = {},
    r = {},
    i
  ;(e === null || typeof e != "object") && (e = {}),
    (t === null || typeof t != "object") && (t = {})
  for (i in t) i in e ? (n[i] = La(e[i], t[i])) : (r[i] = t[i])
  return function (o) {
    for (i in n) r[i] = n[i](o)
    return r
  }
}
var qv = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  jh = new RegExp(qv.source, "g")
function yQ(e) {
  return function () {
    return e
  }
}
function bQ(e) {
  return function (t) {
    return e(t) + ""
  }
}
function xQ(e, t) {
  var n = (qv.lastIndex = jh.lastIndex = 0),
    r,
    i,
    o,
    a = -1,
    s = [],
    l = []
  for (e = e + "", t = t + ""; (r = qv.exec(e)) && (i = jh.exec(t)); )
    (o = i.index) > n &&
      ((o = t.slice(n, o)), s[a] ? (s[a] += o) : (s[++a] = o)),
      (r = r[0]) === (i = i[0])
        ? s[a]
          ? (s[a] += i)
          : (s[++a] = i)
        : ((s[++a] = null), l.push({ i: a, x: jf(r, i) })),
      (n = jh.lastIndex)
  return (
    n < t.length && ((o = t.slice(n)), s[a] ? (s[a] += o) : (s[++a] = o)),
    s.length < 2
      ? l[0]
        ? bQ(l[0].x)
        : yQ(t)
      : ((t = l.length),
        function (u) {
          for (var f = 0, c; f < t; ++f) s[(c = l[f]).i] = c.x(u)
          return s.join("")
        })
  )
}
function La(e, t) {
  var n = typeof t,
    r
  return t == null || n === "boolean"
    ? O0(t)
    : (n === "number"
        ? jf
        : n === "string"
          ? (r = yl(t))
            ? ((t = r), zS)
            : xQ
          : t instanceof yl
            ? zS
            : t instanceof Date
              ? vQ
              : hQ(t)
                ? pQ
                : Array.isArray(t)
                  ? mQ
                  : (typeof t.valueOf != "function" &&
                        typeof t.toString != "function") ||
                      isNaN(t)
                    ? gQ
                    : jf)(e, t)
}
function P0(e, t) {
  return (
    (e = +e),
    (t = +t),
    function (n) {
      return Math.round(e * (1 - n) + t * n)
    }
  )
}
function wQ(e, t) {
  t === void 0 && ((t = e), (e = La))
  for (
    var n = 0, r = t.length - 1, i = t[0], o = new Array(r < 0 ? 0 : r);
    n < r;

  )
    o[n] = e(i, (i = t[++n]))
  return function (a) {
    var s = Math.max(0, Math.min(r - 1, Math.floor((a *= r))))
    return o[s](a - s)
  }
}
function SQ(e) {
  return function () {
    return e
  }
}
function Df(e) {
  return +e
}
var US = [0, 1]
function kt(e) {
  return e
}
function Xv(e, t) {
  return (t -= e = +e)
    ? function (n) {
        return (n - e) / t
      }
    : SQ(isNaN(t) ? NaN : 0.5)
}
function OQ(e, t) {
  var n
  return (
    e > t && ((n = e), (e = t), (t = n)),
    function (r) {
      return Math.max(e, Math.min(t, r))
    }
  )
}
function PQ(e, t, n) {
  var r = e[0],
    i = e[1],
    o = t[0],
    a = t[1]
  return (
    i < r ? ((r = Xv(i, r)), (o = n(a, o))) : ((r = Xv(r, i)), (o = n(o, a))),
    function (s) {
      return o(r(s))
    }
  )
}
function $Q(e, t, n) {
  var r = Math.min(e.length, t.length) - 1,
    i = new Array(r),
    o = new Array(r),
    a = -1
  for (
    e[r] < e[0] && ((e = e.slice().reverse()), (t = t.slice().reverse()));
    ++a < r;

  )
    (i[a] = Xv(e[a], e[a + 1])), (o[a] = n(t[a], t[a + 1]))
  return function (s) {
    var l = su(e, s, 1, r) - 1
    return o[l](i[l](s))
  }
}
function uu(e, t) {
  return t
    .domain(e.domain())
    .range(e.range())
    .interpolate(e.interpolate())
    .clamp(e.clamp())
    .unknown(e.unknown())
}
function np() {
  var e = US,
    t = US,
    n = La,
    r,
    i,
    o,
    a = kt,
    s,
    l,
    u
  function f() {
    var d = Math.min(e.length, t.length)
    return (
      a !== kt && (a = OQ(e[0], e[d - 1])),
      (s = d > 2 ? $Q : PQ),
      (l = u = null),
      c
    )
  }
  function c(d) {
    return d == null || isNaN((d = +d))
      ? o
      : (l || (l = s(e.map(r), t, n)))(r(a(d)))
  }
  return (
    (c.invert = function (d) {
      return a(i((u || (u = s(t, e.map(r), jf)))(d)))
    }),
    (c.domain = function (d) {
      return arguments.length ? ((e = Array.from(d, Df)), f()) : e.slice()
    }),
    (c.range = function (d) {
      return arguments.length ? ((t = Array.from(d)), f()) : t.slice()
    }),
    (c.rangeRound = function (d) {
      return (t = Array.from(d)), (n = P0), f()
    }),
    (c.clamp = function (d) {
      return arguments.length ? ((a = d ? !0 : kt), f()) : a !== kt
    }),
    (c.interpolate = function (d) {
      return arguments.length ? ((n = d), f()) : n
    }),
    (c.unknown = function (d) {
      return arguments.length ? ((o = d), c) : o
    }),
    function (d, p) {
      return (r = d), (i = p), f()
    }
  )
}
function $0() {
  return np()(kt, kt)
}
function AQ(e) {
  return Math.abs((e = Math.round(e))) >= 1e21
    ? e.toLocaleString("en").replace(/,/g, "")
    : e.toString(10)
}
function If(e, t) {
  if (
    (n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0
  )
    return null
  var n,
    r = e.slice(0, n)
  return [r.length > 1 ? r[0] + r.slice(2) : r, +e.slice(n + 1)]
}
function ha(e) {
  return (e = If(Math.abs(e))), e ? e[1] : NaN
}
function TQ(e, t) {
  return function (n, r) {
    for (
      var i = n.length, o = [], a = 0, s = e[0], l = 0;
      i > 0 &&
      s > 0 &&
      (l + s + 1 > r && (s = Math.max(1, r - l)),
      o.push(n.substring((i -= s), i + s)),
      !((l += s + 1) > r));

    )
      s = e[(a = (a + 1) % e.length)]
    return o.reverse().join(t)
  }
}
function EQ(e) {
  return function (t) {
    return t.replace(/[0-9]/g, function (n) {
      return e[+n]
    })
  }
}
var CQ =
  /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i
function bl(e) {
  if (!(t = CQ.exec(e))) throw new Error("invalid format: " + e)
  var t
  return new A0({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  })
}
bl.prototype = A0.prototype
function A0(e) {
  ;(this.fill = e.fill === void 0 ? " " : e.fill + ""),
    (this.align = e.align === void 0 ? ">" : e.align + ""),
    (this.sign = e.sign === void 0 ? "-" : e.sign + ""),
    (this.symbol = e.symbol === void 0 ? "" : e.symbol + ""),
    (this.zero = !!e.zero),
    (this.width = e.width === void 0 ? void 0 : +e.width),
    (this.comma = !!e.comma),
    (this.precision = e.precision === void 0 ? void 0 : +e.precision),
    (this.trim = !!e.trim),
    (this.type = e.type === void 0 ? "" : e.type + "")
}
A0.prototype.toString = function () {
  return (
    this.fill +
    this.align +
    this.sign +
    this.symbol +
    (this.zero ? "0" : "") +
    (this.width === void 0 ? "" : Math.max(1, this.width | 0)) +
    (this.comma ? "," : "") +
    (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) +
    (this.trim ? "~" : "") +
    this.type
  )
}
function _Q(e) {
  e: for (var t = e.length, n = 1, r = -1, i; n < t; ++n)
    switch (e[n]) {
      case ".":
        r = i = n
        break
      case "0":
        r === 0 && (r = n), (i = n)
        break
      default:
        if (!+e[n]) break e
        r > 0 && (r = 0)
        break
    }
  return r > 0 ? e.slice(0, r) + e.slice(i + 1) : e
}
var F_
function kQ(e, t) {
  var n = If(e, t)
  if (!n) return e + ""
  var r = n[0],
    i = n[1],
    o = i - (F_ = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1,
    a = r.length
  return o === a
    ? r
    : o > a
      ? r + new Array(o - a + 1).join("0")
      : o > 0
        ? r.slice(0, o) + "." + r.slice(o)
        : "0." + new Array(1 - o).join("0") + If(e, Math.max(0, t + o - 1))[0]
}
function WS(e, t) {
  var n = If(e, t)
  if (!n) return e + ""
  var r = n[0],
    i = n[1]
  return i < 0
    ? "0." + new Array(-i).join("0") + r
    : r.length > i + 1
      ? r.slice(0, i + 1) + "." + r.slice(i + 1)
      : r + new Array(i - r.length + 2).join("0")
}
const HS = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: AQ,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => WS(e * 100, t),
  r: WS,
  s: kQ,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
}
function GS(e) {
  return e
}
var KS = Array.prototype.map,
  qS = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
  ]
function MQ(e) {
  var t =
      e.grouping === void 0 || e.thousands === void 0
        ? GS
        : TQ(KS.call(e.grouping, Number), e.thousands + ""),
    n = e.currency === void 0 ? "" : e.currency[0] + "",
    r = e.currency === void 0 ? "" : e.currency[1] + "",
    i = e.decimal === void 0 ? "." : e.decimal + "",
    o = e.numerals === void 0 ? GS : EQ(KS.call(e.numerals, String)),
    a = e.percent === void 0 ? "%" : e.percent + "",
    s = e.minus === void 0 ? "" : e.minus + "",
    l = e.nan === void 0 ? "NaN" : e.nan + ""
  function u(c) {
    c = bl(c)
    var d = c.fill,
      p = c.align,
      h = c.sign,
      m = c.symbol,
      b = c.zero,
      g = c.width,
      v = c.comma,
      y = c.precision,
      w = c.trim,
      x = c.type
    x === "n"
      ? ((v = !0), (x = "g"))
      : HS[x] || (y === void 0 && (y = 12), (w = !0), (x = "g")),
      (b || (d === "0" && p === "=")) && ((b = !0), (d = "0"), (p = "="))
    var S =
        m === "$"
          ? n
          : m === "#" && /[boxX]/.test(x)
            ? "0" + x.toLowerCase()
            : "",
      O = m === "$" ? r : /[%p]/.test(x) ? a : "",
      $ = HS[x],
      A = /[defgprs%]/.test(x)
    y =
      y === void 0
        ? 6
        : /[gprs]/.test(x)
          ? Math.max(1, Math.min(21, y))
          : Math.max(0, Math.min(20, y))
    function C(T) {
      var _ = S,
        R = O,
        M,
        D,
        N
      if (x === "c") (R = $(T) + R), (T = "")
      else {
        T = +T
        var L = T < 0 || 1 / T < 0
        if (
          ((T = isNaN(T) ? l : $(Math.abs(T), y)),
          w && (T = _Q(T)),
          L && +T == 0 && h !== "+" && (L = !1),
          (_ = (L ? (h === "(" ? h : s) : h === "-" || h === "(" ? "" : h) + _),
          (R =
            (x === "s" ? qS[8 + F_ / 3] : "") +
            R +
            (L && h === "(" ? ")" : "")),
          A)
        ) {
          for (M = -1, D = T.length; ++M < D; )
            if (((N = T.charCodeAt(M)), 48 > N || N > 57)) {
              ;(R = (N === 46 ? i + T.slice(M + 1) : T.slice(M)) + R),
                (T = T.slice(0, M))
              break
            }
        }
      }
      v && !b && (T = t(T, 1 / 0))
      var k = _.length + T.length + R.length,
        I = k < g ? new Array(g - k + 1).join(d) : ""
      switch (
        (v && b && ((T = t(I + T, I.length ? g - R.length : 1 / 0)), (I = "")),
        p)
      ) {
        case "<":
          T = _ + T + R + I
          break
        case "=":
          T = _ + I + T + R
          break
        case "^":
          T = I.slice(0, (k = I.length >> 1)) + _ + T + R + I.slice(k)
          break
        default:
          T = I + _ + T + R
          break
      }
      return o(T)
    }
    return (
      (C.toString = function () {
        return c + ""
      }),
      C
    )
  }
  function f(c, d) {
    var p = u(((c = bl(c)), (c.type = "f"), c)),
      h = Math.max(-8, Math.min(8, Math.floor(ha(d) / 3))) * 3,
      m = Math.pow(10, -h),
      b = qS[8 + h / 3]
    return function (g) {
      return p(m * g) + b
    }
  }
  return { format: u, formatPrefix: f }
}
var tc, T0, V_
jQ({ thousands: ",", grouping: [3], currency: ["$", ""] })
function jQ(e) {
  return (tc = MQ(e)), (T0 = tc.format), (V_ = tc.formatPrefix), tc
}
function DQ(e) {
  return Math.max(0, -ha(Math.abs(e)))
}
function IQ(e, t) {
  return Math.max(
    0,
    Math.max(-8, Math.min(8, Math.floor(ha(t) / 3))) * 3 - ha(Math.abs(e))
  )
}
function NQ(e, t) {
  return (
    (e = Math.abs(e)), (t = Math.abs(t) - e), Math.max(0, ha(t) - ha(e)) + 1
  )
}
function z_(e, t, n, r) {
  var i = Hv(e, t, n),
    o
  switch (((r = bl(r ?? ",f")), r.type)) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t))
      return (
        r.precision == null && !isNaN((o = IQ(i, a))) && (r.precision = o),
        V_(r, a)
      )
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null &&
        !isNaN((o = NQ(i, Math.max(Math.abs(e), Math.abs(t))))) &&
        (r.precision = o - (r.type === "e"))
      break
    }
    case "f":
    case "%": {
      r.precision == null &&
        !isNaN((o = DQ(i))) &&
        (r.precision = o - (r.type === "%") * 2)
      break
    }
  }
  return T0(r)
}
function Pi(e) {
  var t = e.domain
  return (
    (e.ticks = function (n) {
      var r = t()
      return Uv(r[0], r[r.length - 1], n ?? 10)
    }),
    (e.tickFormat = function (n, r) {
      var i = t()
      return z_(i[0], i[i.length - 1], n ?? 10, r)
    }),
    (e.nice = function (n) {
      n == null && (n = 10)
      var r = t(),
        i = 0,
        o = r.length - 1,
        a = r[i],
        s = r[o],
        l,
        u,
        f = 10
      for (
        s < a && ((u = a), (a = s), (s = u), (u = i), (i = o), (o = u));
        f-- > 0;

      ) {
        if (((u = Wv(a, s, n)), u === l)) return (r[i] = a), (r[o] = s), t(r)
        if (u > 0) (a = Math.floor(a / u) * u), (s = Math.ceil(s / u) * u)
        else if (u < 0) (a = Math.ceil(a * u) / u), (s = Math.floor(s * u) / u)
        else break
        l = u
      }
      return e
    }),
    e
  )
}
function Nf() {
  var e = $0()
  return (
    (e.copy = function () {
      return uu(e, Nf())
    }),
    xn.apply(e, arguments),
    Pi(e)
  )
}
function U_(e) {
  var t
  function n(r) {
    return r == null || isNaN((r = +r)) ? t : r
  }
  return (
    (n.invert = n),
    (n.domain = n.range =
      function (r) {
        return arguments.length ? ((e = Array.from(r, Df)), n) : e.slice()
      }),
    (n.unknown = function (r) {
      return arguments.length ? ((t = r), n) : t
    }),
    (n.copy = function () {
      return U_(e).unknown(t)
    }),
    (e = arguments.length ? Array.from(e, Df) : [0, 1]),
    Pi(n)
  )
}
function W_(e, t) {
  e = e.slice()
  var n = 0,
    r = e.length - 1,
    i = e[n],
    o = e[r],
    a
  return (
    o < i && ((a = n), (n = r), (r = a), (a = i), (i = o), (o = a)),
    (e[n] = t.floor(i)),
    (e[r] = t.ceil(o)),
    e
  )
}
function XS(e) {
  return Math.log(e)
}
function YS(e) {
  return Math.exp(e)
}
function RQ(e) {
  return -Math.log(-e)
}
function LQ(e) {
  return -Math.exp(-e)
}
function BQ(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e
}
function FQ(e) {
  return e === 10 ? BQ : e === Math.E ? Math.exp : (t) => Math.pow(e, t)
}
function VQ(e) {
  return e === Math.E
    ? Math.log
    : (e === 10 && Math.log10) ||
        (e === 2 && Math.log2) ||
        ((e = Math.log(e)), (t) => Math.log(t) / e)
}
function QS(e) {
  return (t, n) => -e(-t, n)
}
function E0(e) {
  const t = e(XS, YS),
    n = t.domain
  let r = 10,
    i,
    o
  function a() {
    return (
      (i = VQ(r)),
      (o = FQ(r)),
      n()[0] < 0 ? ((i = QS(i)), (o = QS(o)), e(RQ, LQ)) : e(XS, YS),
      t
    )
  }
  return (
    (t.base = function (s) {
      return arguments.length ? ((r = +s), a()) : r
    }),
    (t.domain = function (s) {
      return arguments.length ? (n(s), a()) : n()
    }),
    (t.ticks = (s) => {
      const l = n()
      let u = l[0],
        f = l[l.length - 1]
      const c = f < u
      c && ([u, f] = [f, u])
      let d = i(u),
        p = i(f),
        h,
        m
      const b = s == null ? 10 : +s
      let g = []
      if (!(r % 1) && p - d < b) {
        if (((d = Math.floor(d)), (p = Math.ceil(p)), u > 0)) {
          for (; d <= p; ++d)
            for (h = 1; h < r; ++h)
              if (((m = d < 0 ? h / o(-d) : h * o(d)), !(m < u))) {
                if (m > f) break
                g.push(m)
              }
        } else
          for (; d <= p; ++d)
            for (h = r - 1; h >= 1; --h)
              if (((m = d > 0 ? h / o(-d) : h * o(d)), !(m < u))) {
                if (m > f) break
                g.push(m)
              }
        g.length * 2 < b && (g = Uv(u, f, b))
      } else g = Uv(d, p, Math.min(p - d, b)).map(o)
      return c ? g.reverse() : g
    }),
    (t.tickFormat = (s, l) => {
      if (
        (s == null && (s = 10),
        l == null && (l = r === 10 ? "s" : ","),
        typeof l != "function" &&
          (!(r % 1) && (l = bl(l)).precision == null && (l.trim = !0),
          (l = T0(l))),
        s === 1 / 0)
      )
        return l
      const u = Math.max(1, (r * s) / t.ticks().length)
      return (f) => {
        let c = f / o(Math.round(i(f)))
        return c * r < r - 0.5 && (c *= r), c <= u ? l(f) : ""
      }
    }),
    (t.nice = () =>
      n(
        W_(n(), {
          floor: (s) => o(Math.floor(i(s))),
          ceil: (s) => o(Math.ceil(i(s)))
        })
      )),
    t
  )
}
function H_() {
  const e = E0(np()).domain([1, 10])
  return (e.copy = () => uu(e, H_()).base(e.base())), xn.apply(e, arguments), e
}
function ZS(e) {
  return function (t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e))
  }
}
function JS(e) {
  return function (t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e
  }
}
function C0(e) {
  var t = 1,
    n = e(ZS(t), JS(t))
  return (
    (n.constant = function (r) {
      return arguments.length ? e(ZS((t = +r)), JS(t)) : t
    }),
    Pi(n)
  )
}
function G_() {
  var e = C0(np())
  return (
    (e.copy = function () {
      return uu(e, G_()).constant(e.constant())
    }),
    xn.apply(e, arguments)
  )
}
function eO(e) {
  return function (t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e)
  }
}
function zQ(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e)
}
function UQ(e) {
  return e < 0 ? -e * e : e * e
}
function _0(e) {
  var t = e(kt, kt),
    n = 1
  function r() {
    return n === 1 ? e(kt, kt) : n === 0.5 ? e(zQ, UQ) : e(eO(n), eO(1 / n))
  }
  return (
    (t.exponent = function (i) {
      return arguments.length ? ((n = +i), r()) : n
    }),
    Pi(t)
  )
}
function k0() {
  var e = _0(np())
  return (
    (e.copy = function () {
      return uu(e, k0()).exponent(e.exponent())
    }),
    xn.apply(e, arguments),
    e
  )
}
function WQ() {
  return k0.apply(null, arguments).exponent(0.5)
}
function tO(e) {
  return Math.sign(e) * e * e
}
function HQ(e) {
  return Math.sign(e) * Math.sqrt(Math.abs(e))
}
function K_() {
  var e = $0(),
    t = [0, 1],
    n = !1,
    r
  function i(o) {
    var a = HQ(e(o))
    return isNaN(a) ? r : n ? Math.round(a) : a
  }
  return (
    (i.invert = function (o) {
      return e.invert(tO(o))
    }),
    (i.domain = function (o) {
      return arguments.length ? (e.domain(o), i) : e.domain()
    }),
    (i.range = function (o) {
      return arguments.length
        ? (e.range((t = Array.from(o, Df)).map(tO)), i)
        : t.slice()
    }),
    (i.rangeRound = function (o) {
      return i.range(o).round(!0)
    }),
    (i.round = function (o) {
      return arguments.length ? ((n = !!o), i) : n
    }),
    (i.clamp = function (o) {
      return arguments.length ? (e.clamp(o), i) : e.clamp()
    }),
    (i.unknown = function (o) {
      return arguments.length ? ((r = o), i) : r
    }),
    (i.copy = function () {
      return K_(e.domain(), t).round(n).clamp(e.clamp()).unknown(r)
    }),
    xn.apply(i, arguments),
    Pi(i)
  )
}
function q_() {
  var e = [],
    t = [],
    n = [],
    r
  function i() {
    var a = 0,
      s = Math.max(1, t.length)
    for (n = new Array(s - 1); ++a < s; ) n[a - 1] = YY(e, a / s)
    return o
  }
  function o(a) {
    return a == null || isNaN((a = +a)) ? r : t[su(n, a)]
  }
  return (
    (o.invertExtent = function (a) {
      var s = t.indexOf(a)
      return s < 0
        ? [NaN, NaN]
        : [s > 0 ? n[s - 1] : e[0], s < n.length ? n[s] : e[e.length - 1]]
    }),
    (o.domain = function (a) {
      if (!arguments.length) return e.slice()
      e = []
      for (let s of a) s != null && !isNaN((s = +s)) && e.push(s)
      return e.sort(li), i()
    }),
    (o.range = function (a) {
      return arguments.length ? ((t = Array.from(a)), i()) : t.slice()
    }),
    (o.unknown = function (a) {
      return arguments.length ? ((r = a), o) : r
    }),
    (o.quantiles = function () {
      return n.slice()
    }),
    (o.copy = function () {
      return q_().domain(e).range(t).unknown(r)
    }),
    xn.apply(o, arguments)
  )
}
function X_() {
  var e = 0,
    t = 1,
    n = 1,
    r = [0.5],
    i = [0, 1],
    o
  function a(l) {
    return l != null && l <= l ? i[su(r, l, 0, n)] : o
  }
  function s() {
    var l = -1
    for (r = new Array(n); ++l < n; )
      r[l] = ((l + 1) * t - (l - n) * e) / (n + 1)
    return a
  }
  return (
    (a.domain = function (l) {
      return arguments.length ? (([e, t] = l), (e = +e), (t = +t), s()) : [e, t]
    }),
    (a.range = function (l) {
      return arguments.length
        ? ((n = (i = Array.from(l)).length - 1), s())
        : i.slice()
    }),
    (a.invertExtent = function (l) {
      var u = i.indexOf(l)
      return u < 0
        ? [NaN, NaN]
        : u < 1
          ? [e, r[0]]
          : u >= n
            ? [r[n - 1], t]
            : [r[u - 1], r[u]]
    }),
    (a.unknown = function (l) {
      return arguments.length && (o = l), a
    }),
    (a.thresholds = function () {
      return r.slice()
    }),
    (a.copy = function () {
      return X_().domain([e, t]).range(i).unknown(o)
    }),
    xn.apply(Pi(a), arguments)
  )
}
function Y_() {
  var e = [0.5],
    t = [0, 1],
    n,
    r = 1
  function i(o) {
    return o != null && o <= o ? t[su(e, o, 0, r)] : n
  }
  return (
    (i.domain = function (o) {
      return arguments.length
        ? ((e = Array.from(o)), (r = Math.min(e.length, t.length - 1)), i)
        : e.slice()
    }),
    (i.range = function (o) {
      return arguments.length
        ? ((t = Array.from(o)), (r = Math.min(e.length, t.length - 1)), i)
        : t.slice()
    }),
    (i.invertExtent = function (o) {
      var a = t.indexOf(o)
      return [e[a - 1], e[a]]
    }),
    (i.unknown = function (o) {
      return arguments.length ? ((n = o), i) : n
    }),
    (i.copy = function () {
      return Y_().domain(e).range(t).unknown(n)
    }),
    xn.apply(i, arguments)
  )
}
const Dh = new Date(),
  Ih = new Date()
function at(e, t, n, r) {
  function i(o) {
    return e((o = arguments.length === 0 ? new Date() : new Date(+o))), o
  }
  return (
    (i.floor = (o) => (e((o = new Date(+o))), o)),
    (i.ceil = (o) => (e((o = new Date(o - 1))), t(o, 1), e(o), o)),
    (i.round = (o) => {
      const a = i(o),
        s = i.ceil(o)
      return o - a < s - o ? a : s
    }),
    (i.offset = (o, a) => (
      t((o = new Date(+o)), a == null ? 1 : Math.floor(a)), o
    )),
    (i.range = (o, a, s) => {
      const l = []
      if (
        ((o = i.ceil(o)),
        (s = s == null ? 1 : Math.floor(s)),
        !(o < a) || !(s > 0))
      )
        return l
      let u
      do l.push((u = new Date(+o))), t(o, s), e(o)
      while (u < o && o < a)
      return l
    }),
    (i.filter = (o) =>
      at(
        (a) => {
          if (a >= a) for (; e(a), !o(a); ) a.setTime(a - 1)
        },
        (a, s) => {
          if (a >= a)
            if (s < 0) for (; ++s <= 0; ) for (; t(a, -1), !o(a); );
            else for (; --s >= 0; ) for (; t(a, 1), !o(a); );
        }
      )),
    n &&
      ((i.count = (o, a) => (
        Dh.setTime(+o), Ih.setTime(+a), e(Dh), e(Ih), Math.floor(n(Dh, Ih))
      )),
      (i.every = (o) => (
        (o = Math.floor(o)),
        !isFinite(o) || !(o > 0)
          ? null
          : o > 1
            ? i.filter(
                r ? (a) => r(a) % o === 0 : (a) => i.count(0, a) % o === 0
              )
            : i
      ))),
    i
  )
}
const Rf = at(
  () => {},
  (e, t) => {
    e.setTime(+e + t)
  },
  (e, t) => t - e
)
Rf.every = (e) => (
  (e = Math.floor(e)),
  !isFinite(e) || !(e > 0)
    ? null
    : e > 1
      ? at(
          (t) => {
            t.setTime(Math.floor(t / e) * e)
          },
          (t, n) => {
            t.setTime(+t + n * e)
          },
          (t, n) => (n - t) / e
        )
      : Rf
)
Rf.range
const cr = 1e3,
  pn = cr * 60,
  fr = pn * 60,
  Sr = fr * 24,
  M0 = Sr * 7,
  nO = Sr * 30,
  Nh = Sr * 365,
  Ui = at(
    (e) => {
      e.setTime(e - e.getMilliseconds())
    },
    (e, t) => {
      e.setTime(+e + t * cr)
    },
    (e, t) => (t - e) / cr,
    (e) => e.getUTCSeconds()
  )
Ui.range
const j0 = at(
  (e) => {
    e.setTime(e - e.getMilliseconds() - e.getSeconds() * cr)
  },
  (e, t) => {
    e.setTime(+e + t * pn)
  },
  (e, t) => (t - e) / pn,
  (e) => e.getMinutes()
)
j0.range
const D0 = at(
  (e) => {
    e.setUTCSeconds(0, 0)
  },
  (e, t) => {
    e.setTime(+e + t * pn)
  },
  (e, t) => (t - e) / pn,
  (e) => e.getUTCMinutes()
)
D0.range
const I0 = at(
  (e) => {
    e.setTime(
      e - e.getMilliseconds() - e.getSeconds() * cr - e.getMinutes() * pn
    )
  },
  (e, t) => {
    e.setTime(+e + t * fr)
  },
  (e, t) => (t - e) / fr,
  (e) => e.getHours()
)
I0.range
const N0 = at(
  (e) => {
    e.setUTCMinutes(0, 0, 0)
  },
  (e, t) => {
    e.setTime(+e + t * fr)
  },
  (e, t) => (t - e) / fr,
  (e) => e.getUTCHours()
)
N0.range
const cu = at(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * pn) / Sr,
  (e) => e.getDate() - 1
)
cu.range
const rp = at(
  (e) => {
    e.setUTCHours(0, 0, 0, 0)
  },
  (e, t) => {
    e.setUTCDate(e.getUTCDate() + t)
  },
  (e, t) => (t - e) / Sr,
  (e) => e.getUTCDate() - 1
)
rp.range
const Q_ = at(
  (e) => {
    e.setUTCHours(0, 0, 0, 0)
  },
  (e, t) => {
    e.setUTCDate(e.getUTCDate() + t)
  },
  (e, t) => (t - e) / Sr,
  (e) => Math.floor(e / Sr)
)
Q_.range
function lo(e) {
  return at(
    (t) => {
      t.setDate(t.getDate() - ((t.getDay() + 7 - e) % 7)),
        t.setHours(0, 0, 0, 0)
    },
    (t, n) => {
      t.setDate(t.getDate() + n * 7)
    },
    (t, n) =>
      (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * pn) / M0
  )
}
const ip = lo(0),
  Lf = lo(1),
  GQ = lo(2),
  KQ = lo(3),
  ma = lo(4),
  qQ = lo(5),
  XQ = lo(6)
ip.range
Lf.range
GQ.range
KQ.range
ma.range
qQ.range
XQ.range
function uo(e) {
  return at(
    (t) => {
      t.setUTCDate(t.getUTCDate() - ((t.getUTCDay() + 7 - e) % 7)),
        t.setUTCHours(0, 0, 0, 0)
    },
    (t, n) => {
      t.setUTCDate(t.getUTCDate() + n * 7)
    },
    (t, n) => (n - t) / M0
  )
}
const op = uo(0),
  Bf = uo(1),
  YQ = uo(2),
  QQ = uo(3),
  va = uo(4),
  ZQ = uo(5),
  JQ = uo(6)
op.range
Bf.range
YQ.range
QQ.range
va.range
ZQ.range
JQ.range
const R0 = at(
  (e) => {
    e.setDate(1), e.setHours(0, 0, 0, 0)
  },
  (e, t) => {
    e.setMonth(e.getMonth() + t)
  },
  (e, t) =>
    t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12,
  (e) => e.getMonth()
)
R0.range
const L0 = at(
  (e) => {
    e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0)
  },
  (e, t) => {
    e.setUTCMonth(e.getUTCMonth() + t)
  },
  (e, t) =>
    t.getUTCMonth() -
    e.getUTCMonth() +
    (t.getUTCFullYear() - e.getUTCFullYear()) * 12,
  (e) => e.getUTCMonth()
)
L0.range
const Or = at(
  (e) => {
    e.setMonth(0, 1), e.setHours(0, 0, 0, 0)
  },
  (e, t) => {
    e.setFullYear(e.getFullYear() + t)
  },
  (e, t) => t.getFullYear() - e.getFullYear(),
  (e) => e.getFullYear()
)
Or.every = (e) =>
  !isFinite((e = Math.floor(e))) || !(e > 0)
    ? null
    : at(
        (t) => {
          t.setFullYear(Math.floor(t.getFullYear() / e) * e),
            t.setMonth(0, 1),
            t.setHours(0, 0, 0, 0)
        },
        (t, n) => {
          t.setFullYear(t.getFullYear() + n * e)
        }
      )
Or.range
const Pr = at(
  (e) => {
    e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0)
  },
  (e, t) => {
    e.setUTCFullYear(e.getUTCFullYear() + t)
  },
  (e, t) => t.getUTCFullYear() - e.getUTCFullYear(),
  (e) => e.getUTCFullYear()
)
Pr.every = (e) =>
  !isFinite((e = Math.floor(e))) || !(e > 0)
    ? null
    : at(
        (t) => {
          t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e),
            t.setUTCMonth(0, 1),
            t.setUTCHours(0, 0, 0, 0)
        },
        (t, n) => {
          t.setUTCFullYear(t.getUTCFullYear() + n * e)
        }
      )
Pr.range
function Z_(e, t, n, r, i, o) {
  const a = [
    [Ui, 1, cr],
    [Ui, 5, 5 * cr],
    [Ui, 15, 15 * cr],
    [Ui, 30, 30 * cr],
    [o, 1, pn],
    [o, 5, 5 * pn],
    [o, 15, 15 * pn],
    [o, 30, 30 * pn],
    [i, 1, fr],
    [i, 3, 3 * fr],
    [i, 6, 6 * fr],
    [i, 12, 12 * fr],
    [r, 1, Sr],
    [r, 2, 2 * Sr],
    [n, 1, M0],
    [t, 1, nO],
    [t, 3, 3 * nO],
    [e, 1, Nh]
  ]
  function s(u, f, c) {
    const d = f < u
    d && ([u, f] = [f, u])
    const p = c && typeof c.range == "function" ? c : l(u, f, c),
      h = p ? p.range(u, +f + 1) : []
    return d ? h.reverse() : h
  }
  function l(u, f, c) {
    const d = Math.abs(f - u) / c,
      p = x0(([, , b]) => b).right(a, d)
    if (p === a.length) return e.every(Hv(u / Nh, f / Nh, c))
    if (p === 0) return Rf.every(Math.max(Hv(u, f, c), 1))
    const [h, m] = a[d / a[p - 1][2] < a[p][2] / d ? p - 1 : p]
    return h.every(m)
  }
  return [s, l]
}
const [eZ, tZ] = Z_(Pr, L0, op, Q_, N0, D0),
  [nZ, rZ] = Z_(Or, R0, ip, cu, I0, j0)
function Rh(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L)
    return t.setFullYear(e.y), t
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L)
}
function Lh(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L))
    return t.setUTCFullYear(e.y), t
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L))
}
function ss(e, t, n) {
  return { y: e, m: t, d: n, H: 0, M: 0, S: 0, L: 0 }
}
function iZ(e) {
  var t = e.dateTime,
    n = e.date,
    r = e.time,
    i = e.periods,
    o = e.days,
    a = e.shortDays,
    s = e.months,
    l = e.shortMonths,
    u = ls(i),
    f = us(i),
    c = ls(o),
    d = us(o),
    p = ls(a),
    h = us(a),
    m = ls(s),
    b = us(s),
    g = ls(l),
    v = us(l),
    y = {
      a: L,
      A: k,
      b: I,
      B: V,
      c: null,
      d: lO,
      e: lO,
      f: TZ,
      g: RZ,
      G: BZ,
      H: PZ,
      I: $Z,
      j: AZ,
      L: J_,
      m: EZ,
      M: CZ,
      p: U,
      q: H,
      Q: fO,
      s: dO,
      S: _Z,
      u: kZ,
      U: MZ,
      V: jZ,
      w: DZ,
      W: IZ,
      x: null,
      X: null,
      y: NZ,
      Y: LZ,
      Z: FZ,
      "%": cO
    },
    w = {
      a: ee,
      A: X,
      b: de,
      B: ue,
      c: null,
      d: uO,
      e: uO,
      f: WZ,
      g: eJ,
      G: nJ,
      H: VZ,
      I: zZ,
      j: UZ,
      L: tk,
      m: HZ,
      M: GZ,
      p: We,
      q: Qe,
      Q: fO,
      s: dO,
      S: KZ,
      u: qZ,
      U: XZ,
      V: YZ,
      w: QZ,
      W: ZZ,
      x: null,
      X: null,
      y: JZ,
      Y: tJ,
      Z: rJ,
      "%": cO
    },
    x = {
      a: C,
      A: T,
      b: _,
      B: R,
      c: M,
      d: aO,
      e: aO,
      f: xZ,
      g: oO,
      G: iO,
      H: sO,
      I: sO,
      j: vZ,
      L: bZ,
      m: mZ,
      M: gZ,
      p: A,
      q: hZ,
      Q: SZ,
      s: OZ,
      S: yZ,
      u: uZ,
      U: cZ,
      V: fZ,
      w: lZ,
      W: dZ,
      x: D,
      X: N,
      y: oO,
      Y: iO,
      Z: pZ,
      "%": wZ
    }
  ;(y.x = S(n, y)),
    (y.X = S(r, y)),
    (y.c = S(t, y)),
    (w.x = S(n, w)),
    (w.X = S(r, w)),
    (w.c = S(t, w))
  function S(W, Q) {
    return function (Z) {
      var F = [],
        me = -1,
        ae = 0,
        ve = W.length,
        je,
        Ke,
        It
      for (Z instanceof Date || (Z = new Date(+Z)); ++me < ve; )
        W.charCodeAt(me) === 37 &&
          (F.push(W.slice(ae, me)),
          (Ke = rO[(je = W.charAt(++me))]) != null
            ? (je = W.charAt(++me))
            : (Ke = je === "e" ? " " : "0"),
          (It = Q[je]) && (je = It(Z, Ke)),
          F.push(je),
          (ae = me + 1))
      return F.push(W.slice(ae, me)), F.join("")
    }
  }
  function O(W, Q) {
    return function (Z) {
      var F = ss(1900, void 0, 1),
        me = $(F, W, (Z += ""), 0),
        ae,
        ve
      if (me != Z.length) return null
      if ("Q" in F) return new Date(F.Q)
      if ("s" in F) return new Date(F.s * 1e3 + ("L" in F ? F.L : 0))
      if (
        (Q && !("Z" in F) && (F.Z = 0),
        "p" in F && (F.H = (F.H % 12) + F.p * 12),
        F.m === void 0 && (F.m = "q" in F ? F.q : 0),
        "V" in F)
      ) {
        if (F.V < 1 || F.V > 53) return null
        "w" in F || (F.w = 1),
          "Z" in F
            ? ((ae = Lh(ss(F.y, 0, 1))),
              (ve = ae.getUTCDay()),
              (ae = ve > 4 || ve === 0 ? Bf.ceil(ae) : Bf(ae)),
              (ae = rp.offset(ae, (F.V - 1) * 7)),
              (F.y = ae.getUTCFullYear()),
              (F.m = ae.getUTCMonth()),
              (F.d = ae.getUTCDate() + ((F.w + 6) % 7)))
            : ((ae = Rh(ss(F.y, 0, 1))),
              (ve = ae.getDay()),
              (ae = ve > 4 || ve === 0 ? Lf.ceil(ae) : Lf(ae)),
              (ae = cu.offset(ae, (F.V - 1) * 7)),
              (F.y = ae.getFullYear()),
              (F.m = ae.getMonth()),
              (F.d = ae.getDate() + ((F.w + 6) % 7)))
      } else
        ("W" in F || "U" in F) &&
          ("w" in F || (F.w = "u" in F ? F.u % 7 : "W" in F ? 1 : 0),
          (ve =
            "Z" in F
              ? Lh(ss(F.y, 0, 1)).getUTCDay()
              : Rh(ss(F.y, 0, 1)).getDay()),
          (F.m = 0),
          (F.d =
            "W" in F
              ? ((F.w + 6) % 7) + F.W * 7 - ((ve + 5) % 7)
              : F.w + F.U * 7 - ((ve + 6) % 7)))
      return "Z" in F
        ? ((F.H += (F.Z / 100) | 0), (F.M += F.Z % 100), Lh(F))
        : Rh(F)
    }
  }
  function $(W, Q, Z, F) {
    for (var me = 0, ae = Q.length, ve = Z.length, je, Ke; me < ae; ) {
      if (F >= ve) return -1
      if (((je = Q.charCodeAt(me++)), je === 37)) {
        if (
          ((je = Q.charAt(me++)),
          (Ke = x[je in rO ? Q.charAt(me++) : je]),
          !Ke || (F = Ke(W, Z, F)) < 0)
        )
          return -1
      } else if (je != Z.charCodeAt(F++)) return -1
    }
    return F
  }
  function A(W, Q, Z) {
    var F = u.exec(Q.slice(Z))
    return F ? ((W.p = f.get(F[0].toLowerCase())), Z + F[0].length) : -1
  }
  function C(W, Q, Z) {
    var F = p.exec(Q.slice(Z))
    return F ? ((W.w = h.get(F[0].toLowerCase())), Z + F[0].length) : -1
  }
  function T(W, Q, Z) {
    var F = c.exec(Q.slice(Z))
    return F ? ((W.w = d.get(F[0].toLowerCase())), Z + F[0].length) : -1
  }
  function _(W, Q, Z) {
    var F = g.exec(Q.slice(Z))
    return F ? ((W.m = v.get(F[0].toLowerCase())), Z + F[0].length) : -1
  }
  function R(W, Q, Z) {
    var F = m.exec(Q.slice(Z))
    return F ? ((W.m = b.get(F[0].toLowerCase())), Z + F[0].length) : -1
  }
  function M(W, Q, Z) {
    return $(W, t, Q, Z)
  }
  function D(W, Q, Z) {
    return $(W, n, Q, Z)
  }
  function N(W, Q, Z) {
    return $(W, r, Q, Z)
  }
  function L(W) {
    return a[W.getDay()]
  }
  function k(W) {
    return o[W.getDay()]
  }
  function I(W) {
    return l[W.getMonth()]
  }
  function V(W) {
    return s[W.getMonth()]
  }
  function U(W) {
    return i[+(W.getHours() >= 12)]
  }
  function H(W) {
    return 1 + ~~(W.getMonth() / 3)
  }
  function ee(W) {
    return a[W.getUTCDay()]
  }
  function X(W) {
    return o[W.getUTCDay()]
  }
  function de(W) {
    return l[W.getUTCMonth()]
  }
  function ue(W) {
    return s[W.getUTCMonth()]
  }
  function We(W) {
    return i[+(W.getUTCHours() >= 12)]
  }
  function Qe(W) {
    return 1 + ~~(W.getUTCMonth() / 3)
  }
  return {
    format: function (W) {
      var Q = S((W += ""), y)
      return (
        (Q.toString = function () {
          return W
        }),
        Q
      )
    },
    parse: function (W) {
      var Q = O((W += ""), !1)
      return (
        (Q.toString = function () {
          return W
        }),
        Q
      )
    },
    utcFormat: function (W) {
      var Q = S((W += ""), w)
      return (
        (Q.toString = function () {
          return W
        }),
        Q
      )
    },
    utcParse: function (W) {
      var Q = O((W += ""), !0)
      return (
        (Q.toString = function () {
          return W
        }),
        Q
      )
    }
  }
}
var rO = { "-": "", _: " ", 0: "0" },
  ht = /^\s*\d+/,
  oZ = /^%/,
  aZ = /[\\^$*+?|[\]().{}]/g
function pe(e, t, n) {
  var r = e < 0 ? "-" : "",
    i = (r ? -e : e) + "",
    o = i.length
  return r + (o < n ? new Array(n - o + 1).join(t) + i : i)
}
function sZ(e) {
  return e.replace(aZ, "\\$&")
}
function ls(e) {
  return new RegExp("^(?:" + e.map(sZ).join("|") + ")", "i")
}
function us(e) {
  return new Map(e.map((t, n) => [t.toLowerCase(), n]))
}
function lZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 1))
  return r ? ((e.w = +r[0]), n + r[0].length) : -1
}
function uZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 1))
  return r ? ((e.u = +r[0]), n + r[0].length) : -1
}
function cZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 2))
  return r ? ((e.U = +r[0]), n + r[0].length) : -1
}
function fZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 2))
  return r ? ((e.V = +r[0]), n + r[0].length) : -1
}
function dZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 2))
  return r ? ((e.W = +r[0]), n + r[0].length) : -1
}
function iO(e, t, n) {
  var r = ht.exec(t.slice(n, n + 4))
  return r ? ((e.y = +r[0]), n + r[0].length) : -1
}
function oO(e, t, n) {
  var r = ht.exec(t.slice(n, n + 2))
  return r ? ((e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3)), n + r[0].length) : -1
}
function pZ(e, t, n) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(n, n + 6))
  return r ? ((e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00"))), n + r[0].length) : -1
}
function hZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 1))
  return r ? ((e.q = r[0] * 3 - 3), n + r[0].length) : -1
}
function mZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 2))
  return r ? ((e.m = r[0] - 1), n + r[0].length) : -1
}
function aO(e, t, n) {
  var r = ht.exec(t.slice(n, n + 2))
  return r ? ((e.d = +r[0]), n + r[0].length) : -1
}
function vZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 3))
  return r ? ((e.m = 0), (e.d = +r[0]), n + r[0].length) : -1
}
function sO(e, t, n) {
  var r = ht.exec(t.slice(n, n + 2))
  return r ? ((e.H = +r[0]), n + r[0].length) : -1
}
function gZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 2))
  return r ? ((e.M = +r[0]), n + r[0].length) : -1
}
function yZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 2))
  return r ? ((e.S = +r[0]), n + r[0].length) : -1
}
function bZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 3))
  return r ? ((e.L = +r[0]), n + r[0].length) : -1
}
function xZ(e, t, n) {
  var r = ht.exec(t.slice(n, n + 6))
  return r ? ((e.L = Math.floor(r[0] / 1e3)), n + r[0].length) : -1
}
function wZ(e, t, n) {
  var r = oZ.exec(t.slice(n, n + 1))
  return r ? n + r[0].length : -1
}
function SZ(e, t, n) {
  var r = ht.exec(t.slice(n))
  return r ? ((e.Q = +r[0]), n + r[0].length) : -1
}
function OZ(e, t, n) {
  var r = ht.exec(t.slice(n))
  return r ? ((e.s = +r[0]), n + r[0].length) : -1
}
function lO(e, t) {
  return pe(e.getDate(), t, 2)
}
function PZ(e, t) {
  return pe(e.getHours(), t, 2)
}
function $Z(e, t) {
  return pe(e.getHours() % 12 || 12, t, 2)
}
function AZ(e, t) {
  return pe(1 + cu.count(Or(e), e), t, 3)
}
function J_(e, t) {
  return pe(e.getMilliseconds(), t, 3)
}
function TZ(e, t) {
  return J_(e, t) + "000"
}
function EZ(e, t) {
  return pe(e.getMonth() + 1, t, 2)
}
function CZ(e, t) {
  return pe(e.getMinutes(), t, 2)
}
function _Z(e, t) {
  return pe(e.getSeconds(), t, 2)
}
function kZ(e) {
  var t = e.getDay()
  return t === 0 ? 7 : t
}
function MZ(e, t) {
  return pe(ip.count(Or(e) - 1, e), t, 2)
}
function ek(e) {
  var t = e.getDay()
  return t >= 4 || t === 0 ? ma(e) : ma.ceil(e)
}
function jZ(e, t) {
  return (e = ek(e)), pe(ma.count(Or(e), e) + (Or(e).getDay() === 4), t, 2)
}
function DZ(e) {
  return e.getDay()
}
function IZ(e, t) {
  return pe(Lf.count(Or(e) - 1, e), t, 2)
}
function NZ(e, t) {
  return pe(e.getFullYear() % 100, t, 2)
}
function RZ(e, t) {
  return (e = ek(e)), pe(e.getFullYear() % 100, t, 2)
}
function LZ(e, t) {
  return pe(e.getFullYear() % 1e4, t, 4)
}
function BZ(e, t) {
  var n = e.getDay()
  return (
    (e = n >= 4 || n === 0 ? ma(e) : ma.ceil(e)),
    pe(e.getFullYear() % 1e4, t, 4)
  )
}
function FZ(e) {
  var t = e.getTimezoneOffset()
  return (
    (t > 0 ? "-" : ((t *= -1), "+")) +
    pe((t / 60) | 0, "0", 2) +
    pe(t % 60, "0", 2)
  )
}
function uO(e, t) {
  return pe(e.getUTCDate(), t, 2)
}
function VZ(e, t) {
  return pe(e.getUTCHours(), t, 2)
}
function zZ(e, t) {
  return pe(e.getUTCHours() % 12 || 12, t, 2)
}
function UZ(e, t) {
  return pe(1 + rp.count(Pr(e), e), t, 3)
}
function tk(e, t) {
  return pe(e.getUTCMilliseconds(), t, 3)
}
function WZ(e, t) {
  return tk(e, t) + "000"
}
function HZ(e, t) {
  return pe(e.getUTCMonth() + 1, t, 2)
}
function GZ(e, t) {
  return pe(e.getUTCMinutes(), t, 2)
}
function KZ(e, t) {
  return pe(e.getUTCSeconds(), t, 2)
}
function qZ(e) {
  var t = e.getUTCDay()
  return t === 0 ? 7 : t
}
function XZ(e, t) {
  return pe(op.count(Pr(e) - 1, e), t, 2)
}
function nk(e) {
  var t = e.getUTCDay()
  return t >= 4 || t === 0 ? va(e) : va.ceil(e)
}
function YZ(e, t) {
  return (e = nk(e)), pe(va.count(Pr(e), e) + (Pr(e).getUTCDay() === 4), t, 2)
}
function QZ(e) {
  return e.getUTCDay()
}
function ZZ(e, t) {
  return pe(Bf.count(Pr(e) - 1, e), t, 2)
}
function JZ(e, t) {
  return pe(e.getUTCFullYear() % 100, t, 2)
}
function eJ(e, t) {
  return (e = nk(e)), pe(e.getUTCFullYear() % 100, t, 2)
}
function tJ(e, t) {
  return pe(e.getUTCFullYear() % 1e4, t, 4)
}
function nJ(e, t) {
  var n = e.getUTCDay()
  return (
    (e = n >= 4 || n === 0 ? va(e) : va.ceil(e)),
    pe(e.getUTCFullYear() % 1e4, t, 4)
  )
}
function rJ() {
  return "+0000"
}
function cO() {
  return "%"
}
function fO(e) {
  return +e
}
function dO(e) {
  return Math.floor(+e / 1e3)
}
var yo, rk, ik
iJ({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  shortMonths: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ]
})
function iJ(e) {
  return (
    (yo = iZ(e)),
    (rk = yo.format),
    yo.parse,
    (ik = yo.utcFormat),
    yo.utcParse,
    yo
  )
}
function oJ(e) {
  return new Date(e)
}
function aJ(e) {
  return e instanceof Date ? +e : +new Date(+e)
}
function B0(e, t, n, r, i, o, a, s, l, u) {
  var f = $0(),
    c = f.invert,
    d = f.domain,
    p = u(".%L"),
    h = u(":%S"),
    m = u("%I:%M"),
    b = u("%I %p"),
    g = u("%a %d"),
    v = u("%b %d"),
    y = u("%B"),
    w = u("%Y")
  function x(S) {
    return (
      l(S) < S
        ? p
        : s(S) < S
          ? h
          : a(S) < S
            ? m
            : o(S) < S
              ? b
              : r(S) < S
                ? i(S) < S
                  ? g
                  : v
                : n(S) < S
                  ? y
                  : w
    )(S)
  }
  return (
    (f.invert = function (S) {
      return new Date(c(S))
    }),
    (f.domain = function (S) {
      return arguments.length ? d(Array.from(S, aJ)) : d().map(oJ)
    }),
    (f.ticks = function (S) {
      var O = d()
      return e(O[0], O[O.length - 1], S ?? 10)
    }),
    (f.tickFormat = function (S, O) {
      return O == null ? x : u(O)
    }),
    (f.nice = function (S) {
      var O = d()
      return (
        (!S || typeof S.range != "function") &&
          (S = t(O[0], O[O.length - 1], S ?? 10)),
        S ? d(W_(O, S)) : f
      )
    }),
    (f.copy = function () {
      return uu(f, B0(e, t, n, r, i, o, a, s, l, u))
    }),
    f
  )
}
function sJ() {
  return xn.apply(
    B0(nZ, rZ, Or, R0, ip, cu, I0, j0, Ui, rk).domain([
      new Date(2e3, 0, 1),
      new Date(2e3, 0, 2)
    ]),
    arguments
  )
}
function lJ() {
  return xn.apply(
    B0(eZ, tZ, Pr, L0, op, rp, N0, D0, Ui, ik).domain([
      Date.UTC(2e3, 0, 1),
      Date.UTC(2e3, 0, 2)
    ]),
    arguments
  )
}
function ap() {
  var e = 0,
    t = 1,
    n,
    r,
    i,
    o,
    a = kt,
    s = !1,
    l
  function u(c) {
    return c == null || isNaN((c = +c))
      ? l
      : a(
          i === 0
            ? 0.5
            : ((c = (o(c) - n) * i), s ? Math.max(0, Math.min(1, c)) : c)
        )
  }
  ;(u.domain = function (c) {
    return arguments.length
      ? (([e, t] = c),
        (n = o((e = +e))),
        (r = o((t = +t))),
        (i = n === r ? 0 : 1 / (r - n)),
        u)
      : [e, t]
  }),
    (u.clamp = function (c) {
      return arguments.length ? ((s = !!c), u) : s
    }),
    (u.interpolator = function (c) {
      return arguments.length ? ((a = c), u) : a
    })
  function f(c) {
    return function (d) {
      var p, h
      return arguments.length ? (([p, h] = d), (a = c(p, h)), u) : [a(0), a(1)]
    }
  }
  return (
    (u.range = f(La)),
    (u.rangeRound = f(P0)),
    (u.unknown = function (c) {
      return arguments.length ? ((l = c), u) : l
    }),
    function (c) {
      return (o = c), (n = c(e)), (r = c(t)), (i = n === r ? 0 : 1 / (r - n)), u
    }
  )
}
function $i(e, t) {
  return t
    .domain(e.domain())
    .interpolator(e.interpolator())
    .clamp(e.clamp())
    .unknown(e.unknown())
}
function ok() {
  var e = Pi(ap()(kt))
  return (
    (e.copy = function () {
      return $i(e, ok())
    }),
    kr.apply(e, arguments)
  )
}
function ak() {
  var e = E0(ap()).domain([1, 10])
  return (
    (e.copy = function () {
      return $i(e, ak()).base(e.base())
    }),
    kr.apply(e, arguments)
  )
}
function sk() {
  var e = C0(ap())
  return (
    (e.copy = function () {
      return $i(e, sk()).constant(e.constant())
    }),
    kr.apply(e, arguments)
  )
}
function F0() {
  var e = _0(ap())
  return (
    (e.copy = function () {
      return $i(e, F0()).exponent(e.exponent())
    }),
    kr.apply(e, arguments)
  )
}
function uJ() {
  return F0.apply(null, arguments).exponent(0.5)
}
function lk() {
  var e = [],
    t = kt
  function n(r) {
    if (r != null && !isNaN((r = +r)))
      return t((su(e, r, 1) - 1) / (e.length - 1))
  }
  return (
    (n.domain = function (r) {
      if (!arguments.length) return e.slice()
      e = []
      for (let i of r) i != null && !isNaN((i = +i)) && e.push(i)
      return e.sort(li), n
    }),
    (n.interpolator = function (r) {
      return arguments.length ? ((t = r), n) : t
    }),
    (n.range = function () {
      return e.map((r, i) => t(i / (e.length - 1)))
    }),
    (n.quantiles = function (r) {
      return Array.from({ length: r + 1 }, (i, o) => XY(e, o / r))
    }),
    (n.copy = function () {
      return lk(t).domain(e)
    }),
    kr.apply(n, arguments)
  )
}
function sp() {
  var e = 0,
    t = 0.5,
    n = 1,
    r = 1,
    i,
    o,
    a,
    s,
    l,
    u = kt,
    f,
    c = !1,
    d
  function p(m) {
    return isNaN((m = +m))
      ? d
      : ((m = 0.5 + ((m = +f(m)) - o) * (r * m < r * o ? s : l)),
        u(c ? Math.max(0, Math.min(1, m)) : m))
  }
  ;(p.domain = function (m) {
    return arguments.length
      ? (([e, t, n] = m),
        (i = f((e = +e))),
        (o = f((t = +t))),
        (a = f((n = +n))),
        (s = i === o ? 0 : 0.5 / (o - i)),
        (l = o === a ? 0 : 0.5 / (a - o)),
        (r = o < i ? -1 : 1),
        p)
      : [e, t, n]
  }),
    (p.clamp = function (m) {
      return arguments.length ? ((c = !!m), p) : c
    }),
    (p.interpolator = function (m) {
      return arguments.length ? ((u = m), p) : u
    })
  function h(m) {
    return function (b) {
      var g, v, y
      return arguments.length
        ? (([g, v, y] = b), (u = wQ(m, [g, v, y])), p)
        : [u(0), u(0.5), u(1)]
    }
  }
  return (
    (p.range = h(La)),
    (p.rangeRound = h(P0)),
    (p.unknown = function (m) {
      return arguments.length ? ((d = m), p) : d
    }),
    function (m) {
      return (
        (f = m),
        (i = m(e)),
        (o = m(t)),
        (a = m(n)),
        (s = i === o ? 0 : 0.5 / (o - i)),
        (l = o === a ? 0 : 0.5 / (a - o)),
        (r = o < i ? -1 : 1),
        p
      )
    }
  )
}
function uk() {
  var e = Pi(sp()(kt))
  return (
    (e.copy = function () {
      return $i(e, uk())
    }),
    kr.apply(e, arguments)
  )
}
function ck() {
  var e = E0(sp()).domain([0.1, 1, 10])
  return (
    (e.copy = function () {
      return $i(e, ck()).base(e.base())
    }),
    kr.apply(e, arguments)
  )
}
function fk() {
  var e = C0(sp())
  return (
    (e.copy = function () {
      return $i(e, fk()).constant(e.constant())
    }),
    kr.apply(e, arguments)
  )
}
function V0() {
  var e = _0(sp())
  return (
    (e.copy = function () {
      return $i(e, V0()).exponent(e.exponent())
    }),
    kr.apply(e, arguments)
  )
}
function cJ() {
  return V0.apply(null, arguments).exponent(0.5)
}
const pO = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      scaleBand: ml,
      scaleDiverging: uk,
      scaleDivergingLog: ck,
      scaleDivergingPow: V0,
      scaleDivergingSqrt: cJ,
      scaleDivergingSymlog: fk,
      scaleIdentity: U_,
      scaleImplicit: Gv,
      scaleLinear: Nf,
      scaleLog: H_,
      scaleOrdinal: w0,
      scalePoint: Ns,
      scalePow: k0,
      scaleQuantile: q_,
      scaleQuantize: X_,
      scaleRadial: K_,
      scaleSequential: ok,
      scaleSequentialLog: ak,
      scaleSequentialPow: F0,
      scaleSequentialQuantile: lk,
      scaleSequentialSqrt: uJ,
      scaleSequentialSymlog: sk,
      scaleSqrt: WQ,
      scaleSymlog: G_,
      scaleThreshold: Y_,
      scaleTime: sJ,
      scaleUtc: lJ,
      tickFormat: z_
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
)
var fJ = Ca
function dJ(e, t, n) {
  for (var r = -1, i = e.length; ++r < i; ) {
    var o = e[r],
      a = t(o)
    if (a != null && (s === void 0 ? a === a && !fJ(a) : n(a, s)))
      var s = a,
        l = o
  }
  return l
}
var dk = dJ
function pJ(e, t) {
  return e > t
}
var hJ = pJ,
  mJ = dk,
  vJ = hJ,
  gJ = Na
function yJ(e) {
  return e && e.length ? mJ(e, gJ, vJ) : void 0
}
var bJ = yJ
const lp = Pe(bJ)
function xJ(e, t) {
  return e < t
}
var wJ = xJ,
  SJ = dk,
  OJ = wJ,
  PJ = Na
function $J(e) {
  return e && e.length ? SJ(e, PJ, OJ) : void 0
}
var AJ = $J
const up = Pe(AJ)
var TJ = Jy,
  EJ = Si,
  CJ = p_,
  _J = Ut
function kJ(e, t) {
  var n = _J(e) ? TJ : CJ
  return n(e, EJ(t))
}
var MJ = kJ,
  jJ = f_,
  DJ = MJ
function IJ(e, t) {
  return jJ(DJ(e, t), 1)
}
var NJ = IJ
const RJ = Pe(NJ)
var LJ = m0
function BJ(e, t) {
  return LJ(e, t)
}
var FJ = BJ
const z0 = Pe(FJ)
var Ba = 1e9,
  VJ = {
    precision: 20,
    rounding: 4,
    toExpNeg: -7,
    toExpPos: 21,
    LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
  },
  W0,
  Ie = !0,
  yn = "[DecimalError] ",
  qi = yn + "Invalid argument: ",
  U0 = yn + "Exponent out of range: ",
  Fa = Math.floor,
  Ii = Math.pow,
  zJ = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
  Kt,
  lt = 1e7,
  _e = 7,
  pk = 9007199254740991,
  Ff = Fa(pk / _e),
  q = {}
q.absoluteValue = q.abs = function () {
  var e = new this.constructor(this)
  return e.s && (e.s = 1), e
}
q.comparedTo = q.cmp = function (e) {
  var t,
    n,
    r,
    i,
    o = this
  if (((e = new o.constructor(e)), o.s !== e.s)) return o.s || -e.s
  if (o.e !== e.e) return (o.e > e.e) ^ (o.s < 0) ? 1 : -1
  for (r = o.d.length, i = e.d.length, t = 0, n = r < i ? r : i; t < n; ++t)
    if (o.d[t] !== e.d[t]) return (o.d[t] > e.d[t]) ^ (o.s < 0) ? 1 : -1
  return r === i ? 0 : (r > i) ^ (o.s < 0) ? 1 : -1
}
q.decimalPlaces = q.dp = function () {
  var e = this,
    t = e.d.length - 1,
    n = (t - e.e) * _e
  if (((t = e.d[t]), t)) for (; t % 10 == 0; t /= 10) n--
  return n < 0 ? 0 : n
}
q.dividedBy = q.div = function (e) {
  return mr(this, new this.constructor(e))
}
q.dividedToIntegerBy = q.idiv = function (e) {
  var t = this,
    n = t.constructor
  return Se(mr(t, new n(e), 0, 1), n.precision)
}
q.equals = q.eq = function (e) {
  return !this.cmp(e)
}
q.exponent = function () {
  return Ye(this)
}
q.greaterThan = q.gt = function (e) {
  return this.cmp(e) > 0
}
q.greaterThanOrEqualTo = q.gte = function (e) {
  return this.cmp(e) >= 0
}
q.isInteger = q.isint = function () {
  return this.e > this.d.length - 2
}
q.isNegative = q.isneg = function () {
  return this.s < 0
}
q.isPositive = q.ispos = function () {
  return this.s > 0
}
q.isZero = function () {
  return this.s === 0
}
q.lessThan = q.lt = function (e) {
  return this.cmp(e) < 0
}
q.lessThanOrEqualTo = q.lte = function (e) {
  return this.cmp(e) < 1
}
q.logarithm = q.log = function (e) {
  var t,
    n = this,
    r = n.constructor,
    i = r.precision,
    o = i + 5
  if (e === void 0) e = new r(10)
  else if (((e = new r(e)), e.s < 1 || e.eq(Kt))) throw Error(yn + "NaN")
  if (n.s < 1) throw Error(yn + (n.s ? "NaN" : "-Infinity"))
  return n.eq(Kt)
    ? new r(0)
    : ((Ie = !1), (t = mr(xl(n, o), xl(e, o), o)), (Ie = !0), Se(t, i))
}
q.minus = q.sub = function (e) {
  var t = this
  return (
    (e = new t.constructor(e)), t.s == e.s ? vk(t, e) : hk(t, ((e.s = -e.s), e))
  )
}
q.modulo = q.mod = function (e) {
  var t,
    n = this,
    r = n.constructor,
    i = r.precision
  if (((e = new r(e)), !e.s)) throw Error(yn + "NaN")
  return n.s
    ? ((Ie = !1), (t = mr(n, e, 0, 1).times(e)), (Ie = !0), n.minus(t))
    : Se(new r(n), i)
}
q.naturalExponential = q.exp = function () {
  return mk(this)
}
q.naturalLogarithm = q.ln = function () {
  return xl(this)
}
q.negated = q.neg = function () {
  var e = new this.constructor(this)
  return (e.s = -e.s || 0), e
}
q.plus = q.add = function (e) {
  var t = this
  return (
    (e = new t.constructor(e)), t.s == e.s ? hk(t, e) : vk(t, ((e.s = -e.s), e))
  )
}
q.precision = q.sd = function (e) {
  var t,
    n,
    r,
    i = this
  if (e !== void 0 && e !== !!e && e !== 1 && e !== 0) throw Error(qi + e)
  if (
    ((t = Ye(i) + 1), (r = i.d.length - 1), (n = r * _e + 1), (r = i.d[r]), r)
  ) {
    for (; r % 10 == 0; r /= 10) n--
    for (r = i.d[0]; r >= 10; r /= 10) n++
  }
  return e && t > n ? t : n
}
q.squareRoot = q.sqrt = function () {
  var e,
    t,
    n,
    r,
    i,
    o,
    a,
    s = this,
    l = s.constructor
  if (s.s < 1) {
    if (!s.s) return new l(0)
    throw Error(yn + "NaN")
  }
  for (
    e = Ye(s),
      Ie = !1,
      i = Math.sqrt(+s),
      i == 0 || i == 1 / 0
        ? ((t = Un(s.d)),
          (t.length + e) % 2 == 0 && (t += "0"),
          (i = Math.sqrt(t)),
          (e = Fa((e + 1) / 2) - (e < 0 || e % 2)),
          i == 1 / 0
            ? (t = "5e" + e)
            : ((t = i.toExponential()),
              (t = t.slice(0, t.indexOf("e") + 1) + e)),
          (r = new l(t)))
        : (r = new l(i.toString())),
      n = l.precision,
      i = a = n + 3;
    ;

  )
    if (
      ((o = r),
      (r = o.plus(mr(s, o, a + 2)).times(0.5)),
      Un(o.d).slice(0, a) === (t = Un(r.d)).slice(0, a))
    ) {
      if (((t = t.slice(a - 3, a + 1)), i == a && t == "4999")) {
        if ((Se(o, n + 1, 0), o.times(o).eq(s))) {
          r = o
          break
        }
      } else if (t != "9999") break
      a += 4
    }
  return (Ie = !0), Se(r, n)
}
q.times = q.mul = function (e) {
  var t,
    n,
    r,
    i,
    o,
    a,
    s,
    l,
    u,
    f = this,
    c = f.constructor,
    d = f.d,
    p = (e = new c(e)).d
  if (!f.s || !e.s) return new c(0)
  for (
    e.s *= f.s,
      n = f.e + e.e,
      l = d.length,
      u = p.length,
      l < u && ((o = d), (d = p), (p = o), (a = l), (l = u), (u = a)),
      o = [],
      a = l + u,
      r = a;
    r--;

  )
    o.push(0)
  for (r = u; --r >= 0; ) {
    for (t = 0, i = l + r; i > r; )
      (s = o[i] + p[r] * d[i - r - 1] + t),
        (o[i--] = s % lt | 0),
        (t = (s / lt) | 0)
    o[i] = (o[i] + t) % lt | 0
  }
  for (; !o[--a]; ) o.pop()
  return t ? ++n : o.shift(), (e.d = o), (e.e = n), Ie ? Se(e, c.precision) : e
}
q.toDecimalPlaces = q.todp = function (e, t) {
  var n = this,
    r = n.constructor
  return (
    (n = new r(n)),
    e === void 0
      ? n
      : (Xn(e, 0, Ba),
        t === void 0 ? (t = r.rounding) : Xn(t, 0, 8),
        Se(n, e + Ye(n) + 1, t))
  )
}
q.toExponential = function (e, t) {
  var n,
    r = this,
    i = r.constructor
  return (
    e === void 0
      ? (n = to(r, !0))
      : (Xn(e, 0, Ba),
        t === void 0 ? (t = i.rounding) : Xn(t, 0, 8),
        (r = Se(new i(r), e + 1, t)),
        (n = to(r, !0, e + 1))),
    n
  )
}
q.toFixed = function (e, t) {
  var n,
    r,
    i = this,
    o = i.constructor
  return e === void 0
    ? to(i)
    : (Xn(e, 0, Ba),
      t === void 0 ? (t = o.rounding) : Xn(t, 0, 8),
      (r = Se(new o(i), e + Ye(i) + 1, t)),
      (n = to(r.abs(), !1, e + Ye(r) + 1)),
      i.isneg() && !i.isZero() ? "-" + n : n)
}
q.toInteger = q.toint = function () {
  var e = this,
    t = e.constructor
  return Se(new t(e), Ye(e) + 1, t.rounding)
}
q.toNumber = function () {
  return +this
}
q.toPower = q.pow = function (e) {
  var t,
    n,
    r,
    i,
    o,
    a,
    s = this,
    l = s.constructor,
    u = 12,
    f = +(e = new l(e))
  if (!e.s) return new l(Kt)
  if (((s = new l(s)), !s.s)) {
    if (e.s < 1) throw Error(yn + "Infinity")
    return s
  }
  if (s.eq(Kt)) return s
  if (((r = l.precision), e.eq(Kt))) return Se(s, r)
  if (((t = e.e), (n = e.d.length - 1), (a = t >= n), (o = s.s), a)) {
    if ((n = f < 0 ? -f : f) <= pk) {
      for (
        i = new l(Kt), t = Math.ceil(r / _e + 4), Ie = !1;
        n % 2 && ((i = i.times(s)), mO(i.d, t)), (n = Fa(n / 2)), n !== 0;

      )
        (s = s.times(s)), mO(s.d, t)
      return (Ie = !0), e.s < 0 ? new l(Kt).div(i) : Se(i, r)
    }
  } else if (o < 0) throw Error(yn + "NaN")
  return (
    (o = o < 0 && e.d[Math.max(t, n)] & 1 ? -1 : 1),
    (s.s = 1),
    (Ie = !1),
    (i = e.times(xl(s, r + u))),
    (Ie = !0),
    (i = mk(i)),
    (i.s = o),
    i
  )
}
q.toPrecision = function (e, t) {
  var n,
    r,
    i = this,
    o = i.constructor
  return (
    e === void 0
      ? ((n = Ye(i)), (r = to(i, n <= o.toExpNeg || n >= o.toExpPos)))
      : (Xn(e, 1, Ba),
        t === void 0 ? (t = o.rounding) : Xn(t, 0, 8),
        (i = Se(new o(i), e, t)),
        (n = Ye(i)),
        (r = to(i, e <= n || n <= o.toExpNeg, e))),
    r
  )
}
q.toSignificantDigits = q.tosd = function (e, t) {
  var n = this,
    r = n.constructor
  return (
    e === void 0
      ? ((e = r.precision), (t = r.rounding))
      : (Xn(e, 1, Ba), t === void 0 ? (t = r.rounding) : Xn(t, 0, 8)),
    Se(new r(n), e, t)
  )
}
q.toString =
  q.valueOf =
  q.val =
  q.toJSON =
  q[Symbol.for("nodejs.util.inspect.custom")] =
    function () {
      var e = this,
        t = Ye(e),
        n = e.constructor
      return to(e, t <= n.toExpNeg || t >= n.toExpPos)
    }
function hk(e, t) {
  var n,
    r,
    i,
    o,
    a,
    s,
    l,
    u,
    f = e.constructor,
    c = f.precision
  if (!e.s || !t.s) return t.s || (t = new f(e)), Ie ? Se(t, c) : t
  if (
    ((l = e.d),
    (u = t.d),
    (a = e.e),
    (i = t.e),
    (l = l.slice()),
    (o = a - i),
    o)
  ) {
    for (
      o < 0
        ? ((r = l), (o = -o), (s = u.length))
        : ((r = u), (i = a), (s = l.length)),
        a = Math.ceil(c / _e),
        s = a > s ? a + 1 : s + 1,
        o > s && ((o = s), (r.length = 1)),
        r.reverse();
      o--;

    )
      r.push(0)
    r.reverse()
  }
  for (
    s = l.length,
      o = u.length,
      s - o < 0 && ((o = s), (r = u), (u = l), (l = r)),
      n = 0;
    o;

  )
    (n = ((l[--o] = l[o] + u[o] + n) / lt) | 0), (l[o] %= lt)
  for (n && (l.unshift(n), ++i), s = l.length; l[--s] == 0; ) l.pop()
  return (t.d = l), (t.e = i), Ie ? Se(t, c) : t
}
function Xn(e, t, n) {
  if (e !== ~~e || e < t || e > n) throw Error(qi + e)
}
function Un(e) {
  var t,
    n,
    r,
    i = e.length - 1,
    o = "",
    a = e[0]
  if (i > 0) {
    for (o += a, t = 1; t < i; t++)
      (r = e[t] + ""), (n = _e - r.length), n && (o += Hr(n)), (o += r)
    ;(a = e[t]), (r = a + ""), (n = _e - r.length), n && (o += Hr(n))
  } else if (a === 0) return "0"
  for (; a % 10 === 0; ) a /= 10
  return o + a
}
var mr = (function () {
  function e(r, i) {
    var o,
      a = 0,
      s = r.length
    for (r = r.slice(); s--; )
      (o = r[s] * i + a), (r[s] = o % lt | 0), (a = (o / lt) | 0)
    return a && r.unshift(a), r
  }
  function t(r, i, o, a) {
    var s, l
    if (o != a) l = o > a ? 1 : -1
    else
      for (s = l = 0; s < o; s++)
        if (r[s] != i[s]) {
          l = r[s] > i[s] ? 1 : -1
          break
        }
    return l
  }
  function n(r, i, o) {
    for (var a = 0; o--; )
      (r[o] -= a), (a = r[o] < i[o] ? 1 : 0), (r[o] = a * lt + r[o] - i[o])
    for (; !r[0] && r.length > 1; ) r.shift()
  }
  return function (r, i, o, a) {
    var s,
      l,
      u,
      f,
      c,
      d,
      p,
      h,
      m,
      b,
      g,
      v,
      y,
      w,
      x,
      S,
      O,
      $,
      A = r.constructor,
      C = r.s == i.s ? 1 : -1,
      T = r.d,
      _ = i.d
    if (!r.s) return new A(r)
    if (!i.s) throw Error(yn + "Division by zero")
    for (
      l = r.e - i.e,
        O = _.length,
        x = T.length,
        p = new A(C),
        h = p.d = [],
        u = 0;
      _[u] == (T[u] || 0);

    )
      ++u
    if (
      (_[u] > (T[u] || 0) && --l,
      o == null
        ? (v = o = A.precision)
        : a
          ? (v = o + (Ye(r) - Ye(i)) + 1)
          : (v = o),
      v < 0)
    )
      return new A(0)
    if (((v = (v / _e + 2) | 0), (u = 0), O == 1))
      for (f = 0, _ = _[0], v++; (u < x || f) && v--; u++)
        (y = f * lt + (T[u] || 0)), (h[u] = (y / _) | 0), (f = y % _ | 0)
    else {
      for (
        f = (lt / (_[0] + 1)) | 0,
          f > 1 &&
            ((_ = e(_, f)), (T = e(T, f)), (O = _.length), (x = T.length)),
          w = O,
          m = T.slice(0, O),
          b = m.length;
        b < O;

      )
        m[b++] = 0
      ;($ = _.slice()), $.unshift(0), (S = _[0]), _[1] >= lt / 2 && ++S
      do
        (f = 0),
          (s = t(_, m, O, b)),
          s < 0
            ? ((g = m[0]),
              O != b && (g = g * lt + (m[1] || 0)),
              (f = (g / S) | 0),
              f > 1
                ? (f >= lt && (f = lt - 1),
                  (c = e(_, f)),
                  (d = c.length),
                  (b = m.length),
                  (s = t(c, m, d, b)),
                  s == 1 && (f--, n(c, O < d ? $ : _, d)))
                : (f == 0 && (s = f = 1), (c = _.slice())),
              (d = c.length),
              d < b && c.unshift(0),
              n(m, c, b),
              s == -1 &&
                ((b = m.length),
                (s = t(_, m, O, b)),
                s < 1 && (f++, n(m, O < b ? $ : _, b))),
              (b = m.length))
            : s === 0 && (f++, (m = [0])),
          (h[u++] = f),
          s && m[0] ? (m[b++] = T[w] || 0) : ((m = [T[w]]), (b = 1))
      while ((w++ < x || m[0] !== void 0) && v--)
    }
    return h[0] || h.shift(), (p.e = l), Se(p, a ? o + Ye(p) + 1 : o)
  }
})()
function mk(e, t) {
  var n,
    r,
    i,
    o,
    a,
    s,
    l = 0,
    u = 0,
    f = e.constructor,
    c = f.precision
  if (Ye(e) > 16) throw Error(U0 + Ye(e))
  if (!e.s) return new f(Kt)
  for (
    t == null ? ((Ie = !1), (s = c)) : (s = t), a = new f(0.03125);
    e.abs().gte(0.1);

  )
    (e = e.times(a)), (u += 5)
  for (
    r = ((Math.log(Ii(2, u)) / Math.LN10) * 2 + 5) | 0,
      s += r,
      n = i = o = new f(Kt),
      f.precision = s;
    ;

  ) {
    if (
      ((i = Se(i.times(e), s)),
      (n = n.times(++l)),
      (a = o.plus(mr(i, n, s))),
      Un(a.d).slice(0, s) === Un(o.d).slice(0, s))
    ) {
      for (; u--; ) o = Se(o.times(o), s)
      return (f.precision = c), t == null ? ((Ie = !0), Se(o, c)) : o
    }
    o = a
  }
}
function Ye(e) {
  for (var t = e.e * _e, n = e.d[0]; n >= 10; n /= 10) t++
  return t
}
function Bh(e, t, n) {
  if (t > e.LN10.sd())
    throw (
      ((Ie = !0),
      n && (e.precision = n),
      Error(yn + "LN10 precision limit exceeded"))
    )
  return Se(new e(e.LN10), t)
}
function Hr(e) {
  for (var t = ""; e--; ) t += "0"
  return t
}
function xl(e, t) {
  var n,
    r,
    i,
    o,
    a,
    s,
    l,
    u,
    f,
    c = 1,
    d = 10,
    p = e,
    h = p.d,
    m = p.constructor,
    b = m.precision
  if (p.s < 1) throw Error(yn + (p.s ? "NaN" : "-Infinity"))
  if (p.eq(Kt)) return new m(0)
  if ((t == null ? ((Ie = !1), (u = b)) : (u = t), p.eq(10)))
    return t == null && (Ie = !0), Bh(m, u)
  if (
    ((u += d),
    (m.precision = u),
    (n = Un(h)),
    (r = n.charAt(0)),
    (o = Ye(p)),
    Math.abs(o) < 15e14)
  ) {
    for (; (r < 7 && r != 1) || (r == 1 && n.charAt(1) > 3); )
      (p = p.times(e)), (n = Un(p.d)), (r = n.charAt(0)), c++
    ;(o = Ye(p)),
      r > 1 ? ((p = new m("0." + n)), o++) : (p = new m(r + "." + n.slice(1)))
  } else
    return (
      (l = Bh(m, u + 2, b).times(o + "")),
      (p = xl(new m(r + "." + n.slice(1)), u - d).plus(l)),
      (m.precision = b),
      t == null ? ((Ie = !0), Se(p, b)) : p
    )
  for (
    s = a = p = mr(p.minus(Kt), p.plus(Kt), u), f = Se(p.times(p), u), i = 3;
    ;

  ) {
    if (
      ((a = Se(a.times(f), u)),
      (l = s.plus(mr(a, new m(i), u))),
      Un(l.d).slice(0, u) === Un(s.d).slice(0, u))
    )
      return (
        (s = s.times(2)),
        o !== 0 && (s = s.plus(Bh(m, u + 2, b).times(o + ""))),
        (s = mr(s, new m(c), u)),
        (m.precision = b),
        t == null ? ((Ie = !0), Se(s, b)) : s
      )
    ;(s = l), (i += 2)
  }
}
function hO(e, t) {
  var n, r, i
  for (
    (n = t.indexOf(".")) > -1 && (t = t.replace(".", "")),
      (r = t.search(/e/i)) > 0
        ? (n < 0 && (n = r), (n += +t.slice(r + 1)), (t = t.substring(0, r)))
        : n < 0 && (n = t.length),
      r = 0;
    t.charCodeAt(r) === 48;

  )
    ++r
  for (i = t.length; t.charCodeAt(i - 1) === 48; ) --i
  if (((t = t.slice(r, i)), t)) {
    if (
      ((i -= r),
      (n = n - r - 1),
      (e.e = Fa(n / _e)),
      (e.d = []),
      (r = (n + 1) % _e),
      n < 0 && (r += _e),
      r < i)
    ) {
      for (r && e.d.push(+t.slice(0, r)), i -= _e; r < i; )
        e.d.push(+t.slice(r, (r += _e)))
      ;(t = t.slice(r)), (r = _e - t.length)
    } else r -= i
    for (; r--; ) t += "0"
    if ((e.d.push(+t), Ie && (e.e > Ff || e.e < -Ff))) throw Error(U0 + n)
  } else (e.s = 0), (e.e = 0), (e.d = [0])
  return e
}
function Se(e, t, n) {
  var r,
    i,
    o,
    a,
    s,
    l,
    u,
    f,
    c = e.d
  for (a = 1, o = c[0]; o >= 10; o /= 10) a++
  if (((r = t - a), r < 0)) (r += _e), (i = t), (u = c[(f = 0)])
  else {
    if (((f = Math.ceil((r + 1) / _e)), (o = c.length), f >= o)) return e
    for (u = o = c[f], a = 1; o >= 10; o /= 10) a++
    ;(r %= _e), (i = r - _e + a)
  }
  if (
    (n !== void 0 &&
      ((o = Ii(10, a - i - 1)),
      (s = (u / o) % 10 | 0),
      (l = t < 0 || c[f + 1] !== void 0 || u % o),
      (l =
        n < 4
          ? (s || l) && (n == 0 || n == (e.s < 0 ? 3 : 2))
          : s > 5 ||
            (s == 5 &&
              (n == 4 ||
                l ||
                (n == 6 &&
                  (r > 0 ? (i > 0 ? u / Ii(10, a - i) : 0) : c[f - 1]) % 10 &
                    1) ||
                n == (e.s < 0 ? 8 : 7))))),
    t < 1 || !c[0])
  )
    return (
      l
        ? ((o = Ye(e)),
          (c.length = 1),
          (t = t - o - 1),
          (c[0] = Ii(10, (_e - (t % _e)) % _e)),
          (e.e = Fa(-t / _e) || 0))
        : ((c.length = 1), (c[0] = e.e = e.s = 0)),
      e
    )
  if (
    (r == 0
      ? ((c.length = f), (o = 1), f--)
      : ((c.length = f + 1),
        (o = Ii(10, _e - r)),
        (c[f] = i > 0 ? ((u / Ii(10, a - i)) % Ii(10, i) | 0) * o : 0)),
    l)
  )
    for (;;)
      if (f == 0) {
        ;(c[0] += o) == lt && ((c[0] = 1), ++e.e)
        break
      } else {
        if (((c[f] += o), c[f] != lt)) break
        ;(c[f--] = 0), (o = 1)
      }
  for (r = c.length; c[--r] === 0; ) c.pop()
  if (Ie && (e.e > Ff || e.e < -Ff)) throw Error(U0 + Ye(e))
  return e
}
function vk(e, t) {
  var n,
    r,
    i,
    o,
    a,
    s,
    l,
    u,
    f,
    c,
    d = e.constructor,
    p = d.precision
  if (!e.s || !t.s)
    return t.s ? (t.s = -t.s) : (t = new d(e)), Ie ? Se(t, p) : t
  if (
    ((l = e.d),
    (c = t.d),
    (r = t.e),
    (u = e.e),
    (l = l.slice()),
    (a = u - r),
    a)
  ) {
    for (
      f = a < 0,
        f
          ? ((n = l), (a = -a), (s = c.length))
          : ((n = c), (r = u), (s = l.length)),
        i = Math.max(Math.ceil(p / _e), s) + 2,
        a > i && ((a = i), (n.length = 1)),
        n.reverse(),
        i = a;
      i--;

    )
      n.push(0)
    n.reverse()
  } else {
    for (i = l.length, s = c.length, f = i < s, f && (s = i), i = 0; i < s; i++)
      if (l[i] != c[i]) {
        f = l[i] < c[i]
        break
      }
    a = 0
  }
  for (
    f && ((n = l), (l = c), (c = n), (t.s = -t.s)),
      s = l.length,
      i = c.length - s;
    i > 0;
    --i
  )
    l[s++] = 0
  for (i = c.length; i > a; ) {
    if (l[--i] < c[i]) {
      for (o = i; o && l[--o] === 0; ) l[o] = lt - 1
      --l[o], (l[i] += lt)
    }
    l[i] -= c[i]
  }
  for (; l[--s] === 0; ) l.pop()
  for (; l[0] === 0; l.shift()) --r
  return l[0] ? ((t.d = l), (t.e = r), Ie ? Se(t, p) : t) : new d(0)
}
function to(e, t, n) {
  var r,
    i = Ye(e),
    o = Un(e.d),
    a = o.length
  return (
    t
      ? (n && (r = n - a) > 0
          ? (o = o.charAt(0) + "." + o.slice(1) + Hr(r))
          : a > 1 && (o = o.charAt(0) + "." + o.slice(1)),
        (o = o + (i < 0 ? "e" : "e+") + i))
      : i < 0
        ? ((o = "0." + Hr(-i - 1) + o), n && (r = n - a) > 0 && (o += Hr(r)))
        : i >= a
          ? ((o += Hr(i + 1 - a)),
            n && (r = n - i - 1) > 0 && (o = o + "." + Hr(r)))
          : ((r = i + 1) < a && (o = o.slice(0, r) + "." + o.slice(r)),
            n && (r = n - a) > 0 && (i + 1 === a && (o += "."), (o += Hr(r)))),
    e.s < 0 ? "-" + o : o
  )
}
function mO(e, t) {
  if (e.length > t) return (e.length = t), !0
}
function gk(e) {
  var t, n, r
  function i(o) {
    var a = this
    if (!(a instanceof i)) return new i(o)
    if (((a.constructor = i), o instanceof i)) {
      ;(a.s = o.s), (a.e = o.e), (a.d = (o = o.d) ? o.slice() : o)
      return
    }
    if (typeof o == "number") {
      if (o * 0 !== 0) throw Error(qi + o)
      if (o > 0) a.s = 1
      else if (o < 0) (o = -o), (a.s = -1)
      else {
        ;(a.s = 0), (a.e = 0), (a.d = [0])
        return
      }
      if (o === ~~o && o < 1e7) {
        ;(a.e = 0), (a.d = [o])
        return
      }
      return hO(a, o.toString())
    } else if (typeof o != "string") throw Error(qi + o)
    if (
      (o.charCodeAt(0) === 45 ? ((o = o.slice(1)), (a.s = -1)) : (a.s = 1),
      zJ.test(o))
    )
      hO(a, o)
    else throw Error(qi + o)
  }
  if (
    ((i.prototype = q),
    (i.ROUND_UP = 0),
    (i.ROUND_DOWN = 1),
    (i.ROUND_CEIL = 2),
    (i.ROUND_FLOOR = 3),
    (i.ROUND_HALF_UP = 4),
    (i.ROUND_HALF_DOWN = 5),
    (i.ROUND_HALF_EVEN = 6),
    (i.ROUND_HALF_CEIL = 7),
    (i.ROUND_HALF_FLOOR = 8),
    (i.clone = gk),
    (i.config = i.set = UJ),
    e === void 0 && (e = {}),
    e)
  )
    for (
      r = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], t = 0;
      t < r.length;

    )
      e.hasOwnProperty((n = r[t++])) || (e[n] = this[n])
  return i.config(e), i
}
function UJ(e) {
  if (!e || typeof e != "object") throw Error(yn + "Object expected")
  var t,
    n,
    r,
    i = [
      "precision",
      1,
      Ba,
      "rounding",
      0,
      8,
      "toExpNeg",
      -1 / 0,
      0,
      "toExpPos",
      0,
      1 / 0
    ]
  for (t = 0; t < i.length; t += 3)
    if ((r = e[(n = i[t])]) !== void 0)
      if (Fa(r) === r && r >= i[t + 1] && r <= i[t + 2]) this[n] = r
      else throw Error(qi + n + ": " + r)
  if ((r = e[(n = "LN10")]) !== void 0)
    if (r == Math.LN10) this[n] = new this(r)
    else throw Error(qi + n + ": " + r)
  return this
}
var W0 = gk(VJ)
Kt = new W0(1)
const be = W0
function WJ(e) {
  return qJ(e) || KJ(e) || GJ(e) || HJ()
}
function HJ() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function GJ(e, t) {
  if (e) {
    if (typeof e == "string") return Yv(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Yv(e, t)
  }
}
function KJ(e) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e)
}
function qJ(e) {
  if (Array.isArray(e)) return Yv(e)
}
function Yv(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
var XJ = function (t) {
    return t
  },
  yk = { "@@functional/placeholder": !0 },
  bk = function (t) {
    return t === yk
  },
  vO = function (t) {
    return function n() {
      return arguments.length === 0 ||
        (arguments.length === 1 &&
          bk(arguments.length <= 0 ? void 0 : arguments[0]))
        ? n
        : t.apply(void 0, arguments)
    }
  },
  YJ = function e(t, n) {
    return t === 1
      ? n
      : vO(function () {
          for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)
            i[o] = arguments[o]
          var a = i.filter(function (s) {
            return s !== yk
          }).length
          return a >= t
            ? n.apply(void 0, i)
            : e(
                t - a,
                vO(function () {
                  for (
                    var s = arguments.length, l = new Array(s), u = 0;
                    u < s;
                    u++
                  )
                    l[u] = arguments[u]
                  var f = i.map(function (c) {
                    return bk(c) ? l.shift() : c
                  })
                  return n.apply(void 0, WJ(f).concat(l))
                })
              )
        })
  },
  cp = function (t) {
    return YJ(t.length, t)
  },
  Qv = function (t, n) {
    for (var r = [], i = t; i < n; ++i) r[i - t] = i
    return r
  },
  QJ = cp(function (e, t) {
    return Array.isArray(t)
      ? t.map(e)
      : Object.keys(t)
          .map(function (n) {
            return t[n]
          })
          .map(e)
  }),
  ZJ = function () {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r]
    if (!n.length) return XJ
    var i = n.reverse(),
      o = i[0],
      a = i.slice(1)
    return function () {
      return a.reduce(
        function (s, l) {
          return l(s)
        },
        o.apply(void 0, arguments)
      )
    }
  },
  Zv = function (t) {
    return Array.isArray(t) ? t.reverse() : t.split("").reverse.join("")
  },
  xk = function (t) {
    var n = null,
      r = null
    return function () {
      for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)
        o[a] = arguments[a]
      return (
        (n &&
          o.every(function (s, l) {
            return s === n[l]
          })) ||
          ((n = o), (r = t.apply(void 0, o))),
        r
      )
    }
  }
function JJ(e) {
  var t
  return (
    e === 0
      ? (t = 1)
      : (t = Math.floor(new be(e).abs().log(10).toNumber()) + 1),
    t
  )
}
function eee(e, t, n) {
  for (var r = new be(e), i = 0, o = []; r.lt(t) && i < 1e5; )
    o.push(r.toNumber()), (r = r.add(n)), i++
  return o
}
var tee = cp(function (e, t, n) {
    var r = +e,
      i = +t
    return r + n * (i - r)
  }),
  nee = cp(function (e, t, n) {
    var r = t - +e
    return (r = r || 1 / 0), (n - e) / r
  }),
  ree = cp(function (e, t, n) {
    var r = t - +e
    return (r = r || 1 / 0), Math.max(0, Math.min(1, (n - e) / r))
  })
const fp = {
  rangeStep: eee,
  getDigitCount: JJ,
  interpolateNumber: tee,
  uninterpolateNumber: nee,
  uninterpolateTruncation: ree
}
function Jv(e) {
  return aee(e) || oee(e) || wk(e) || iee()
}
function iee() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function oee(e) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(e)) return Array.from(e)
}
function aee(e) {
  if (Array.isArray(e)) return eg(e)
}
function wl(e, t) {
  return uee(e) || lee(e, t) || wk(e, t) || see()
}
function see() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function wk(e, t) {
  if (e) {
    if (typeof e == "string") return eg(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return eg(e, t)
  }
}
function eg(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function lee(e, t) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(e)))) {
    var n = [],
      r = !0,
      i = !1,
      o = void 0
    try {
      for (
        var a = e[Symbol.iterator](), s;
        !(r = (s = a.next()).done) && (n.push(s.value), !(t && n.length === t));
        r = !0
      );
    } catch (l) {
      ;(i = !0), (o = l)
    } finally {
      try {
        !r && a.return != null && a.return()
      } finally {
        if (i) throw o
      }
    }
    return n
  }
}
function uee(e) {
  if (Array.isArray(e)) return e
}
function Sk(e) {
  var t = wl(e, 2),
    n = t[0],
    r = t[1],
    i = n,
    o = r
  return n > r && ((i = r), (o = n)), [i, o]
}
function Ok(e, t, n) {
  if (e.lte(0)) return new be(0)
  var r = fp.getDigitCount(e.toNumber()),
    i = new be(10).pow(r),
    o = e.div(i),
    a = r !== 1 ? 0.05 : 0.1,
    s = new be(Math.ceil(o.div(a).toNumber())).add(n).mul(a),
    l = s.mul(i)
  return t ? l : new be(Math.ceil(l))
}
function cee(e, t, n) {
  var r = 1,
    i = new be(e)
  if (!i.isint() && n) {
    var o = Math.abs(e)
    o < 1
      ? ((r = new be(10).pow(fp.getDigitCount(e) - 1)),
        (i = new be(Math.floor(i.div(r).toNumber())).mul(r)))
      : o > 1 && (i = new be(Math.floor(e)))
  } else
    e === 0
      ? (i = new be(Math.floor((t - 1) / 2)))
      : n || (i = new be(Math.floor(e)))
  var a = Math.floor((t - 1) / 2),
    s = ZJ(
      QJ(function (l) {
        return i.add(new be(l - a).mul(r)).toNumber()
      }),
      Qv
    )
  return s(0, t)
}
function Pk(e, t, n, r) {
  var i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0
  if (!Number.isFinite((t - e) / (n - 1)))
    return { step: new be(0), tickMin: new be(0), tickMax: new be(0) }
  var o = Ok(new be(t).sub(e).div(n - 1), r, i),
    a
  e <= 0 && t >= 0
    ? (a = new be(0))
    : ((a = new be(e).add(t).div(2)), (a = a.sub(new be(a).mod(o))))
  var s = Math.ceil(a.sub(e).div(o).toNumber()),
    l = Math.ceil(new be(t).sub(a).div(o).toNumber()),
    u = s + l + 1
  return u > n
    ? Pk(e, t, n, r, i + 1)
    : (u < n && ((l = t > 0 ? l + (n - u) : l), (s = t > 0 ? s : s + (n - u))),
      {
        step: o,
        tickMin: a.sub(new be(s).mul(o)),
        tickMax: a.add(new be(l).mul(o))
      })
}
function fee(e) {
  var t = wl(e, 2),
    n = t[0],
    r = t[1],
    i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6,
    o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
    a = Math.max(i, 2),
    s = Sk([n, r]),
    l = wl(s, 2),
    u = l[0],
    f = l[1]
  if (u === -1 / 0 || f === 1 / 0) {
    var c =
      f === 1 / 0
        ? [u].concat(
            Jv(
              Qv(0, i - 1).map(function () {
                return 1 / 0
              })
            )
          )
        : [].concat(
            Jv(
              Qv(0, i - 1).map(function () {
                return -1 / 0
              })
            ),
            [f]
          )
    return n > r ? Zv(c) : c
  }
  if (u === f) return cee(u, i, o)
  var d = Pk(u, f, a, o),
    p = d.step,
    h = d.tickMin,
    m = d.tickMax,
    b = fp.rangeStep(h, m.add(new be(0.1).mul(p)), p)
  return n > r ? Zv(b) : b
}
function dee(e, t) {
  var n = wl(e, 2),
    r = n[0],
    i = n[1],
    o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
    a = Sk([r, i]),
    s = wl(a, 2),
    l = s[0],
    u = s[1]
  if (l === -1 / 0 || u === 1 / 0) return [r, i]
  if (l === u) return [l]
  var f = Math.max(t, 2),
    c = Ok(new be(u).sub(l).div(f - 1), o, 0),
    d = [].concat(
      Jv(fp.rangeStep(new be(l), new be(u).sub(new be(0.99).mul(c)), c)),
      [u]
    )
  return r > i ? Zv(d) : d
}
var pee = xk(fee),
  hee = xk(dee),
  mee = [
    "offset",
    "layout",
    "width",
    "dataKey",
    "data",
    "dataPointFormatter",
    "xAxis",
    "yAxis"
  ]
function Vf() {
  return (
    (Vf = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Vf.apply(this, arguments)
  )
}
function vee(e, t) {
  return xee(e) || bee(e, t) || yee(e, t) || gee()
}
function gee() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function yee(e, t) {
  if (e) {
    if (typeof e == "string") return gO(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return gO(e, t)
  }
}
function gO(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function bee(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function xee(e) {
  if (Array.isArray(e)) return e
}
function wee(e, t) {
  if (e == null) return {}
  var n = See(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function See(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function dp(e) {
  var t = e.offset,
    n = e.layout,
    r = e.width,
    i = e.dataKey,
    o = e.data,
    a = e.dataPointFormatter,
    s = e.xAxis,
    l = e.yAxis,
    u = wee(e, mee),
    f = he(u),
    c = o.map(function (d) {
      var p = a(d, i),
        h = p.x,
        m = p.y,
        b = p.value,
        g = p.errorVal
      if (!g) return null
      var v = [],
        y,
        w
      if (Array.isArray(g)) {
        var x = vee(g, 2)
        ;(y = x[0]), (w = x[1])
      } else y = w = g
      if (n === "vertical") {
        var S = s.scale,
          O = m + t,
          $ = O + r,
          A = O - r,
          C = S(b - y),
          T = S(b + w)
        v.push({ x1: T, y1: $, x2: T, y2: A }),
          v.push({ x1: C, y1: O, x2: T, y2: O }),
          v.push({ x1: C, y1: $, x2: C, y2: A })
      } else if (n === "horizontal") {
        var _ = l.scale,
          R = h + t,
          M = R - r,
          D = R + r,
          N = _(b - y),
          L = _(b + w)
        v.push({ x1: M, y1: L, x2: D, y2: L }),
          v.push({ x1: R, y1: N, x2: R, y2: L }),
          v.push({ x1: M, y1: N, x2: D, y2: N })
      }
      return E.createElement(
        ct,
        Vf(
          {
            className: "recharts-errorBar",
            key: "bar-".concat(
              v.map(function (k) {
                return ""
                  .concat(k.x1, "-")
                  .concat(k.x2, "-")
                  .concat(k.y1, "-")
                  .concat(k.y2)
              })
            )
          },
          f
        ),
        v.map(function (k) {
          return E.createElement(
            "line",
            Vf({}, k, {
              key: "line-"
                .concat(k.x1, "-")
                .concat(k.x2, "-")
                .concat(k.y1, "-")
                .concat(k.y2)
            })
          )
        })
      )
    })
  return E.createElement(ct, { className: "recharts-errorBars" }, c)
}
dp.defaultProps = {
  stroke: "black",
  strokeWidth: 1.5,
  width: 5,
  offset: 0,
  layout: "horizontal"
}
dp.displayName = "ErrorBar"
function Sl(e) {
  "@babel/helpers - typeof"
  return (
    (Sl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Sl(e)
  )
}
function yO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Fh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? yO(Object(n), !0).forEach(function (r) {
          Oee(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : yO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Oee(e, t, n) {
  return (
    (t = Pee(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Pee(e) {
  var t = $ee(e, "string")
  return Sl(t) === "symbol" ? t : String(t)
}
function $ee(e, t) {
  if (Sl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Sl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var $k = function (t) {
  var n = t.children,
    r = t.formattedGraphicalItems,
    i = t.legendWidth,
    o = t.legendContent,
    a = ur(n, ll)
  if (!a) return null
  var s
  return (
    a.props && a.props.payload
      ? (s = a.props && a.props.payload)
      : o === "children"
        ? (s = (r || []).reduce(function (l, u) {
            var f = u.item,
              c = u.props,
              d = c.sectors || c.data || []
            return l.concat(
              d.map(function (p) {
                return {
                  type: a.props.iconType || f.props.legendType,
                  value: p.name,
                  color: p.fill,
                  payload: p
                }
              })
            )
          }, []))
        : (s = (r || []).map(function (l) {
            var u = l.item,
              f = u.props,
              c = f.dataKey,
              d = f.name,
              p = f.legendType,
              h = f.hide
            return {
              inactive: h,
              dataKey: c,
              type: a.props.iconType || p || "square",
              color: H0(u),
              value: d || c,
              payload: u.props
            }
          })),
    Fh(Fh(Fh({}, a.props), ll.getWithHeight(a, i)), {}, { payload: s, item: a })
  )
}
function Ol(e) {
  "@babel/helpers - typeof"
  return (
    (Ol =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Ol(e)
  )
}
function bO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function fn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? bO(Object(n), !0).forEach(function (r) {
          Ko(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : bO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Ko(e, t, n) {
  return (
    (t = Aee(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Aee(e) {
  var t = Tee(e, "string")
  return Ol(t) === "symbol" ? t : String(t)
}
function Tee(e, t) {
  if (Ol(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Ol(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function xO(e) {
  return kee(e) || _ee(e) || Cee(e) || Eee()
}
function Eee() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Cee(e, t) {
  if (e) {
    if (typeof e == "string") return tg(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return tg(e, t)
  }
}
function _ee(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function kee(e) {
  if (Array.isArray(e)) return tg(e)
}
function tg(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function Yn(e, t, n) {
  return xe(e) || xe(t) ? n : it(t) ? mn(e, t, n) : ce(t) ? t(e) : n
}
function Rs(e, t, n, r) {
  var i = RJ(e, function (s) {
    return Yn(s, t)
  })
  if (n === "number") {
    var o = i.filter(function (s) {
      return G(s) || parseFloat(s)
    })
    return o.length ? [up(o), lp(o)] : [1 / 0, -1 / 0]
  }
  var a = r
    ? i.filter(function (s) {
        return !xe(s)
      })
    : i
  return a.map(function (s) {
    return it(s) || s instanceof Date ? s : ""
  })
}
var Mee = function (t) {
    var n,
      r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
      i = arguments.length > 2 ? arguments[2] : void 0,
      o = arguments.length > 3 ? arguments[3] : void 0,
      a = -1,
      s = (n = r == null ? void 0 : r.length) !== null && n !== void 0 ? n : 0
    if (s <= 1) return 0
    if (
      o &&
      o.axisType === "angleAxis" &&
      Math.abs(Math.abs(o.range[1] - o.range[0]) - 360) <= 1e-6
    )
      for (var l = o.range, u = 0; u < s; u++) {
        var f = u > 0 ? i[u - 1].coordinate : i[s - 1].coordinate,
          c = i[u].coordinate,
          d = u >= s - 1 ? i[0].coordinate : i[u + 1].coordinate,
          p = void 0
        if (_n(c - f) !== _n(d - c)) {
          var h = []
          if (_n(d - c) === _n(l[1] - l[0])) {
            p = d
            var m = c + l[1] - l[0]
            ;(h[0] = Math.min(m, (m + f) / 2)),
              (h[1] = Math.max(m, (m + f) / 2))
          } else {
            p = f
            var b = d + l[1] - l[0]
            ;(h[0] = Math.min(c, (b + c) / 2)),
              (h[1] = Math.max(c, (b + c) / 2))
          }
          var g = [Math.min(c, (p + c) / 2), Math.max(c, (p + c) / 2)]
          if ((t > g[0] && t <= g[1]) || (t >= h[0] && t <= h[1])) {
            a = i[u].index
            break
          }
        } else {
          var v = Math.min(f, d),
            y = Math.max(f, d)
          if (t > (v + c) / 2 && t <= (y + c) / 2) {
            a = i[u].index
            break
          }
        }
      }
    else
      for (var w = 0; w < s; w++)
        if (
          (w === 0 && t <= (r[w].coordinate + r[w + 1].coordinate) / 2) ||
          (w > 0 &&
            w < s - 1 &&
            t > (r[w].coordinate + r[w - 1].coordinate) / 2 &&
            t <= (r[w].coordinate + r[w + 1].coordinate) / 2) ||
          (w === s - 1 && t > (r[w].coordinate + r[w - 1].coordinate) / 2)
        ) {
          a = r[w].index
          break
        }
    return a
  },
  H0 = function (t) {
    var n = t,
      r = n.type.displayName,
      i = t.props,
      o = i.stroke,
      a = i.fill,
      s
    switch (r) {
      case "Line":
        s = o
        break
      case "Area":
      case "Radar":
        s = o && o !== "none" ? o : a
        break
      default:
        s = a
        break
    }
    return s
  },
  jee = function (t) {
    var n = t.barSize,
      r = t.stackGroups,
      i = r === void 0 ? {} : r
    if (!i) return {}
    for (var o = {}, a = Object.keys(i), s = 0, l = a.length; s < l; s++)
      for (
        var u = i[a[s]].stackGroups, f = Object.keys(u), c = 0, d = f.length;
        c < d;
        c++
      ) {
        var p = u[f[c]],
          h = p.items,
          m = p.cateAxisId,
          b = h.filter(function (y) {
            return ai(y.type).indexOf("Bar") >= 0
          })
        if (b && b.length) {
          var g = b[0].props.barSize,
            v = b[0].props[m]
          o[v] || (o[v] = []),
            o[v].push({
              item: b[0],
              stackList: b.slice(1),
              barSize: xe(g) ? n : g
            })
        }
      }
    return o
  },
  Dee = function (t) {
    var n = t.barGap,
      r = t.barCategoryGap,
      i = t.bandSize,
      o = t.sizeList,
      a = o === void 0 ? [] : o,
      s = t.maxBarSize,
      l = a.length
    if (l < 1) return null
    var u = aa(n, i, 0, !0),
      f,
      c = []
    if (a[0].barSize === +a[0].barSize) {
      var d = !1,
        p = i / l,
        h = a.reduce(function (w, x) {
          return w + x.barSize || 0
        }, 0)
      ;(h += (l - 1) * u),
        h >= i && ((h -= (l - 1) * u), (u = 0)),
        h >= i && p > 0 && ((d = !0), (p *= 0.9), (h = l * p))
      var m = ((i - h) / 2) >> 0,
        b = { offset: m - u, size: 0 }
      f = a.reduce(function (w, x) {
        var S = {
            item: x.item,
            position: { offset: b.offset + b.size + u, size: d ? p : x.barSize }
          },
          O = [].concat(xO(w), [S])
        return (
          (b = O[O.length - 1].position),
          x.stackList &&
            x.stackList.length &&
            x.stackList.forEach(function ($) {
              O.push({ item: $, position: b })
            }),
          O
        )
      }, c)
    } else {
      var g = aa(r, i, 0, !0)
      i - 2 * g - (l - 1) * u <= 0 && (u = 0)
      var v = (i - 2 * g - (l - 1) * u) / l
      v > 1 && (v >>= 0)
      var y = s === +s ? Math.min(v, s) : v
      f = a.reduce(function (w, x, S) {
        var O = [].concat(xO(w), [
          {
            item: x.item,
            position: { offset: g + (v + u) * S + (v - y) / 2, size: y }
          }
        ])
        return (
          x.stackList &&
            x.stackList.length &&
            x.stackList.forEach(function ($) {
              O.push({ item: $, position: O[O.length - 1].position })
            }),
          O
        )
      }, c)
    }
    return f
  },
  Iee = function (t, n, r, i) {
    var o = r.children,
      a = r.width,
      s = r.margin,
      l = a - (s.left || 0) - (s.right || 0),
      u = $k({ children: o, legendWidth: l })
    if (u) {
      var f = i || {},
        c = f.width,
        d = f.height,
        p = u.align,
        h = u.verticalAlign,
        m = u.layout
      if (
        (m === "vertical" || (m === "horizontal" && h === "middle")) &&
        p !== "center" &&
        G(t[p])
      )
        return fn(fn({}, t), {}, Ko({}, p, t[p] + (c || 0)))
      if (
        (m === "horizontal" || (m === "vertical" && p === "center")) &&
        h !== "middle" &&
        G(t[h])
      )
        return fn(fn({}, t), {}, Ko({}, h, t[h] + (d || 0)))
    }
    return t
  },
  Nee = function (t, n, r) {
    return xe(n)
      ? !0
      : t === "horizontal"
        ? n === "yAxis"
        : t === "vertical" || r === "x"
          ? n === "xAxis"
          : r === "y"
            ? n === "yAxis"
            : !0
  },
  Ak = function (t, n, r, i, o) {
    var a = n.props.children,
      s = jn(a, dp).filter(function (u) {
        return Nee(i, o, u.props.direction)
      })
    if (s && s.length) {
      var l = s.map(function (u) {
        return u.props.dataKey
      })
      return t.reduce(
        function (u, f) {
          var c = Yn(f, r, 0),
            d = Array.isArray(c) ? [up(c), lp(c)] : [c, c],
            p = l.reduce(
              function (h, m) {
                var b = Yn(f, m, 0),
                  g = d[0] - Math.abs(Array.isArray(b) ? b[0] : b),
                  v = d[1] + Math.abs(Array.isArray(b) ? b[1] : b)
                return [Math.min(g, h[0]), Math.max(v, h[1])]
              },
              [1 / 0, -1 / 0]
            )
          return [Math.min(p[0], u[0]), Math.max(p[1], u[1])]
        },
        [1 / 0, -1 / 0]
      )
    }
    return null
  },
  Ree = function (t, n, r, i, o) {
    var a = n
      .map(function (s) {
        return Ak(t, s, r, o, i)
      })
      .filter(function (s) {
        return !xe(s)
      })
    return a && a.length
      ? a.reduce(
          function (s, l) {
            return [Math.min(s[0], l[0]), Math.max(s[1], l[1])]
          },
          [1 / 0, -1 / 0]
        )
      : null
  },
  Tk = function (t, n, r, i, o) {
    var a = n.map(function (l) {
      var u = l.props.dataKey
      return (r === "number" && u && Ak(t, l, u, i)) || Rs(t, u, r, o)
    })
    if (r === "number")
      return a.reduce(
        function (l, u) {
          return [Math.min(l[0], u[0]), Math.max(l[1], u[1])]
        },
        [1 / 0, -1 / 0]
      )
    var s = {}
    return a.reduce(function (l, u) {
      for (var f = 0, c = u.length; f < c; f++)
        s[u[f]] || ((s[u[f]] = !0), l.push(u[f]))
      return l
    }, [])
  },
  Ek = function (t, n) {
    return (
      (t === "horizontal" && n === "xAxis") ||
      (t === "vertical" && n === "yAxis") ||
      (t === "centric" && n === "angleAxis") ||
      (t === "radial" && n === "radiusAxis")
    )
  },
  wO = function (t, n, r, i) {
    if (i)
      return t.map(function (l) {
        return l.coordinate
      })
    var o,
      a,
      s = t.map(function (l) {
        return (
          l.coordinate === n && (o = !0),
          l.coordinate === r && (a = !0),
          l.coordinate
        )
      })
    return o || s.push(n), a || s.push(r), s
  },
  Vr = function (t, n, r) {
    if (!t) return null
    var i = t.scale,
      o = t.duplicateDomain,
      a = t.type,
      s = t.range,
      l = t.realScaleType === "scaleBand" ? i.bandwidth() / 2 : 2,
      u = (n || r) && a === "category" && i.bandwidth ? i.bandwidth() / l : 0
    if (
      ((u =
        t.axisType === "angleAxis" && (s == null ? void 0 : s.length) >= 2
          ? _n(s[0] - s[1]) * 2 * u
          : u),
      n && (t.ticks || t.niceTicks))
    ) {
      var f = (t.ticks || t.niceTicks).map(function (c) {
        var d = o ? o.indexOf(c) : c
        return { coordinate: i(d) + u, value: c, offset: u }
      })
      return f.filter(function (c) {
        return !ou(c.coordinate)
      })
    }
    return t.isCategorical && t.categoricalDomain
      ? t.categoricalDomain.map(function (c, d) {
          return { coordinate: i(c) + u, value: c, index: d, offset: u }
        })
      : i.ticks && !r
        ? i.ticks(t.tickCount).map(function (c) {
            return { coordinate: i(c) + u, value: c, offset: u }
          })
        : i.domain().map(function (c, d) {
            return {
              coordinate: i(c) + u,
              value: o ? o[c] : c,
              index: d,
              offset: u
            }
          })
  },
  Vh = new WeakMap(),
  nc = function (t, n) {
    if (typeof n != "function") return t
    Vh.has(t) || Vh.set(t, new WeakMap())
    var r = Vh.get(t)
    if (r.has(n)) return r.get(n)
    var i = function () {
      t.apply(void 0, arguments), n.apply(void 0, arguments)
    }
    return r.set(n, i), i
  },
  Lee = function (t, n, r) {
    var i = t.scale,
      o = t.type,
      a = t.layout,
      s = t.axisType
    if (i === "auto")
      return a === "radial" && s === "radiusAxis"
        ? { scale: ml(), realScaleType: "band" }
        : a === "radial" && s === "angleAxis"
          ? { scale: Nf(), realScaleType: "linear" }
          : o === "category" &&
              n &&
              (n.indexOf("LineChart") >= 0 ||
                n.indexOf("AreaChart") >= 0 ||
                (n.indexOf("ComposedChart") >= 0 && !r))
            ? { scale: Ns(), realScaleType: "point" }
            : o === "category"
              ? { scale: ml(), realScaleType: "band" }
              : { scale: Nf(), realScaleType: "linear" }
    if (iu(i)) {
      var l = "scale".concat(Xd(i))
      return { scale: (pO[l] || Ns)(), realScaleType: pO[l] ? l : "point" }
    }
    return ce(i) ? { scale: i } : { scale: Ns(), realScaleType: "point" }
  },
  SO = 1e-4,
  Bee = function (t) {
    var n = t.domain()
    if (!(!n || n.length <= 2)) {
      var r = n.length,
        i = t.range(),
        o = Math.min(i[0], i[1]) - SO,
        a = Math.max(i[0], i[1]) + SO,
        s = t(n[0]),
        l = t(n[r - 1])
      ;(s < o || s > a || l < o || l > a) && t.domain([n[0], n[r - 1]])
    }
  },
  Fee = function (t, n) {
    if (!t) return null
    for (var r = 0, i = t.length; r < i; r++)
      if (t[r].item === n) return t[r].position
    return null
  },
  Vee = function (t, n) {
    if (!n || n.length !== 2 || !G(n[0]) || !G(n[1])) return t
    var r = Math.min(n[0], n[1]),
      i = Math.max(n[0], n[1]),
      o = [t[0], t[1]]
    return (
      (!G(t[0]) || t[0] < r) && (o[0] = r),
      (!G(t[1]) || t[1] > i) && (o[1] = i),
      o[0] > i && (o[0] = i),
      o[1] < r && (o[1] = r),
      o
    )
  },
  zee = function (t) {
    var n = t.length
    if (!(n <= 0))
      for (var r = 0, i = t[0].length; r < i; ++r)
        for (var o = 0, a = 0, s = 0; s < n; ++s) {
          var l = ou(t[s][r][1]) ? t[s][r][0] : t[s][r][1]
          l >= 0
            ? ((t[s][r][0] = o), (t[s][r][1] = o + l), (o = t[s][r][1]))
            : ((t[s][r][0] = a), (t[s][r][1] = a + l), (a = t[s][r][1]))
        }
  },
  Uee = function (t) {
    var n = t.length
    if (!(n <= 0))
      for (var r = 0, i = t[0].length; r < i; ++r)
        for (var o = 0, a = 0; a < n; ++a) {
          var s = ou(t[a][r][1]) ? t[a][r][0] : t[a][r][1]
          s >= 0
            ? ((t[a][r][0] = o), (t[a][r][1] = o + s), (o = t[a][r][1]))
            : ((t[a][r][0] = 0), (t[a][r][1] = 0))
        }
  },
  Wee = {
    sign: zee,
    expand: XV,
    none: sa,
    silhouette: YV,
    wiggle: QV,
    positive: Uee
  },
  Hee = function (t, n, r) {
    var i = n.map(function (s) {
        return s.props.dataKey
      }),
      o = Wee[r],
      a = qV()
        .keys(i)
        .value(function (s, l) {
          return +Yn(s, l, 0)
        })
        .order(xv)
        .offset(o)
    return a(t)
  },
  Gee = function (t, n, r, i, o, a) {
    if (!t) return null
    var s = a ? n.reverse() : n,
      l = {},
      u = s.reduce(function (c, d) {
        var p = d.props,
          h = p.stackId,
          m = p.hide
        if (m) return c
        var b = d.props[r],
          g = c[b] || { hasStack: !1, stackGroups: {} }
        if (it(h)) {
          var v = g.stackGroups[h] || {
            numericAxisId: r,
            cateAxisId: i,
            items: []
          }
          v.items.push(d), (g.hasStack = !0), (g.stackGroups[h] = v)
        } else
          g.stackGroups[Kd("_stackId_")] = {
            numericAxisId: r,
            cateAxisId: i,
            items: [d]
          }
        return fn(fn({}, c), {}, Ko({}, b, g))
      }, l),
      f = {}
    return Object.keys(u).reduce(function (c, d) {
      var p = u[d]
      if (p.hasStack) {
        var h = {}
        p.stackGroups = Object.keys(p.stackGroups).reduce(function (m, b) {
          var g = p.stackGroups[b]
          return fn(
            fn({}, m),
            {},
            Ko({}, b, {
              numericAxisId: r,
              cateAxisId: i,
              items: g.items,
              stackedData: Hee(t, g.items, o)
            })
          )
        }, h)
      }
      return fn(fn({}, c), {}, Ko({}, d, p))
    }, f)
  },
  Kee = function (t, n) {
    var r = n.realScaleType,
      i = n.type,
      o = n.tickCount,
      a = n.originalDomain,
      s = n.allowDecimals,
      l = r || n.scale
    if (l !== "auto" && l !== "linear") return null
    if (o && i === "number" && a && (a[0] === "auto" || a[1] === "auto")) {
      var u = t.domain()
      if (!u.length) return null
      var f = pee(u, o, s)
      return t.domain([up(f), lp(f)]), { niceTicks: f }
    }
    if (o && i === "number") {
      var c = t.domain(),
        d = hee(c, o, s)
      return { niceTicks: d }
    }
    return null
  },
  OO = function (t) {
    var n = t.axis,
      r = t.ticks,
      i = t.offset,
      o = t.bandSize,
      a = t.entry,
      s = t.index
    if (n.type === "category") return r[s] ? r[s].coordinate + i : null
    var l = Yn(a, n.dataKey, n.domain[s])
    return xe(l) ? null : n.scale(l) - o / 2 + i
  },
  qee = function (t) {
    var n = t.numericAxis,
      r = n.scale.domain()
    if (n.type === "number") {
      var i = Math.min(r[0], r[1]),
        o = Math.max(r[0], r[1])
      return i <= 0 && o >= 0 ? 0 : o < 0 ? o : i
    }
    return r[0]
  },
  Xee = function (t, n) {
    var r = t.props.stackId
    if (it(r)) {
      var i = n[r]
      if (i) {
        var o = i.items.indexOf(t)
        return o >= 0 ? i.stackedData[o] : null
      }
    }
    return null
  },
  Yee = function (t) {
    return t.reduce(
      function (n, r) {
        return [up(r.concat([n[0]]).filter(G)), lp(r.concat([n[1]]).filter(G))]
      },
      [1 / 0, -1 / 0]
    )
  },
  Ck = function (t, n, r) {
    return Object.keys(t)
      .reduce(
        function (i, o) {
          var a = t[o],
            s = a.stackedData,
            l = s.reduce(
              function (u, f) {
                var c = Yee(f.slice(n, r + 1))
                return [Math.min(u[0], c[0]), Math.max(u[1], c[1])]
              },
              [1 / 0, -1 / 0]
            )
          return [Math.min(l[0], i[0]), Math.max(l[1], i[1])]
        },
        [1 / 0, -1 / 0]
      )
      .map(function (i) {
        return i === 1 / 0 || i === -1 / 0 ? 0 : i
      })
  },
  PO = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/,
  $O = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/,
  ng = function (t, n, r) {
    if (ce(t)) return t(n, r)
    if (!Array.isArray(t)) return n
    var i = []
    if (G(t[0])) i[0] = r ? t[0] : Math.min(t[0], n[0])
    else if (PO.test(t[0])) {
      var o = +PO.exec(t[0])[1]
      i[0] = n[0] - o
    } else ce(t[0]) ? (i[0] = t[0](n[0])) : (i[0] = n[0])
    if (G(t[1])) i[1] = r ? t[1] : Math.max(t[1], n[1])
    else if ($O.test(t[1])) {
      var a = +$O.exec(t[1])[1]
      i[1] = n[1] + a
    } else ce(t[1]) ? (i[1] = t[1](n[1])) : (i[1] = n[1])
    return i
  },
  zf = function (t, n, r) {
    if (t && t.scale && t.scale.bandwidth) {
      var i = t.scale.bandwidth()
      if (!r || i > 0) return i
    }
    if (t && n && n.length >= 2) {
      for (
        var o = g0(n, function (c) {
            return c.coordinate
          }),
          a = 1 / 0,
          s = 1,
          l = o.length;
        s < l;
        s++
      ) {
        var u = o[s],
          f = o[s - 1]
        a = Math.min((u.coordinate || 0) - (f.coordinate || 0), a)
      }
      return a === 1 / 0 ? 0 : a
    }
    return r ? void 0 : 0
  },
  AO = function (t, n, r) {
    return !t || !t.length || z0(t, mn(r, "type.defaultProps.domain")) ? n : t
  },
  _k = function (t, n) {
    var r = t.props,
      i = r.dataKey,
      o = r.name,
      a = r.unit,
      s = r.formatter,
      l = r.tooltipType,
      u = r.chartType
    return fn(
      fn({}, he(t)),
      {},
      {
        dataKey: i,
        unit: a,
        formatter: s,
        name: o || i,
        color: H0(t),
        value: Yn(n, i),
        type: l,
        payload: n,
        chartType: u
      }
    )
  }
function Pl(e) {
  "@babel/helpers - typeof"
  return (
    (Pl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Pl(e)
  )
}
function TO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function EO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? TO(Object(n), !0).forEach(function (r) {
          Qee(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : TO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Qee(e, t, n) {
  return (
    (t = Zee(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Zee(e) {
  var t = Jee(e, "string")
  return Pl(t) === "symbol" ? t : String(t)
}
function Jee(e, t) {
  if (Pl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Pl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var Uf = Math.PI / 180,
  ete = function (t) {
    return (t * 180) / Math.PI
  },
  yt = function (t, n, r, i) {
    return { x: t + Math.cos(-Uf * i) * r, y: n + Math.sin(-Uf * i) * r }
  },
  tte = function (t, n) {
    var r = t.x,
      i = t.y,
      o = n.x,
      a = n.y
    return Math.sqrt(Math.pow(r - o, 2) + Math.pow(i - a, 2))
  },
  nte = function (t, n) {
    var r = t.x,
      i = t.y,
      o = n.cx,
      a = n.cy,
      s = tte({ x: r, y: i }, { x: o, y: a })
    if (s <= 0) return { radius: s }
    var l = (r - o) / s,
      u = Math.acos(l)
    return (
      i > a && (u = 2 * Math.PI - u),
      { radius: s, angle: ete(u), angleInRadian: u }
    )
  },
  rte = function (t) {
    var n = t.startAngle,
      r = t.endAngle,
      i = Math.floor(n / 360),
      o = Math.floor(r / 360),
      a = Math.min(i, o)
    return { startAngle: n - a * 360, endAngle: r - a * 360 }
  },
  ite = function (t, n) {
    var r = n.startAngle,
      i = n.endAngle,
      o = Math.floor(r / 360),
      a = Math.floor(i / 360),
      s = Math.min(o, a)
    return t + s * 360
  },
  CO = function (t, n) {
    var r = t.x,
      i = t.y,
      o = nte({ x: r, y: i }, n),
      a = o.radius,
      s = o.angle,
      l = n.innerRadius,
      u = n.outerRadius
    if (a < l || a > u) return !1
    if (a === 0) return !0
    var f = rte(n),
      c = f.startAngle,
      d = f.endAngle,
      p = s,
      h
    if (c <= d) {
      for (; p > d; ) p -= 360
      for (; p < c; ) p += 360
      h = p >= c && p <= d
    } else {
      for (; p > c; ) p -= 360
      for (; p < d; ) p += 360
      h = p >= d && p <= c
    }
    return h ? EO(EO({}, n), {}, { radius: a, angle: ite(p, n) }) : null
  }
function $l(e) {
  "@babel/helpers - typeof"
  return (
    ($l =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    $l(e)
  )
}
var ote = ["offset"]
function ate(e) {
  return cte(e) || ute(e) || lte(e) || ste()
}
function ste() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function lte(e, t) {
  if (e) {
    if (typeof e == "string") return rg(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return rg(e, t)
  }
}
function ute(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function cte(e) {
  if (Array.isArray(e)) return rg(e)
}
function rg(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function fte(e, t) {
  if (e == null) return {}
  var n = dte(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function dte(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function _O(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function tt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? _O(Object(n), !0).forEach(function (r) {
          pte(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : _O(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function pte(e, t, n) {
  return (
    (t = hte(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function hte(e) {
  var t = mte(e, "string")
  return $l(t) === "symbol" ? t : String(t)
}
function mte(e, t) {
  if ($l(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if ($l(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function Al() {
  return (
    (Al = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Al.apply(this, arguments)
  )
}
var vte = function (t) {
    var n = t.value,
      r = t.formatter,
      i = xe(t.children) ? n : t.children
    return ce(r) ? r(i) : i
  },
  gte = function (t, n) {
    var r = _n(n - t),
      i = Math.min(Math.abs(n - t), 360)
    return r * i
  },
  yte = function (t, n, r) {
    var i = t.position,
      o = t.viewBox,
      a = t.offset,
      s = t.className,
      l = o,
      u = l.cx,
      f = l.cy,
      c = l.innerRadius,
      d = l.outerRadius,
      p = l.startAngle,
      h = l.endAngle,
      m = l.clockWise,
      b = (c + d) / 2,
      g = gte(p, h),
      v = g >= 0 ? 1 : -1,
      y,
      w
    i === "insideStart"
      ? ((y = p + v * a), (w = m))
      : i === "insideEnd"
        ? ((y = h - v * a), (w = !m))
        : i === "end" && ((y = h + v * a), (w = m)),
      (w = g <= 0 ? w : !w)
    var x = yt(u, f, b, y),
      S = yt(u, f, b, y + (w ? 1 : -1) * 359),
      O = "M"
        .concat(x.x, ",")
        .concat(
          x.y,
          `
    A`
        )
        .concat(b, ",")
        .concat(b, ",0,1,")
        .concat(
          w ? 0 : 1,
          `,
    `
        )
        .concat(S.x, ",")
        .concat(S.y),
      $ = xe(t.id) ? Kd("recharts-radial-line-") : t.id
    return E.createElement(
      "text",
      Al({}, r, {
        dominantBaseline: "central",
        className: Oe("recharts-radial-bar-label", s)
      }),
      E.createElement("defs", null, E.createElement("path", { id: $, d: O })),
      E.createElement("textPath", { xlinkHref: "#".concat($) }, n)
    )
  },
  bte = function (t) {
    var n = t.viewBox,
      r = t.offset,
      i = t.position,
      o = n,
      a = o.cx,
      s = o.cy,
      l = o.innerRadius,
      u = o.outerRadius,
      f = o.startAngle,
      c = o.endAngle,
      d = (f + c) / 2
    if (i === "outside") {
      var p = yt(a, s, u + r, d),
        h = p.x,
        m = p.y
      return {
        x: h,
        y: m,
        textAnchor: h >= a ? "start" : "end",
        verticalAnchor: "middle"
      }
    }
    if (i === "center")
      return { x: a, y: s, textAnchor: "middle", verticalAnchor: "middle" }
    if (i === "centerTop")
      return { x: a, y: s, textAnchor: "middle", verticalAnchor: "start" }
    if (i === "centerBottom")
      return { x: a, y: s, textAnchor: "middle", verticalAnchor: "end" }
    var b = (l + u) / 2,
      g = yt(a, s, b, d),
      v = g.x,
      y = g.y
    return { x: v, y, textAnchor: "middle", verticalAnchor: "middle" }
  },
  xte = function (t) {
    var n = t.viewBox,
      r = t.parentViewBox,
      i = t.offset,
      o = t.position,
      a = n,
      s = a.x,
      l = a.y,
      u = a.width,
      f = a.height,
      c = f >= 0 ? 1 : -1,
      d = c * i,
      p = c > 0 ? "end" : "start",
      h = c > 0 ? "start" : "end",
      m = u >= 0 ? 1 : -1,
      b = m * i,
      g = m > 0 ? "end" : "start",
      v = m > 0 ? "start" : "end"
    if (o === "top") {
      var y = {
        x: s + u / 2,
        y: l - c * i,
        textAnchor: "middle",
        verticalAnchor: p
      }
      return tt(tt({}, y), r ? { height: Math.max(l - r.y, 0), width: u } : {})
    }
    if (o === "bottom") {
      var w = {
        x: s + u / 2,
        y: l + f + d,
        textAnchor: "middle",
        verticalAnchor: h
      }
      return tt(
        tt({}, w),
        r ? { height: Math.max(r.y + r.height - (l + f), 0), width: u } : {}
      )
    }
    if (o === "left") {
      var x = {
        x: s - b,
        y: l + f / 2,
        textAnchor: g,
        verticalAnchor: "middle"
      }
      return tt(
        tt({}, x),
        r ? { width: Math.max(x.x - r.x, 0), height: f } : {}
      )
    }
    if (o === "right") {
      var S = {
        x: s + u + b,
        y: l + f / 2,
        textAnchor: v,
        verticalAnchor: "middle"
      }
      return tt(
        tt({}, S),
        r ? { width: Math.max(r.x + r.width - S.x, 0), height: f } : {}
      )
    }
    var O = r ? { width: u, height: f } : {}
    return o === "insideLeft"
      ? tt(
          { x: s + b, y: l + f / 2, textAnchor: v, verticalAnchor: "middle" },
          O
        )
      : o === "insideRight"
        ? tt(
            {
              x: s + u - b,
              y: l + f / 2,
              textAnchor: g,
              verticalAnchor: "middle"
            },
            O
          )
        : o === "insideTop"
          ? tt(
              {
                x: s + u / 2,
                y: l + d,
                textAnchor: "middle",
                verticalAnchor: h
              },
              O
            )
          : o === "insideBottom"
            ? tt(
                {
                  x: s + u / 2,
                  y: l + f - d,
                  textAnchor: "middle",
                  verticalAnchor: p
                },
                O
              )
            : o === "insideTopLeft"
              ? tt({ x: s + b, y: l + d, textAnchor: v, verticalAnchor: h }, O)
              : o === "insideTopRight"
                ? tt(
                    {
                      x: s + u - b,
                      y: l + d,
                      textAnchor: g,
                      verticalAnchor: h
                    },
                    O
                  )
                : o === "insideBottomLeft"
                  ? tt(
                      {
                        x: s + b,
                        y: l + f - d,
                        textAnchor: v,
                        verticalAnchor: p
                      },
                      O
                    )
                  : o === "insideBottomRight"
                    ? tt(
                        {
                          x: s + u - b,
                          y: l + f - d,
                          textAnchor: g,
                          verticalAnchor: p
                        },
                        O
                      )
                    : _a(o) && (G(o.x) || uv(o.x)) && (G(o.y) || uv(o.y))
                      ? tt(
                          {
                            x: s + aa(o.x, u),
                            y: l + aa(o.y, f),
                            textAnchor: "end",
                            verticalAnchor: "end"
                          },
                          O
                        )
                      : tt(
                          {
                            x: s + u / 2,
                            y: l + f / 2,
                            textAnchor: "middle",
                            verticalAnchor: "middle"
                          },
                          O
                        )
  },
  wte = function (t) {
    return "cx" in t && G(t.cx)
  }
function At(e) {
  var t = e.offset,
    n = t === void 0 ? 5 : t,
    r = fte(e, ote),
    i = tt({ offset: n }, r),
    o = i.viewBox,
    a = i.position,
    s = i.value,
    l = i.children,
    u = i.content,
    f = i.className,
    c = f === void 0 ? "" : f,
    d = i.textBreakAll
  if (!o || (xe(s) && xe(l) && !P.isValidElement(u) && !ce(u))) return null
  if (P.isValidElement(u)) return P.cloneElement(u, i)
  var p
  if (ce(u)) {
    if (((p = P.createElement(u, i)), P.isValidElement(p))) return p
  } else p = vte(i)
  var h = wte(o),
    m = he(i, !0)
  if (h && (a === "insideStart" || a === "insideEnd" || a === "end"))
    return yte(i, p, m)
  var b = h ? bte(i) : xte(i)
  return E.createElement(
    Cf,
    Al({ className: Oe("recharts-label", c) }, m, b, { breakAll: d }),
    p
  )
}
At.displayName = "Label"
var kk = function (t) {
    var n = t.cx,
      r = t.cy,
      i = t.angle,
      o = t.startAngle,
      a = t.endAngle,
      s = t.r,
      l = t.radius,
      u = t.innerRadius,
      f = t.outerRadius,
      c = t.x,
      d = t.y,
      p = t.top,
      h = t.left,
      m = t.width,
      b = t.height,
      g = t.clockWise,
      v = t.labelViewBox
    if (v) return v
    if (G(m) && G(b)) {
      if (G(c) && G(d)) return { x: c, y: d, width: m, height: b }
      if (G(p) && G(h)) return { x: p, y: h, width: m, height: b }
    }
    return G(c) && G(d)
      ? { x: c, y: d, width: 0, height: 0 }
      : G(n) && G(r)
        ? {
            cx: n,
            cy: r,
            startAngle: o || i || 0,
            endAngle: a || i || 0,
            innerRadius: u || 0,
            outerRadius: f || l || s || 0,
            clockWise: g
          }
        : t.viewBox
          ? t.viewBox
          : {}
  },
  Ste = function (t, n) {
    return t
      ? t === !0
        ? E.createElement(At, { key: "label-implicit", viewBox: n })
        : it(t)
          ? E.createElement(At, { key: "label-implicit", viewBox: n, value: t })
          : P.isValidElement(t)
            ? t.type === At
              ? P.cloneElement(t, { key: "label-implicit", viewBox: n })
              : E.createElement(At, {
                  key: "label-implicit",
                  content: t,
                  viewBox: n
                })
            : ce(t)
              ? E.createElement(At, {
                  key: "label-implicit",
                  content: t,
                  viewBox: n
                })
              : _a(t)
                ? E.createElement(
                    At,
                    Al({ viewBox: n }, t, { key: "label-implicit" })
                  )
                : null
      : null
  },
  Ote = function (t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0
    if (!t || (!t.children && r && !t.label)) return null
    var i = t.children,
      o = kk(t),
      a = jn(i, At).map(function (l, u) {
        return P.cloneElement(l, { viewBox: n || o, key: "label-".concat(u) })
      })
    if (!r) return a
    var s = Ste(t.label, n || o)
    return [s].concat(ate(a))
  }
At.parseViewBox = kk
At.renderCallByParent = Ote
function Pte(e) {
  var t = e == null ? 0 : e.length
  return t ? e[t - 1] : void 0
}
var $te = Pte
const Ate = Pe($te)
function Tl(e) {
  "@babel/helpers - typeof"
  return (
    (Tl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Tl(e)
  )
}
var Tte = ["valueAccessor"],
  Ete = ["data", "dataKey", "clockWise", "id", "textBreakAll"]
function Cte(e) {
  return jte(e) || Mte(e) || kte(e) || _te()
}
function _te() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function kte(e, t) {
  if (e) {
    if (typeof e == "string") return ig(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return ig(e, t)
  }
}
function Mte(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function jte(e) {
  if (Array.isArray(e)) return ig(e)
}
function ig(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function Wf() {
  return (
    (Wf = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Wf.apply(this, arguments)
  )
}
function kO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function MO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? kO(Object(n), !0).forEach(function (r) {
          Dte(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : kO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Dte(e, t, n) {
  return (
    (t = Ite(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Ite(e) {
  var t = Nte(e, "string")
  return Tl(t) === "symbol" ? t : String(t)
}
function Nte(e, t) {
  if (Tl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Tl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function jO(e, t) {
  if (e == null) return {}
  var n = Rte(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function Rte(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
var Lte = function (t) {
  return Array.isArray(t.value) ? Ate(t.value) : t.value
}
function Xi(e) {
  var t = e.valueAccessor,
    n = t === void 0 ? Lte : t,
    r = jO(e, Tte),
    i = r.data,
    o = r.dataKey,
    a = r.clockWise,
    s = r.id,
    l = r.textBreakAll,
    u = jO(r, Ete)
  return !i || !i.length
    ? null
    : E.createElement(
        ct,
        { className: "recharts-label-list" },
        i.map(function (f, c) {
          var d = xe(o) ? n(f, c) : Yn(f && f.payload, o),
            p = xe(s) ? {} : { id: "".concat(s, "-").concat(c) }
          return E.createElement(
            At,
            Wf({}, he(f, !0), u, p, {
              parentViewBox: f.parentViewBox,
              value: d,
              textBreakAll: l,
              viewBox: At.parseViewBox(
                xe(a) ? f : MO(MO({}, f), {}, { clockWise: a })
              ),
              key: "label-".concat(c),
              index: c
            })
          )
        })
      )
}
Xi.displayName = "LabelList"
function Bte(e, t) {
  return e
    ? e === !0
      ? E.createElement(Xi, { key: "labelList-implicit", data: t })
      : E.isValidElement(e) || ce(e)
        ? E.createElement(Xi, {
            key: "labelList-implicit",
            data: t,
            content: e
          })
        : _a(e)
          ? E.createElement(
              Xi,
              Wf({ data: t }, e, { key: "labelList-implicit" })
            )
          : null
    : null
}
function Fte(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0
  if (!e || (!e.children && n && !e.label)) return null
  var r = e.children,
    i = jn(r, Xi).map(function (a, s) {
      return P.cloneElement(a, { data: t, key: "labelList-".concat(s) })
    })
  if (!n) return i
  var o = Bte(e.label, t)
  return [o].concat(Cte(i))
}
Xi.renderCallByParent = Fte
function El(e) {
  "@babel/helpers - typeof"
  return (
    (El =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    El(e)
  )
}
function og() {
  return (
    (og = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    og.apply(this, arguments)
  )
}
function DO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function IO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? DO(Object(n), !0).forEach(function (r) {
          Vte(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : DO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Vte(e, t, n) {
  return (
    (t = zte(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function zte(e) {
  var t = Ute(e, "string")
  return El(t) === "symbol" ? t : String(t)
}
function Ute(e, t) {
  if (El(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (El(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var Wte = function (t, n) {
    var r = _n(n - t),
      i = Math.min(Math.abs(n - t), 359.999)
    return r * i
  },
  rc = function (t) {
    var n = t.cx,
      r = t.cy,
      i = t.radius,
      o = t.angle,
      a = t.sign,
      s = t.isExternal,
      l = t.cornerRadius,
      u = t.cornerIsExternal,
      f = l * (s ? 1 : -1) + i,
      c = Math.asin(l / f) / Uf,
      d = u ? o : o + a * c,
      p = yt(n, r, f, d),
      h = yt(n, r, i, d),
      m = u ? o - a * c : o,
      b = yt(n, r, f * Math.cos(c * Uf), m)
    return { center: p, circleTangency: h, lineTangency: b, theta: c }
  },
  Mk = function (t) {
    var n = t.cx,
      r = t.cy,
      i = t.innerRadius,
      o = t.outerRadius,
      a = t.startAngle,
      s = t.endAngle,
      l = Wte(a, s),
      u = a + l,
      f = yt(n, r, o, a),
      c = yt(n, r, o, u),
      d = "M "
        .concat(f.x, ",")
        .concat(
          f.y,
          `
    A `
        )
        .concat(o, ",")
        .concat(
          o,
          `,0,
    `
        )
        .concat(+(Math.abs(l) > 180), ",")
        .concat(
          +(a > u),
          `,
    `
        )
        .concat(c.x, ",")
        .concat(
          c.y,
          `
  `
        )
    if (i > 0) {
      var p = yt(n, r, i, a),
        h = yt(n, r, i, u)
      d += "L "
        .concat(h.x, ",")
        .concat(
          h.y,
          `
            A `
        )
        .concat(i, ",")
        .concat(
          i,
          `,0,
            `
        )
        .concat(+(Math.abs(l) > 180), ",")
        .concat(
          +(a <= u),
          `,
            `
        )
        .concat(p.x, ",")
        .concat(p.y, " Z")
    } else d += "L ".concat(n, ",").concat(r, " Z")
    return d
  },
  Hte = function (t) {
    var n = t.cx,
      r = t.cy,
      i = t.innerRadius,
      o = t.outerRadius,
      a = t.cornerRadius,
      s = t.forceCornerRadius,
      l = t.cornerIsExternal,
      u = t.startAngle,
      f = t.endAngle,
      c = _n(f - u),
      d = rc({
        cx: n,
        cy: r,
        radius: o,
        angle: u,
        sign: c,
        cornerRadius: a,
        cornerIsExternal: l
      }),
      p = d.circleTangency,
      h = d.lineTangency,
      m = d.theta,
      b = rc({
        cx: n,
        cy: r,
        radius: o,
        angle: f,
        sign: -c,
        cornerRadius: a,
        cornerIsExternal: l
      }),
      g = b.circleTangency,
      v = b.lineTangency,
      y = b.theta,
      w = l ? Math.abs(u - f) : Math.abs(u - f) - m - y
    if (w < 0)
      return s
        ? "M "
            .concat(h.x, ",")
            .concat(
              h.y,
              `
        a`
            )
            .concat(a, ",")
            .concat(a, ",0,0,1,")
            .concat(
              a * 2,
              `,0
        a`
            )
            .concat(a, ",")
            .concat(a, ",0,0,1,")
            .concat(
              -a * 2,
              `,0
      `
            )
        : Mk({
            cx: n,
            cy: r,
            innerRadius: i,
            outerRadius: o,
            startAngle: u,
            endAngle: f
          })
    var x = "M "
      .concat(h.x, ",")
      .concat(
        h.y,
        `
    A`
      )
      .concat(a, ",")
      .concat(a, ",0,0,")
      .concat(+(c < 0), ",")
      .concat(p.x, ",")
      .concat(
        p.y,
        `
    A`
      )
      .concat(o, ",")
      .concat(o, ",0,")
      .concat(+(w > 180), ",")
      .concat(+(c < 0), ",")
      .concat(g.x, ",")
      .concat(
        g.y,
        `
    A`
      )
      .concat(a, ",")
      .concat(a, ",0,0,")
      .concat(+(c < 0), ",")
      .concat(v.x, ",")
      .concat(
        v.y,
        `
  `
      )
    if (i > 0) {
      var S = rc({
          cx: n,
          cy: r,
          radius: i,
          angle: u,
          sign: c,
          isExternal: !0,
          cornerRadius: a,
          cornerIsExternal: l
        }),
        O = S.circleTangency,
        $ = S.lineTangency,
        A = S.theta,
        C = rc({
          cx: n,
          cy: r,
          radius: i,
          angle: f,
          sign: -c,
          isExternal: !0,
          cornerRadius: a,
          cornerIsExternal: l
        }),
        T = C.circleTangency,
        _ = C.lineTangency,
        R = C.theta,
        M = l ? Math.abs(u - f) : Math.abs(u - f) - A - R
      if (M < 0 && a === 0)
        return "".concat(x, "L").concat(n, ",").concat(r, "Z")
      x += "L"
        .concat(_.x, ",")
        .concat(
          _.y,
          `
      A`
        )
        .concat(a, ",")
        .concat(a, ",0,0,")
        .concat(+(c < 0), ",")
        .concat(T.x, ",")
        .concat(
          T.y,
          `
      A`
        )
        .concat(i, ",")
        .concat(i, ",0,")
        .concat(+(M > 180), ",")
        .concat(+(c > 0), ",")
        .concat(O.x, ",")
        .concat(
          O.y,
          `
      A`
        )
        .concat(a, ",")
        .concat(a, ",0,0,")
        .concat(+(c < 0), ",")
        .concat($.x, ",")
        .concat($.y, "Z")
    } else x += "L".concat(n, ",").concat(r, "Z")
    return x
  },
  Gte = {
    cx: 0,
    cy: 0,
    innerRadius: 0,
    outerRadius: 0,
    startAngle: 0,
    endAngle: 0,
    cornerRadius: 0,
    forceCornerRadius: !1,
    cornerIsExternal: !1
  },
  jk = function (t) {
    var n = IO(IO({}, Gte), t),
      r = n.cx,
      i = n.cy,
      o = n.innerRadius,
      a = n.outerRadius,
      s = n.cornerRadius,
      l = n.forceCornerRadius,
      u = n.cornerIsExternal,
      f = n.startAngle,
      c = n.endAngle,
      d = n.className
    if (a < o || f === c) return null
    var p = Oe("recharts-sector", d),
      h = a - o,
      m = aa(s, h, 0, !0),
      b
    return (
      m > 0 && Math.abs(f - c) < 360
        ? (b = Hte({
            cx: r,
            cy: i,
            innerRadius: o,
            outerRadius: a,
            cornerRadius: Math.min(m, h / 2),
            forceCornerRadius: l,
            cornerIsExternal: u,
            startAngle: f,
            endAngle: c
          }))
        : (b = Mk({
            cx: r,
            cy: i,
            innerRadius: o,
            outerRadius: a,
            startAngle: f,
            endAngle: c
          })),
      E.createElement(
        "path",
        og({}, he(n, !0), { className: p, d: b, role: "img" })
      )
    )
  }
function Cl(e) {
  "@babel/helpers - typeof"
  return (
    (Cl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Cl(e)
  )
}
function ag() {
  return (
    (ag = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    ag.apply(this, arguments)
  )
}
function NO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function RO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? NO(Object(n), !0).forEach(function (r) {
          Kte(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : NO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Kte(e, t, n) {
  return (
    (t = qte(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function qte(e) {
  var t = Xte(e, "string")
  return Cl(t) === "symbol" ? t : String(t)
}
function Xte(e, t) {
  if (Cl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Cl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var LO = {
    curveBasisClosed: RV,
    curveBasisOpen: LV,
    curveBasis: NV,
    curveBumpX: SV,
    curveBumpY: OV,
    curveLinearClosed: BV,
    curveLinear: Qd,
    curveMonotoneX: FV,
    curveMonotoneY: VV,
    curveNatural: zV,
    curveStep: UV,
    curveStepAfter: HV,
    curveStepBefore: WV
  },
  ic = function (t) {
    return t.x === +t.x && t.y === +t.y
  },
  cs = function (t) {
    return t.x
  },
  fs = function (t) {
    return t.y
  },
  Yte = function (t, n) {
    if (ce(t)) return t
    var r = "curve".concat(Xd(t))
    return (r === "curveMonotone" || r === "curveBump") && n
      ? LO["".concat(r).concat(n === "vertical" ? "Y" : "X")]
      : LO[r] || Qd
  },
  Qte = function (t) {
    var n = t.type,
      r = n === void 0 ? "linear" : n,
      i = t.points,
      o = i === void 0 ? [] : i,
      a = t.baseLine,
      s = t.layout,
      l = t.connectNulls,
      u = l === void 0 ? !1 : l,
      f = Yte(r, s),
      c = u
        ? o.filter(function (m) {
            return ic(m)
          })
        : o,
      d
    if (Array.isArray(a)) {
      var p = u
          ? a.filter(function (m) {
              return ic(m)
            })
          : a,
        h = c.map(function (m, b) {
          return RO(RO({}, m), {}, { base: p[b] })
        })
      return (
        s === "vertical"
          ? (d = qu()
              .y(fs)
              .x1(cs)
              .x0(function (m) {
                return m.base.x
              }))
          : (d = qu()
              .x(cs)
              .y1(fs)
              .y0(function (m) {
                return m.base.y
              })),
        d.defined(ic).curve(f),
        d(h)
      )
    }
    return (
      s === "vertical" && G(a)
        ? (d = qu().y(fs).x1(cs).x0(a))
        : G(a)
          ? (d = qu().x(cs).y1(fs).y0(a))
          : (d = kC().x(cs).y(fs)),
      d.defined(ic).curve(f),
      d(c)
    )
  },
  BO = function (t) {
    var n = t.className,
      r = t.points,
      i = t.path,
      o = t.pathRef
    if ((!r || !r.length) && !i) return null
    var a = r && r.length ? Qte(t) : i
    return E.createElement(
      "path",
      ag({}, he(t), cf(t), { className: Oe("recharts-curve", n), d: a, ref: o })
    )
  }
function _l(e) {
  "@babel/helpers - typeof"
  return (
    (_l =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    _l(e)
  )
}
function Hf() {
  return (
    (Hf = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Hf.apply(this, arguments)
  )
}
function Zte(e, t) {
  return nne(e) || tne(e, t) || ene(e, t) || Jte()
}
function Jte() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function ene(e, t) {
  if (e) {
    if (typeof e == "string") return FO(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return FO(e, t)
  }
}
function FO(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function tne(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function nne(e) {
  if (Array.isArray(e)) return e
}
function VO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function zO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? VO(Object(n), !0).forEach(function (r) {
          rne(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : VO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function rne(e, t, n) {
  return (
    (t = ine(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function ine(e) {
  var t = one(e, "string")
  return _l(t) === "symbol" ? t : String(t)
}
function one(e, t) {
  if (_l(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (_l(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var UO = function (t, n, r, i, o) {
    var a = Math.min(Math.abs(r) / 2, Math.abs(i) / 2),
      s = i >= 0 ? 1 : -1,
      l = r >= 0 ? 1 : -1,
      u = (i >= 0 && r >= 0) || (i < 0 && r < 0) ? 1 : 0,
      f
    if (a > 0 && o instanceof Array) {
      for (var c = [0, 0, 0, 0], d = 0, p = 4; d < p; d++)
        c[d] = o[d] > a ? a : o[d]
      ;(f = "M".concat(t, ",").concat(n + s * c[0])),
        c[0] > 0 &&
          (f += "A "
            .concat(c[0], ",")
            .concat(c[0], ",0,0,")
            .concat(u, ",")
            .concat(t + l * c[0], ",")
            .concat(n)),
        (f += "L ".concat(t + r - l * c[1], ",").concat(n)),
        c[1] > 0 &&
          (f += "A "
            .concat(c[1], ",")
            .concat(c[1], ",0,0,")
            .concat(
              u,
              `,
        `
            )
            .concat(t + r, ",")
            .concat(n + s * c[1])),
        (f += "L ".concat(t + r, ",").concat(n + i - s * c[2])),
        c[2] > 0 &&
          (f += "A "
            .concat(c[2], ",")
            .concat(c[2], ",0,0,")
            .concat(
              u,
              `,
        `
            )
            .concat(t + r - l * c[2], ",")
            .concat(n + i)),
        (f += "L ".concat(t + l * c[3], ",").concat(n + i)),
        c[3] > 0 &&
          (f += "A "
            .concat(c[3], ",")
            .concat(c[3], ",0,0,")
            .concat(
              u,
              `,
        `
            )
            .concat(t, ",")
            .concat(n + i - s * c[3])),
        (f += "Z")
    } else if (a > 0 && o === +o && o > 0) {
      var h = Math.min(a, o)
      f = "M "
        .concat(t, ",")
        .concat(
          n + s * h,
          `
            A `
        )
        .concat(h, ",")
        .concat(h, ",0,0,")
        .concat(u, ",")
        .concat(t + l * h, ",")
        .concat(
          n,
          `
            L `
        )
        .concat(t + r - l * h, ",")
        .concat(
          n,
          `
            A `
        )
        .concat(h, ",")
        .concat(h, ",0,0,")
        .concat(u, ",")
        .concat(t + r, ",")
        .concat(
          n + s * h,
          `
            L `
        )
        .concat(t + r, ",")
        .concat(
          n + i - s * h,
          `
            A `
        )
        .concat(h, ",")
        .concat(h, ",0,0,")
        .concat(u, ",")
        .concat(t + r - l * h, ",")
        .concat(
          n + i,
          `
            L `
        )
        .concat(t + l * h, ",")
        .concat(
          n + i,
          `
            A `
        )
        .concat(h, ",")
        .concat(h, ",0,0,")
        .concat(u, ",")
        .concat(t, ",")
        .concat(n + i - s * h, " Z")
    } else
      f = "M "
        .concat(t, ",")
        .concat(n, " h ")
        .concat(r, " v ")
        .concat(i, " h ")
        .concat(-r, " Z")
    return f
  },
  ane = function (t, n) {
    if (!t || !n) return !1
    var r = t.x,
      i = t.y,
      o = n.x,
      a = n.y,
      s = n.width,
      l = n.height
    if (Math.abs(s) > 0 && Math.abs(l) > 0) {
      var u = Math.min(o, o + s),
        f = Math.max(o, o + s),
        c = Math.min(a, a + l),
        d = Math.max(a, a + l)
      return r >= u && r <= f && i >= c && i <= d
    }
    return !1
  },
  sne = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    radius: 0,
    isAnimationActive: !1,
    isUpdateAnimationActive: !1,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "ease"
  },
  G0 = function (t) {
    var n = zO(zO({}, sne), t),
      r = P.useRef(),
      i = P.useState(-1),
      o = Zte(i, 2),
      a = o[0],
      s = o[1]
    P.useEffect(function () {
      if (r.current && r.current.getTotalLength)
        try {
          var w = r.current.getTotalLength()
          w && s(w)
        } catch {}
    }, [])
    var l = n.x,
      u = n.y,
      f = n.width,
      c = n.height,
      d = n.radius,
      p = n.className,
      h = n.animationEasing,
      m = n.animationDuration,
      b = n.animationBegin,
      g = n.isAnimationActive,
      v = n.isUpdateAnimationActive
    if (l !== +l || u !== +u || f !== +f || c !== +c || f === 0 || c === 0)
      return null
    var y = Oe("recharts-rectangle", p)
    return v
      ? E.createElement(
          pi,
          {
            canBegin: a > 0,
            from: { width: f, height: c, x: l, y: u },
            to: { width: f, height: c, x: l, y: u },
            duration: m,
            animationEasing: h,
            isActive: v
          },
          function (w) {
            var x = w.width,
              S = w.height,
              O = w.x,
              $ = w.y
            return E.createElement(
              pi,
              {
                canBegin: a > 0,
                from: "0px ".concat(a === -1 ? 1 : a, "px"),
                to: "".concat(a, "px 0px"),
                attributeName: "strokeDasharray",
                begin: b,
                duration: m,
                isActive: g,
                easing: h
              },
              E.createElement(
                "path",
                Hf({}, he(n, !0), {
                  className: y,
                  d: UO(O, $, x, S, d),
                  ref: r
                })
              )
            )
          }
        )
      : E.createElement(
          "path",
          Hf({}, he(n, !0), { className: y, d: UO(l, u, f, c, d) })
        )
  }
function sg() {
  return (
    (sg = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    sg.apply(this, arguments)
  )
}
var Dk = function (t) {
  var n = t.cx,
    r = t.cy,
    i = t.r,
    o = t.className,
    a = Oe("recharts-dot", o)
  return n === +n && r === +r && i === +i
    ? E.createElement(
        "circle",
        sg({}, he(t), cf(t), { className: a, cx: n, cy: r, r: i })
      )
    : null
}
function kl(e) {
  "@babel/helpers - typeof"
  return (
    (kl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    kl(e)
  )
}
var lne = ["x", "y", "top", "left", "width", "height", "className"]
function lg() {
  return (
    (lg = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    lg.apply(this, arguments)
  )
}
function WO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function une(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? WO(Object(n), !0).forEach(function (r) {
          cne(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : WO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function cne(e, t, n) {
  return (
    (t = fne(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function fne(e) {
  var t = dne(e, "string")
  return kl(t) === "symbol" ? t : String(t)
}
function dne(e, t) {
  if (kl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (kl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function pne(e, t) {
  if (e == null) return {}
  var n = hne(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function hne(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
var mne = function (t, n, r, i, o, a) {
    return "M"
      .concat(t, ",")
      .concat(o, "v")
      .concat(i, "M")
      .concat(a, ",")
      .concat(n, "h")
      .concat(r)
  },
  vne = function (t) {
    var n = t.x,
      r = n === void 0 ? 0 : n,
      i = t.y,
      o = i === void 0 ? 0 : i,
      a = t.top,
      s = a === void 0 ? 0 : a,
      l = t.left,
      u = l === void 0 ? 0 : l,
      f = t.width,
      c = f === void 0 ? 0 : f,
      d = t.height,
      p = d === void 0 ? 0 : d,
      h = t.className,
      m = pne(t, lne),
      b = une({ x: r, y: o, top: s, left: u, width: c, height: p }, m)
    return !G(r) || !G(o) || !G(c) || !G(p) || !G(s) || !G(u)
      ? null
      : E.createElement(
          "path",
          lg({}, he(b, !0), {
            className: Oe("recharts-cross", h),
            d: mne(r, o, c, p, s, u)
          })
        )
  },
  gne = e_,
  yne = gne(Object.getPrototypeOf, Object),
  bne = yne,
  xne = Cr,
  wne = bne,
  Sne = _r,
  One = "[object Object]",
  Pne = Function.prototype,
  $ne = Object.prototype,
  Ik = Pne.toString,
  Ane = $ne.hasOwnProperty,
  Tne = Ik.call(Object)
function Ene(e) {
  if (!Sne(e) || xne(e) != One) return !1
  var t = wne(e)
  if (t === null) return !0
  var n = Ane.call(t, "constructor") && t.constructor
  return typeof n == "function" && n instanceof n && Ik.call(n) == Tne
}
var Cne = Ene
const _ne = Pe(Cne)
var kne = Cr,
  Mne = _r,
  jne = "[object Boolean]"
function Dne(e) {
  return e === !0 || e === !1 || (Mne(e) && kne(e) == jne)
}
var Ine = Dne
const Nne = Pe(Ine)
function Ml(e) {
  "@babel/helpers - typeof"
  return (
    (Ml =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Ml(e)
  )
}
function Gf() {
  return (
    (Gf = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Gf.apply(this, arguments)
  )
}
function Rne(e, t) {
  return Vne(e) || Fne(e, t) || Bne(e, t) || Lne()
}
function Lne() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Bne(e, t) {
  if (e) {
    if (typeof e == "string") return HO(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return HO(e, t)
  }
}
function HO(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function Fne(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function Vne(e) {
  if (Array.isArray(e)) return e
}
function GO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function KO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? GO(Object(n), !0).forEach(function (r) {
          zne(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : GO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function zne(e, t, n) {
  return (
    (t = Une(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Une(e) {
  var t = Wne(e, "string")
  return Ml(t) === "symbol" ? t : String(t)
}
function Wne(e, t) {
  if (Ml(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Ml(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var qO = function (t, n, r, i, o) {
    var a = r - i,
      s
    return (
      (s = "M ".concat(t, ",").concat(n)),
      (s += "L ".concat(t + r, ",").concat(n)),
      (s += "L ".concat(t + r - a / 2, ",").concat(n + o)),
      (s += "L ".concat(t + r - a / 2 - i, ",").concat(n + o)),
      (s += "L ".concat(t, ",").concat(n, " Z")),
      s
    )
  },
  Hne = {
    x: 0,
    y: 0,
    upperWidth: 0,
    lowerWidth: 0,
    height: 0,
    isUpdateAnimationActive: !1,
    animationBegin: 0,
    animationDuration: 1500,
    animationEasing: "ease"
  },
  Gne = function (t) {
    var n = KO(KO({}, Hne), t),
      r = P.useRef(),
      i = P.useState(-1),
      o = Rne(i, 2),
      a = o[0],
      s = o[1]
    P.useEffect(function () {
      if (r.current && r.current.getTotalLength)
        try {
          var y = r.current.getTotalLength()
          y && s(y)
        } catch {}
    }, [])
    var l = n.x,
      u = n.y,
      f = n.upperWidth,
      c = n.lowerWidth,
      d = n.height,
      p = n.className,
      h = n.animationEasing,
      m = n.animationDuration,
      b = n.animationBegin,
      g = n.isUpdateAnimationActive
    if (
      l !== +l ||
      u !== +u ||
      f !== +f ||
      c !== +c ||
      d !== +d ||
      (f === 0 && c === 0) ||
      d === 0
    )
      return null
    var v = Oe("recharts-trapezoid", p)
    return g
      ? E.createElement(
          pi,
          {
            canBegin: a > 0,
            from: { upperWidth: 0, lowerWidth: 0, height: d, x: l, y: u },
            to: { upperWidth: f, lowerWidth: c, height: d, x: l, y: u },
            duration: m,
            animationEasing: h,
            isActive: g
          },
          function (y) {
            var w = y.upperWidth,
              x = y.lowerWidth,
              S = y.height,
              O = y.x,
              $ = y.y
            return E.createElement(
              pi,
              {
                canBegin: a > 0,
                from: "0px ".concat(a === -1 ? 1 : a, "px"),
                to: "".concat(a, "px 0px"),
                attributeName: "strokeDasharray",
                begin: b,
                duration: m,
                easing: h
              },
              E.createElement(
                "path",
                Gf({}, he(n, !0), {
                  className: v,
                  d: qO(O, $, w, x, S),
                  ref: r
                })
              )
            )
          }
        )
      : E.createElement(
          "g",
          null,
          E.createElement(
            "path",
            Gf({}, he(n, !0), { className: v, d: qO(l, u, f, c, d) })
          )
        )
  },
  Kne = [
    "option",
    "shapeType",
    "propTransformer",
    "activeClassName",
    "isActive"
  ]
function jl(e) {
  "@babel/helpers - typeof"
  return (
    (jl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    jl(e)
  )
}
function qne(e, t) {
  if (e == null) return {}
  var n = Xne(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function Xne(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function XO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Kf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? XO(Object(n), !0).forEach(function (r) {
          Yne(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : XO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Yne(e, t, n) {
  return (
    (t = Qne(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Qne(e) {
  var t = Zne(e, "string")
  return jl(t) === "symbol" ? t : String(t)
}
function Zne(e, t) {
  if (jl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (jl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function Jne(e, t) {
  return Kf(Kf({}, t), e)
}
function ere(e, t) {
  return e === "symbols"
}
function YO(e) {
  var t = e.shapeType,
    n = e.elementProps
  switch (t) {
    case "rectangle":
      return E.createElement(G0, n)
    case "trapezoid":
      return E.createElement(Gne, n)
    case "sector":
      return E.createElement(jk, n)
    case "symbols":
      if (ere(t)) return E.createElement(u0, n)
      break
    default:
      return null
  }
}
function tre(e) {
  return P.isValidElement(e) ? e.props : e
}
function nre(e) {
  var t = e.option,
    n = e.shapeType,
    r = e.propTransformer,
    i = r === void 0 ? Jne : r,
    o = e.activeClassName,
    a = o === void 0 ? "recharts-active-shape" : o,
    s = e.isActive,
    l = qne(e, Kne),
    u
  if (P.isValidElement(t)) u = P.cloneElement(t, Kf(Kf({}, l), tre(t)))
  else if (ce(t)) u = t(l)
  else if (_ne(t) && !Nne(t)) {
    var f = i(t, l)
    u = E.createElement(YO, { shapeType: n, elementProps: f })
  } else {
    var c = l
    u = E.createElement(YO, { shapeType: n, elementProps: c })
  }
  return s ? E.createElement(ct, { className: a }, u) : u
}
function pp(e, t) {
  return t != null && "trapezoids" in e.props
}
function hp(e, t) {
  return t != null && "sectors" in e.props
}
function Dl(e, t) {
  return t != null && "points" in e.props
}
function rre(e, t) {
  var n,
    r,
    i =
      e.x ===
        (t == null || (n = t.labelViewBox) === null || n === void 0
          ? void 0
          : n.x) || e.x === t.x,
    o =
      e.y ===
        (t == null || (r = t.labelViewBox) === null || r === void 0
          ? void 0
          : r.y) || e.y === t.y
  return i && o
}
function ire(e, t) {
  var n = e.endAngle === t.endAngle,
    r = e.startAngle === t.startAngle
  return n && r
}
function ore(e, t) {
  var n = e.x === t.x,
    r = e.y === t.y,
    i = e.z === t.z
  return n && r && i
}
function are(e, t) {
  var n
  return pp(e, t) ? (n = rre) : hp(e, t) ? (n = ire) : Dl(e, t) && (n = ore), n
}
function sre(e, t) {
  var n
  return (
    pp(e, t)
      ? (n = "trapezoids")
      : hp(e, t)
        ? (n = "sectors")
        : Dl(e, t) && (n = "points"),
    n
  )
}
function lre(e, t) {
  if (pp(e, t)) {
    var n
    return (n = t.tooltipPayload) === null ||
      n === void 0 ||
      (n = n[0]) === null ||
      n === void 0 ||
      (n = n.payload) === null ||
      n === void 0
      ? void 0
      : n.payload
  }
  if (hp(e, t)) {
    var r
    return (r = t.tooltipPayload) === null ||
      r === void 0 ||
      (r = r[0]) === null ||
      r === void 0 ||
      (r = r.payload) === null ||
      r === void 0
      ? void 0
      : r.payload
  }
  return Dl(e, t) ? t.payload : {}
}
function ure(e) {
  var t = e.activeTooltipItem,
    n = e.graphicalItem,
    r = e.itemData,
    i = sre(n, t),
    o = lre(n, t),
    a = r.filter(function (l, u) {
      var f = z0(o, l),
        c = n.props[i].filter(function (h) {
          var m = are(n, t)
          return m(h, t)
        }),
        d = n.props[i].indexOf(c[c.length - 1]),
        p = u === d
      return f && p
    }),
    s = r.indexOf(a[a.length - 1])
  return s
}
var cre = Math.ceil,
  fre = Math.max
function dre(e, t, n, r) {
  for (var i = -1, o = fre(cre((t - e) / (n || 1)), 0), a = Array(o); o--; )
    (a[r ? o : ++i] = e), (e += n)
  return a
}
var pre = dre,
  hre = T_,
  QO = 1 / 0,
  mre = 17976931348623157e292
function vre(e) {
  if (!e) return e === 0 ? e : 0
  if (((e = hre(e)), e === QO || e === -QO)) {
    var t = e < 0 ? -1 : 1
    return t * mre
  }
  return e === e ? e : 0
}
var Nk = vre,
  gre = pre,
  yre = tp,
  zh = Nk
function bre(e) {
  return function (t, n, r) {
    return (
      r && typeof r != "number" && yre(t, n, r) && (n = r = void 0),
      (t = zh(t)),
      n === void 0 ? ((n = t), (t = 0)) : (n = zh(n)),
      (r = r === void 0 ? (t < n ? 1 : -1) : zh(r)),
      gre(t, n, r, e)
    )
  }
}
var xre = bre,
  wre = xre,
  Sre = wre(),
  Ore = Sre
const qf = Pe(Ore)
function Il(e) {
  "@babel/helpers - typeof"
  return (
    (Il =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Il(e)
  )
}
function ZO(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function JO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? ZO(Object(n), !0).forEach(function (r) {
          Rk(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : ZO(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Rk(e, t, n) {
  return (
    (t = Pre(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Pre(e) {
  var t = $re(e, "string")
  return Il(t) === "symbol" ? t : String(t)
}
function $re(e, t) {
  if (Il(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Il(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var Are = ["Webkit", "Moz", "O", "ms"],
  Tre = function (t, n) {
    if (!t) return null
    var r = t.replace(/(\w)/, function (o) {
        return o.toUpperCase()
      }),
      i = Are.reduce(function (o, a) {
        return JO(JO({}, o), {}, Rk({}, a + r, n))
      }, {})
    return (i[t] = n), i
  }
function ga(e) {
  "@babel/helpers - typeof"
  return (
    (ga =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    ga(e)
  )
}
function Xf() {
  return (
    (Xf = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Xf.apply(this, arguments)
  )
}
function eP(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Uh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? eP(Object(n), !0).forEach(function (r) {
          Wt(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : eP(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Ere(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function tP(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, Lk(r.key), r)
  }
}
function Cre(e, t, n) {
  return (
    t && tP(e.prototype, t),
    n && tP(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function _re(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 }
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && ug(e, t)
}
function ug(e, t) {
  return (
    (ug = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r
        }),
    ug(e, t)
  )
}
function kre(e) {
  var t = jre()
  return function () {
    var r = Yf(e),
      i
    if (t) {
      var o = Yf(this).constructor
      i = Reflect.construct(r, arguments, o)
    } else i = r.apply(this, arguments)
    return Mre(this, i)
  }
}
function Mre(e, t) {
  if (t && (ga(t) === "object" || typeof t == "function")) return t
  if (t !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return Bn(e)
}
function Bn(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return e
}
function jre() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function Yf(e) {
  return (
    (Yf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n)
        }),
    Yf(e)
  )
}
function Wt(e, t, n) {
  return (
    (t = Lk(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Lk(e) {
  var t = Dre(e, "string")
  return ga(t) === "symbol" ? t : String(t)
}
function Dre(e, t) {
  if (ga(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (ga(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var Ire = function (t) {
    var n = t.data,
      r = t.startIndex,
      i = t.endIndex,
      o = t.x,
      a = t.width,
      s = t.travellerWidth
    if (!n || !n.length) return {}
    var l = n.length,
      u = Ns()
        .domain(qf(0, l))
        .range([o, o + a - s]),
      f = u.domain().map(function (c) {
        return u(c)
      })
    return {
      isTextActive: !1,
      isSlideMoving: !1,
      isTravellerMoving: !1,
      isTravellerFocused: !1,
      startX: u(r),
      endX: u(i),
      scale: u,
      scaleValues: f
    }
  },
  nP = function (t) {
    return t.changedTouches && !!t.changedTouches.length
  },
  Nl = (function (e) {
    _re(n, e)
    var t = kre(n)
    function n(r) {
      var i
      return (
        Ere(this, n),
        (i = t.call(this, r)),
        Wt(Bn(i), "handleDrag", function (o) {
          i.leaveTimer && (clearTimeout(i.leaveTimer), (i.leaveTimer = null)),
            i.state.isTravellerMoving
              ? i.handleTravellerMove(o)
              : i.state.isSlideMoving && i.handleSlideDrag(o)
        }),
        Wt(Bn(i), "handleTouchMove", function (o) {
          o.changedTouches != null &&
            o.changedTouches.length > 0 &&
            i.handleDrag(o.changedTouches[0])
        }),
        Wt(Bn(i), "handleDragEnd", function () {
          i.setState({ isTravellerMoving: !1, isSlideMoving: !1 }, function () {
            var o = i.props,
              a = o.endIndex,
              s = o.onDragEnd,
              l = o.startIndex
            s == null || s({ endIndex: a, startIndex: l })
          }),
            i.detachDragEndListener()
        }),
        Wt(Bn(i), "handleLeaveWrapper", function () {
          ;(i.state.isTravellerMoving || i.state.isSlideMoving) &&
            (i.leaveTimer = window.setTimeout(
              i.handleDragEnd,
              i.props.leaveTimeOut
            ))
        }),
        Wt(Bn(i), "handleEnterSlideOrTraveller", function () {
          i.setState({ isTextActive: !0 })
        }),
        Wt(Bn(i), "handleLeaveSlideOrTraveller", function () {
          i.setState({ isTextActive: !1 })
        }),
        Wt(Bn(i), "handleSlideDragStart", function (o) {
          var a = nP(o) ? o.changedTouches[0] : o
          i.setState({
            isTravellerMoving: !1,
            isSlideMoving: !0,
            slideMoveStartX: a.pageX
          }),
            i.attachDragEndListener()
        }),
        (i.travellerDragStartHandlers = {
          startX: i.handleTravellerDragStart.bind(Bn(i), "startX"),
          endX: i.handleTravellerDragStart.bind(Bn(i), "endX")
        }),
        (i.state = {}),
        i
      )
    }
    return (
      Cre(
        n,
        [
          {
            key: "componentWillUnmount",
            value: function () {
              this.leaveTimer &&
                (clearTimeout(this.leaveTimer), (this.leaveTimer = null)),
                this.detachDragEndListener()
            }
          },
          {
            key: "getIndex",
            value: function (i) {
              var o = i.startX,
                a = i.endX,
                s = this.state.scaleValues,
                l = this.props,
                u = l.gap,
                f = l.data,
                c = f.length - 1,
                d = Math.min(o, a),
                p = Math.max(o, a),
                h = n.getIndexInRange(s, d),
                m = n.getIndexInRange(s, p)
              return {
                startIndex: h - (h % u),
                endIndex: m === c ? c : m - (m % u)
              }
            }
          },
          {
            key: "getTextOfTick",
            value: function (i) {
              var o = this.props,
                a = o.data,
                s = o.tickFormatter,
                l = o.dataKey,
                u = Yn(a[i], l, i)
              return ce(s) ? s(u, i) : u
            }
          },
          {
            key: "attachDragEndListener",
            value: function () {
              window.addEventListener("mouseup", this.handleDragEnd, !0),
                window.addEventListener("touchend", this.handleDragEnd, !0),
                window.addEventListener("mousemove", this.handleDrag, !0)
            }
          },
          {
            key: "detachDragEndListener",
            value: function () {
              window.removeEventListener("mouseup", this.handleDragEnd, !0),
                window.removeEventListener("touchend", this.handleDragEnd, !0),
                window.removeEventListener("mousemove", this.handleDrag, !0)
            }
          },
          {
            key: "handleSlideDrag",
            value: function (i) {
              var o = this.state,
                a = o.slideMoveStartX,
                s = o.startX,
                l = o.endX,
                u = this.props,
                f = u.x,
                c = u.width,
                d = u.travellerWidth,
                p = u.startIndex,
                h = u.endIndex,
                m = u.onChange,
                b = i.pageX - a
              b > 0
                ? (b = Math.min(b, f + c - d - l, f + c - d - s))
                : b < 0 && (b = Math.max(b, f - s, f - l))
              var g = this.getIndex({ startX: s + b, endX: l + b })
              ;(g.startIndex !== p || g.endIndex !== h) && m && m(g),
                this.setState({
                  startX: s + b,
                  endX: l + b,
                  slideMoveStartX: i.pageX
                })
            }
          },
          {
            key: "handleTravellerDragStart",
            value: function (i, o) {
              var a = nP(o) ? o.changedTouches[0] : o
              this.setState({
                isSlideMoving: !1,
                isTravellerMoving: !0,
                movingTravellerId: i,
                brushMoveStartX: a.pageX
              }),
                this.attachDragEndListener()
            }
          },
          {
            key: "handleTravellerMove",
            value: function (i) {
              var o,
                a = this.state,
                s = a.brushMoveStartX,
                l = a.movingTravellerId,
                u = a.endX,
                f = a.startX,
                c = this.state[l],
                d = this.props,
                p = d.x,
                h = d.width,
                m = d.travellerWidth,
                b = d.onChange,
                g = d.gap,
                v = d.data,
                y = { startX: this.state.startX, endX: this.state.endX },
                w = i.pageX - s
              w > 0
                ? (w = Math.min(w, p + h - m - c))
                : w < 0 && (w = Math.max(w, p - c)),
                (y[l] = c + w)
              var x = this.getIndex(y),
                S = x.startIndex,
                O = x.endIndex,
                $ = function () {
                  var C = v.length - 1
                  return (
                    (l === "startX" && (u > f ? S % g === 0 : O % g === 0)) ||
                    (u < f && O === C) ||
                    (l === "endX" && (u > f ? O % g === 0 : S % g === 0)) ||
                    (u > f && O === C)
                  )
                }
              this.setState(
                ((o = {}),
                Wt(o, l, c + w),
                Wt(o, "brushMoveStartX", i.pageX),
                o),
                function () {
                  b && $() && b(x)
                }
              )
            }
          },
          {
            key: "handleTravellerMoveKeyboard",
            value: function (i, o) {
              var a = this,
                s = this.state,
                l = s.scaleValues,
                u = s.startX,
                f = s.endX,
                c = this.state[o],
                d = l.indexOf(c)
              if (d !== -1) {
                var p = d + i
                if (!(p === -1 || p >= l.length)) {
                  var h = l[p]
                  ;(o === "startX" && h >= f) ||
                    (o === "endX" && h <= u) ||
                    this.setState(Wt({}, o, h), function () {
                      a.props.onChange(
                        a.getIndex({
                          startX: a.state.startX,
                          endX: a.state.endX
                        })
                      )
                    })
                }
              }
            }
          },
          {
            key: "renderBackground",
            value: function () {
              var i = this.props,
                o = i.x,
                a = i.y,
                s = i.width,
                l = i.height,
                u = i.fill,
                f = i.stroke
              return E.createElement("rect", {
                stroke: f,
                fill: u,
                x: o,
                y: a,
                width: s,
                height: l
              })
            }
          },
          {
            key: "renderPanorama",
            value: function () {
              var i = this.props,
                o = i.x,
                a = i.y,
                s = i.width,
                l = i.height,
                u = i.data,
                f = i.children,
                c = i.padding,
                d = P.Children.only(f)
              return d
                ? E.cloneElement(d, {
                    x: o,
                    y: a,
                    width: s,
                    height: l,
                    margin: c,
                    compact: !0,
                    data: u
                  })
                : null
            }
          },
          {
            key: "renderTravellerLayer",
            value: function (i, o) {
              var a = this,
                s = this.props,
                l = s.y,
                u = s.travellerWidth,
                f = s.height,
                c = s.traveller,
                d = s.ariaLabel,
                p = s.data,
                h = s.startIndex,
                m = s.endIndex,
                b = Math.max(i, this.props.x),
                g = Uh(
                  Uh({}, he(this.props)),
                  {},
                  { x: b, y: l, width: u, height: f }
                ),
                v =
                  d ||
                  "Min value: "
                    .concat(p[h].name, ", Max value: ")
                    .concat(p[m].name)
              return E.createElement(
                ct,
                {
                  tabIndex: 0,
                  role: "slider",
                  "aria-label": v,
                  "aria-valuenow": i,
                  className: "recharts-brush-traveller",
                  onMouseEnter: this.handleEnterSlideOrTraveller,
                  onMouseLeave: this.handleLeaveSlideOrTraveller,
                  onMouseDown: this.travellerDragStartHandlers[o],
                  onTouchStart: this.travellerDragStartHandlers[o],
                  onKeyDown: function (w) {
                    ;["ArrowLeft", "ArrowRight"].includes(w.key) &&
                      (w.preventDefault(),
                      w.stopPropagation(),
                      a.handleTravellerMoveKeyboard(
                        w.key === "ArrowRight" ? 1 : -1,
                        o
                      ))
                  },
                  onFocus: function () {
                    a.setState({ isTravellerFocused: !0 })
                  },
                  onBlur: function () {
                    a.setState({ isTravellerFocused: !1 })
                  },
                  style: { cursor: "col-resize" }
                },
                n.renderTraveller(c, g)
              )
            }
          },
          {
            key: "renderSlide",
            value: function (i, o) {
              var a = this.props,
                s = a.y,
                l = a.height,
                u = a.stroke,
                f = a.travellerWidth,
                c = Math.min(i, o) + f,
                d = Math.max(Math.abs(o - i) - f, 0)
              return E.createElement("rect", {
                className: "recharts-brush-slide",
                onMouseEnter: this.handleEnterSlideOrTraveller,
                onMouseLeave: this.handleLeaveSlideOrTraveller,
                onMouseDown: this.handleSlideDragStart,
                onTouchStart: this.handleSlideDragStart,
                style: { cursor: "move" },
                stroke: "none",
                fill: u,
                fillOpacity: 0.2,
                x: c,
                y: s,
                width: d,
                height: l
              })
            }
          },
          {
            key: "renderText",
            value: function () {
              var i = this.props,
                o = i.startIndex,
                a = i.endIndex,
                s = i.y,
                l = i.height,
                u = i.travellerWidth,
                f = i.stroke,
                c = this.state,
                d = c.startX,
                p = c.endX,
                h = 5,
                m = { pointerEvents: "none", fill: f }
              return E.createElement(
                ct,
                { className: "recharts-brush-texts" },
                E.createElement(
                  Cf,
                  Xf(
                    {
                      textAnchor: "end",
                      verticalAnchor: "middle",
                      x: Math.min(d, p) - h,
                      y: s + l / 2
                    },
                    m
                  ),
                  this.getTextOfTick(o)
                ),
                E.createElement(
                  Cf,
                  Xf(
                    {
                      textAnchor: "start",
                      verticalAnchor: "middle",
                      x: Math.max(d, p) + u + h,
                      y: s + l / 2
                    },
                    m
                  ),
                  this.getTextOfTick(a)
                )
              )
            }
          },
          {
            key: "render",
            value: function () {
              var i = this.props,
                o = i.data,
                a = i.className,
                s = i.children,
                l = i.x,
                u = i.y,
                f = i.width,
                c = i.height,
                d = i.alwaysShowText,
                p = this.state,
                h = p.startX,
                m = p.endX,
                b = p.isTextActive,
                g = p.isSlideMoving,
                v = p.isTravellerMoving,
                y = p.isTravellerFocused
              if (
                !o ||
                !o.length ||
                !G(l) ||
                !G(u) ||
                !G(f) ||
                !G(c) ||
                f <= 0 ||
                c <= 0
              )
                return null
              var w = Oe("recharts-brush", a),
                x = E.Children.count(s) === 1,
                S = Tre("userSelect", "none")
              return E.createElement(
                ct,
                {
                  className: w,
                  onMouseLeave: this.handleLeaveWrapper,
                  onTouchMove: this.handleTouchMove,
                  style: S
                },
                this.renderBackground(),
                x && this.renderPanorama(),
                this.renderSlide(h, m),
                this.renderTravellerLayer(h, "startX"),
                this.renderTravellerLayer(m, "endX"),
                (b || g || v || y || d) && this.renderText()
              )
            }
          }
        ],
        [
          {
            key: "renderDefaultTraveller",
            value: function (i) {
              var o = i.x,
                a = i.y,
                s = i.width,
                l = i.height,
                u = i.stroke,
                f = Math.floor(a + l / 2) - 1
              return E.createElement(
                E.Fragment,
                null,
                E.createElement("rect", {
                  x: o,
                  y: a,
                  width: s,
                  height: l,
                  fill: u,
                  stroke: "none"
                }),
                E.createElement("line", {
                  x1: o + 1,
                  y1: f,
                  x2: o + s - 1,
                  y2: f,
                  fill: "none",
                  stroke: "#fff"
                }),
                E.createElement("line", {
                  x1: o + 1,
                  y1: f + 2,
                  x2: o + s - 1,
                  y2: f + 2,
                  fill: "none",
                  stroke: "#fff"
                })
              )
            }
          },
          {
            key: "renderTraveller",
            value: function (i, o) {
              var a
              return (
                E.isValidElement(i)
                  ? (a = E.cloneElement(i, o))
                  : ce(i)
                    ? (a = i(o))
                    : (a = n.renderDefaultTraveller(o)),
                a
              )
            }
          },
          {
            key: "getDerivedStateFromProps",
            value: function (i, o) {
              var a = i.data,
                s = i.width,
                l = i.x,
                u = i.travellerWidth,
                f = i.updateId,
                c = i.startIndex,
                d = i.endIndex
              if (a !== o.prevData || f !== o.prevUpdateId)
                return Uh(
                  {
                    prevData: a,
                    prevTravellerWidth: u,
                    prevUpdateId: f,
                    prevX: l,
                    prevWidth: s
                  },
                  a && a.length
                    ? Ire({
                        data: a,
                        width: s,
                        x: l,
                        travellerWidth: u,
                        startIndex: c,
                        endIndex: d
                      })
                    : { scale: null, scaleValues: null }
                )
              if (
                o.scale &&
                (s !== o.prevWidth ||
                  l !== o.prevX ||
                  u !== o.prevTravellerWidth)
              ) {
                o.scale.range([l, l + s - u])
                var p = o.scale.domain().map(function (h) {
                  return o.scale(h)
                })
                return {
                  prevData: a,
                  prevTravellerWidth: u,
                  prevUpdateId: f,
                  prevX: l,
                  prevWidth: s,
                  startX: o.scale(i.startIndex),
                  endX: o.scale(i.endIndex),
                  scaleValues: p
                }
              }
              return null
            }
          },
          {
            key: "getIndexInRange",
            value: function (i, o) {
              for (var a = i.length, s = 0, l = a - 1; l - s > 1; ) {
                var u = Math.floor((s + l) / 2)
                i[u] > o ? (l = u) : (s = u)
              }
              return o >= i[l] ? l : s
            }
          }
        ]
      ),
      n
    )
  })(P.PureComponent)
Wt(Nl, "displayName", "Brush")
Wt(Nl, "defaultProps", {
  height: 40,
  travellerWidth: 5,
  gap: 1,
  fill: "#fff",
  stroke: "#666",
  padding: { top: 1, right: 1, bottom: 1, left: 1 },
  leaveTimeOut: 1e3,
  alwaysShowText: !1
})
var Nre = v0
function Rre(e, t) {
  var n
  return (
    Nre(e, function (r, i, o) {
      return (n = t(r, i, o)), !n
    }),
    !!n
  )
}
var Lre = Rre,
  Bre = GC,
  Fre = Si,
  Vre = Lre,
  zre = Ut,
  Ure = tp
function Wre(e, t, n) {
  var r = zre(e) ? Bre : Vre
  return n && Ure(e, t, n) && (t = void 0), r(e, Fre(t))
}
var Hre = Wre
const Gre = Pe(Hre)
var qn = function (t, n) {
    var r = t.alwaysShow,
      i = t.ifOverflow
    return r && (i = "extendDomain"), i === n
  },
  rP = h_
function Kre(e, t, n) {
  t == "__proto__" && rP
    ? rP(e, t, { configurable: !0, enumerable: !0, value: n, writable: !0 })
    : (e[t] = n)
}
var qre = Kre,
  Xre = qre,
  Yre = d_,
  Qre = Si
function Zre(e, t) {
  var n = {}
  return (
    (t = Qre(t)),
    Yre(e, function (r, i, o) {
      Xre(n, i, t(r, i, o))
    }),
    n
  )
}
var Jre = Zre
const eie = Pe(Jre)
function tie(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (!t(e[n], n, e)) return !1
  return !0
}
var nie = tie,
  rie = v0
function iie(e, t) {
  var n = !0
  return (
    rie(e, function (r, i, o) {
      return (n = !!t(r, i, o)), n
    }),
    n
  )
}
var oie = iie,
  aie = nie,
  sie = oie,
  lie = Si,
  uie = Ut,
  cie = tp
function fie(e, t, n) {
  var r = uie(e) ? aie : sie
  return n && cie(e, t, n) && (t = void 0), r(e, lie(t))
}
var die = fie
const Bk = Pe(die)
function Rl(e) {
  "@babel/helpers - typeof"
  return (
    (Rl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Rl(e)
  )
}
var pie = ["x", "y"]
function cg() {
  return (
    (cg = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    cg.apply(this, arguments)
  )
}
function iP(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function ds(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? iP(Object(n), !0).forEach(function (r) {
          hie(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : iP(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function hie(e, t, n) {
  return (
    (t = mie(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function mie(e) {
  var t = vie(e, "string")
  return Rl(t) === "symbol" ? t : String(t)
}
function vie(e, t) {
  if (Rl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Rl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function gie(e, t) {
  if (e == null) return {}
  var n = yie(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function yie(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function bie(e, t) {
  var n = e.x,
    r = e.y,
    i = gie(e, pie),
    o = "".concat(n),
    a = parseInt(o, 10),
    s = "".concat(r),
    l = parseInt(s, 10),
    u = "".concat(t.height || i.height),
    f = parseInt(u, 10),
    c = "".concat(t.width || i.width),
    d = parseInt(c, 10)
  return ds(
    ds(ds(ds(ds({}, t), i), a ? { x: a } : {}), l ? { y: l } : {}),
    {},
    { height: f, width: d, name: t.name, radius: t.radius }
  )
}
function oP(e) {
  return E.createElement(
    nre,
    cg(
      {
        shapeType: "rectangle",
        propTransformer: bie,
        activeClassName: "recharts-active-bar"
      },
      e
    )
  )
}
var xie = ["value", "background"]
function ya(e) {
  "@babel/helpers - typeof"
  return (
    (ya =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    ya(e)
  )
}
function wie(e, t) {
  if (e == null) return {}
  var n = Sie(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function Sie(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function Qf() {
  return (
    (Qf = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Qf.apply(this, arguments)
  )
}
function aP(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function st(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? aP(Object(n), !0).forEach(function (r) {
          Yr(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : aP(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Oie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function sP(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, Fk(r.key), r)
  }
}
function Pie(e, t, n) {
  return (
    t && sP(e.prototype, t),
    n && sP(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function $ie(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 }
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && fg(e, t)
}
function fg(e, t) {
  return (
    (fg = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r
        }),
    fg(e, t)
  )
}
function Aie(e) {
  var t = Eie()
  return function () {
    var r = Zf(e),
      i
    if (t) {
      var o = Zf(this).constructor
      i = Reflect.construct(r, arguments, o)
    } else i = r.apply(this, arguments)
    return Tie(this, i)
  }
}
function Tie(e, t) {
  if (t && (ya(t) === "object" || typeof t == "function")) return t
  if (t !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return xs(e)
}
function xs(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return e
}
function Eie() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function Zf(e) {
  return (
    (Zf = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n)
        }),
    Zf(e)
  )
}
function Yr(e, t, n) {
  return (
    (t = Fk(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Fk(e) {
  var t = Cie(e, "string")
  return ya(t) === "symbol" ? t : String(t)
}
function Cie(e, t) {
  if (ya(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (ya(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var Va = (function (e) {
  $ie(n, e)
  var t = Aie(n)
  function n() {
    var r
    Oie(this, n)
    for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a]
    return (
      (r = t.call.apply(t, [this].concat(o))),
      Yr(xs(r), "state", { isAnimationFinished: !1 }),
      Yr(xs(r), "id", Kd("recharts-bar-")),
      Yr(xs(r), "handleAnimationEnd", function () {
        var s = r.props.onAnimationEnd
        r.setState({ isAnimationFinished: !0 }), s && s()
      }),
      Yr(xs(r), "handleAnimationStart", function () {
        var s = r.props.onAnimationStart
        r.setState({ isAnimationFinished: !1 }), s && s()
      }),
      r
    )
  }
  return (
    Pie(
      n,
      [
        {
          key: "renderRectanglesStatically",
          value: function (i) {
            var o = this,
              a = this.props,
              s = a.shape,
              l = a.dataKey,
              u = a.activeIndex,
              f = a.activeBar,
              c = he(this.props)
            return (
              i &&
              i.map(function (d, p) {
                var h = p === u,
                  m = h ? f : s,
                  b = st(
                    st(st({}, c), d),
                    {},
                    {
                      isActive: h,
                      option: m,
                      index: p,
                      dataKey: l,
                      onAnimationStart: o.handleAnimationStart,
                      onAnimationEnd: o.handleAnimationEnd
                    }
                  )
                return E.createElement(
                  ct,
                  Qf(
                    { className: "recharts-bar-rectangle" },
                    ff(o.props, d, p),
                    {
                      key: "rectangle-"
                        .concat(d == null ? void 0 : d.x, "-")
                        .concat(d == null ? void 0 : d.y, "-")
                        .concat(d == null ? void 0 : d.value)
                    }
                  ),
                  E.createElement(oP, b)
                )
              })
            )
          }
        },
        {
          key: "renderRectanglesWithAnimation",
          value: function () {
            var i = this,
              o = this.props,
              a = o.data,
              s = o.layout,
              l = o.isAnimationActive,
              u = o.animationBegin,
              f = o.animationDuration,
              c = o.animationEasing,
              d = o.animationId,
              p = this.state.prevData
            return E.createElement(
              pi,
              {
                begin: u,
                duration: f,
                isActive: l,
                easing: c,
                from: { t: 0 },
                to: { t: 1 },
                key: "bar-".concat(d),
                onAnimationEnd: this.handleAnimationEnd,
                onAnimationStart: this.handleAnimationStart
              },
              function (h) {
                var m = h.t,
                  b = a.map(function (g, v) {
                    var y = p && p[v]
                    if (y) {
                      var w = vo(y.x, g.x),
                        x = vo(y.y, g.y),
                        S = vo(y.width, g.width),
                        O = vo(y.height, g.height)
                      return st(
                        st({}, g),
                        {},
                        { x: w(m), y: x(m), width: S(m), height: O(m) }
                      )
                    }
                    if (s === "horizontal") {
                      var $ = vo(0, g.height),
                        A = $(m)
                      return st(
                        st({}, g),
                        {},
                        { y: g.y + g.height - A, height: A }
                      )
                    }
                    var C = vo(0, g.width),
                      T = C(m)
                    return st(st({}, g), {}, { width: T })
                  })
                return E.createElement(
                  ct,
                  null,
                  i.renderRectanglesStatically(b)
                )
              }
            )
          }
        },
        {
          key: "renderRectangles",
          value: function () {
            var i = this.props,
              o = i.data,
              a = i.isAnimationActive,
              s = this.state.prevData
            return a && o && o.length && (!s || !z0(s, o))
              ? this.renderRectanglesWithAnimation()
              : this.renderRectanglesStatically(o)
          }
        },
        {
          key: "renderBackground",
          value: function () {
            var i = this,
              o = this.props,
              a = o.data,
              s = o.dataKey,
              l = o.activeIndex,
              u = he(this.props.background)
            return a.map(function (f, c) {
              f.value
              var d = f.background,
                p = wie(f, xie)
              if (!d) return null
              var h = st(
                st(
                  st(st(st({}, p), {}, { fill: "#eee" }, d), u),
                  ff(i.props, f, c)
                ),
                {},
                {
                  onAnimationStart: i.handleAnimationStart,
                  onAnimationEnd: i.handleAnimationEnd,
                  dataKey: s,
                  index: c,
                  key: "background-bar-".concat(c),
                  className: "recharts-bar-background-rectangle"
                }
              )
              return E.createElement(
                oP,
                Qf({ option: i.props.background, isActive: c === l }, h)
              )
            })
          }
        },
        {
          key: "renderErrorBar",
          value: function (i, o) {
            if (this.props.isAnimationActive && !this.state.isAnimationFinished)
              return null
            var a = this.props,
              s = a.data,
              l = a.xAxis,
              u = a.yAxis,
              f = a.layout,
              c = a.children,
              d = jn(c, dp)
            if (!d) return null
            var p = f === "vertical" ? s[0].height / 2 : s[0].width / 2,
              h = function (g, v) {
                var y = Array.isArray(g.value) ? g.value[1] : g.value
                return { x: g.x, y: g.y, value: y, errorVal: Yn(g, v) }
              },
              m = { clipPath: i ? "url(#clipPath-".concat(o, ")") : null }
            return E.createElement(
              ct,
              m,
              d.map(function (b) {
                return E.cloneElement(b, {
                  key: "error-bar-".concat(o, "-").concat(b.props.dataKey),
                  data: s,
                  xAxis: l,
                  yAxis: u,
                  layout: f,
                  offset: p,
                  dataPointFormatter: h
                })
              })
            )
          }
        },
        {
          key: "render",
          value: function () {
            var i = this.props,
              o = i.hide,
              a = i.data,
              s = i.className,
              l = i.xAxis,
              u = i.yAxis,
              f = i.left,
              c = i.top,
              d = i.width,
              p = i.height,
              h = i.isAnimationActive,
              m = i.background,
              b = i.id
            if (o || !a || !a.length) return null
            var g = this.state.isAnimationFinished,
              v = Oe("recharts-bar", s),
              y = l && l.allowDataOverflow,
              w = u && u.allowDataOverflow,
              x = y || w,
              S = xe(b) ? this.id : b
            return E.createElement(
              ct,
              { className: v },
              y || w
                ? E.createElement(
                    "defs",
                    null,
                    E.createElement(
                      "clipPath",
                      { id: "clipPath-".concat(S) },
                      E.createElement("rect", {
                        x: y ? f : f - d / 2,
                        y: w ? c : c - p / 2,
                        width: y ? d : d * 2,
                        height: w ? p : p * 2
                      })
                    )
                  )
                : null,
              E.createElement(
                ct,
                {
                  className: "recharts-bar-rectangles",
                  clipPath: x ? "url(#clipPath-".concat(S, ")") : null
                },
                m ? this.renderBackground() : null,
                this.renderRectangles()
              ),
              this.renderErrorBar(x, S),
              (!h || g) && Xi.renderCallByParent(this.props, a)
            )
          }
        }
      ],
      [
        {
          key: "getDerivedStateFromProps",
          value: function (i, o) {
            return i.animationId !== o.prevAnimationId
              ? {
                  prevAnimationId: i.animationId,
                  curData: i.data,
                  prevData: o.curData
                }
              : i.data !== o.curData
                ? { curData: i.data }
                : null
          }
        }
      ]
    ),
    n
  )
})(P.PureComponent)
Yr(Va, "displayName", "Bar")
Yr(Va, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  legendType: "rect",
  minPointSize: 0,
  hide: !1,
  data: [],
  layout: "vertical",
  activeBar: !0,
  isAnimationActive: !si.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease"
})
Yr(Va, "getComposedData", function (e) {
  var t = e.props,
    n = e.item,
    r = e.barPosition,
    i = e.bandSize,
    o = e.xAxis,
    a = e.yAxis,
    s = e.xAxisTicks,
    l = e.yAxisTicks,
    u = e.stackedData,
    f = e.dataStartIndex,
    c = e.displayedData,
    d = e.offset,
    p = Fee(r, n)
  if (!p) return null
  var h = t.layout,
    m = n.props,
    b = m.dataKey,
    g = m.children,
    v = m.minPointSize,
    y = h === "horizontal" ? a : o,
    w = u ? y.scale.domain() : null,
    x = qee({ numericAxis: y }),
    S = jn(g, E_),
    O = c.map(function ($, A) {
      var C, T, _, R, M, D
      if (
        (u
          ? (C = Vee(u[f + A], w))
          : ((C = Yn($, b)), Array.isArray(C) || (C = [x, C])),
        h === "horizontal")
      ) {
        var N,
          L = [a.scale(C[0]), a.scale(C[1])],
          k = L[0],
          I = L[1]
        ;(T = OO({
          axis: o,
          ticks: s,
          bandSize: i,
          offset: p.offset,
          entry: $,
          index: A
        })),
          (_ = (N = I ?? k) !== null && N !== void 0 ? N : void 0),
          (R = p.size)
        var V = k - I
        if (
          ((M = Number.isNaN(V) ? 0 : V),
          (D = { x: T, y: a.y, width: R, height: a.height }),
          Math.abs(v) > 0 && Math.abs(M) < Math.abs(v))
        ) {
          var U = _n(M || v) * (Math.abs(v) - Math.abs(M))
          ;(_ -= U), (M += U)
        }
      } else {
        var H = [o.scale(C[0]), o.scale(C[1])],
          ee = H[0],
          X = H[1]
        if (
          ((T = ee),
          (_ = OO({
            axis: a,
            ticks: l,
            bandSize: i,
            offset: p.offset,
            entry: $,
            index: A
          })),
          (R = X - ee),
          (M = p.size),
          (D = { x: o.x, y: _, width: o.width, height: M }),
          Math.abs(v) > 0 && Math.abs(R) < Math.abs(v))
        ) {
          var de = _n(R || v) * (Math.abs(v) - Math.abs(R))
          R += de
        }
      }
      return st(
        st(
          st({}, $),
          {},
          {
            x: T,
            y: _,
            width: R,
            height: M,
            value: u ? C : C[1],
            payload: $,
            background: D
          },
          S && S[A] && S[A].props
        ),
        {},
        {
          tooltipPayload: [_k(n, $)],
          tooltipPosition: { x: T + R / 2, y: _ + M / 2 }
        }
      )
    })
  return st({ data: O, layout: h }, d)
})
function Ll(e) {
  "@babel/helpers - typeof"
  return (
    (Ll =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Ll(e)
  )
}
function _ie(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function lP(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, Vk(r.key), r)
  }
}
function kie(e, t, n) {
  return (
    t && lP(e.prototype, t),
    n && lP(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function uP(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Tn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? uP(Object(n), !0).forEach(function (r) {
          mp(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : uP(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function mp(e, t, n) {
  return (
    (t = Vk(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Vk(e) {
  var t = Mie(e, "string")
  return Ll(t) === "symbol" ? t : String(t)
}
function Mie(e, t) {
  if (Ll(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Ll(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var jie = function (t, n, r, i, o) {
    var a = t.width,
      s = t.height,
      l = t.layout,
      u = t.children,
      f = Object.keys(n),
      c = {
        left: r.left,
        leftMirror: r.left,
        right: a - r.right,
        rightMirror: a - r.right,
        top: r.top,
        topMirror: r.top,
        bottom: s - r.bottom,
        bottomMirror: s - r.bottom
      },
      d = !!ur(u, Va)
    return f.reduce(function (p, h) {
      var m = n[h],
        b = m.orientation,
        g = m.domain,
        v = m.padding,
        y = v === void 0 ? {} : v,
        w = m.mirror,
        x = m.reversed,
        S = "".concat(b).concat(w ? "Mirror" : ""),
        O,
        $,
        A,
        C,
        T
      if (
        m.type === "number" &&
        (m.padding === "gap" || m.padding === "no-gap")
      ) {
        var _ = g[1] - g[0],
          R = 1 / 0,
          M = m.categoricalDomain.sort()
        M.forEach(function (X, de) {
          de > 0 && (R = Math.min((X || 0) - (M[de - 1] || 0), R))
        })
        var D = R / _,
          N = m.layout === "vertical" ? r.height : r.width
        if (
          (m.padding === "gap" && (O = (D * N) / 2), m.padding === "no-gap")
        ) {
          var L = aa(t.barCategoryGap, D * N),
            k = (D * N) / 2
          O = k - L - ((k - L) / N) * L
        }
      }
      i === "xAxis"
        ? ($ = [
            r.left + (y.left || 0) + (O || 0),
            r.left + r.width - (y.right || 0) - (O || 0)
          ])
        : i === "yAxis"
          ? ($ =
              l === "horizontal"
                ? [r.top + r.height - (y.bottom || 0), r.top + (y.top || 0)]
                : [
                    r.top + (y.top || 0) + (O || 0),
                    r.top + r.height - (y.bottom || 0) - (O || 0)
                  ])
          : ($ = m.range),
        x && ($ = [$[1], $[0]])
      var I = Lee(m, o, d),
        V = I.scale,
        U = I.realScaleType
      V.domain(g).range($), Bee(V)
      var H = Kee(V, Tn(Tn({}, m), {}, { realScaleType: U }))
      i === "xAxis"
        ? ((T = (b === "top" && !w) || (b === "bottom" && w)),
          (A = r.left),
          (C = c[S] - T * m.height))
        : i === "yAxis" &&
          ((T = (b === "left" && !w) || (b === "right" && w)),
          (A = c[S] - T * m.width),
          (C = r.top))
      var ee = Tn(
        Tn(Tn({}, m), H),
        {},
        {
          realScaleType: U,
          x: A,
          y: C,
          scale: V,
          width: i === "xAxis" ? r.width : m.width,
          height: i === "yAxis" ? r.height : m.height
        }
      )
      return (
        (ee.bandSize = zf(ee, H)),
        !m.hide && i === "xAxis"
          ? (c[S] += (T ? -1 : 1) * ee.height)
          : m.hide || (c[S] += (T ? -1 : 1) * ee.width),
        Tn(Tn({}, p), {}, mp({}, h, ee))
      )
    }, {})
  },
  zk = function (t, n) {
    var r = t.x,
      i = t.y,
      o = n.x,
      a = n.y
    return {
      x: Math.min(r, o),
      y: Math.min(i, a),
      width: Math.abs(o - r),
      height: Math.abs(a - i)
    }
  },
  Die = function (t) {
    var n = t.x1,
      r = t.y1,
      i = t.x2,
      o = t.y2
    return zk({ x: n, y: r }, { x: i, y: o })
  },
  Uk = (function () {
    function e(t) {
      _ie(this, e), (this.scale = t)
    }
    return (
      kie(
        e,
        [
          {
            key: "domain",
            get: function () {
              return this.scale.domain
            }
          },
          {
            key: "range",
            get: function () {
              return this.scale.range
            }
          },
          {
            key: "rangeMin",
            get: function () {
              return this.range()[0]
            }
          },
          {
            key: "rangeMax",
            get: function () {
              return this.range()[1]
            }
          },
          {
            key: "bandwidth",
            get: function () {
              return this.scale.bandwidth
            }
          },
          {
            key: "apply",
            value: function (n) {
              var r =
                  arguments.length > 1 && arguments[1] !== void 0
                    ? arguments[1]
                    : {},
                i = r.bandAware,
                o = r.position
              if (n !== void 0) {
                if (o)
                  switch (o) {
                    case "start":
                      return this.scale(n)
                    case "middle": {
                      var a = this.bandwidth ? this.bandwidth() / 2 : 0
                      return this.scale(n) + a
                    }
                    case "end": {
                      var s = this.bandwidth ? this.bandwidth() : 0
                      return this.scale(n) + s
                    }
                    default:
                      return this.scale(n)
                  }
                if (i) {
                  var l = this.bandwidth ? this.bandwidth() / 2 : 0
                  return this.scale(n) + l
                }
                return this.scale(n)
              }
            }
          },
          {
            key: "isInRange",
            value: function (n) {
              var r = this.range(),
                i = r[0],
                o = r[r.length - 1]
              return i <= o ? n >= i && n <= o : n >= o && n <= i
            }
          }
        ],
        [
          {
            key: "create",
            value: function (n) {
              return new e(n)
            }
          }
        ]
      ),
      e
    )
  })()
mp(Uk, "EPS", 1e-4)
var K0 = function (t) {
  var n = Object.keys(t).reduce(function (r, i) {
    return Tn(Tn({}, r), {}, mp({}, i, Uk.create(t[i])))
  }, {})
  return Tn(
    Tn({}, n),
    {},
    {
      apply: function (i) {
        var o =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
          a = o.bandAware,
          s = o.position
        return eie(i, function (l, u) {
          return n[u].apply(l, { bandAware: a, position: s })
        })
      },
      isInRange: function (i) {
        return Bk(i, function (o, a) {
          return n[a].isInRange(o)
        })
      }
    }
  )
}
function Iie(e) {
  return ((e % 180) + 180) % 180
}
var Nie = function (t) {
  var n = t.width,
    r = t.height,
    i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    o = Iie(i),
    a = (o * Math.PI) / 180,
    s = Math.atan(r / n),
    l = a > s && a < Math.PI - s ? r / Math.sin(a) : n / Math.cos(a)
  return Math.abs(l)
}
function Bl(e) {
  "@babel/helpers - typeof"
  return (
    (Bl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Bl(e)
  )
}
function cP(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function fP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? cP(Object(n), !0).forEach(function (r) {
          Rie(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : cP(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Rie(e, t, n) {
  return (
    (t = Lie(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Lie(e) {
  var t = Bie(e, "string")
  return Bl(t) === "symbol" ? t : String(t)
}
function Bie(e, t) {
  if (Bl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Bl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function Fie(e, t) {
  return Wie(e) || Uie(e, t) || zie(e, t) || Vie()
}
function Vie() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function zie(e, t) {
  if (e) {
    if (typeof e == "string") return dP(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return dP(e, t)
  }
}
function dP(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function Uie(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function Wie(e) {
  if (Array.isArray(e)) return e
}
function dg() {
  return (
    (dg = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    dg.apply(this, arguments)
  )
}
var Hie = function (t, n) {
    var r
    return (
      E.isValidElement(t)
        ? (r = E.cloneElement(t, n))
        : ce(t)
          ? (r = t(n))
          : (r = E.createElement(
              "line",
              dg({}, n, { className: "recharts-reference-line-line" })
            )),
      r
    )
  },
  Gie = function (t, n, r, i, o) {
    var a = o.viewBox,
      s = a.x,
      l = a.y,
      u = a.width,
      f = a.height,
      c = o.position
    if (r) {
      var d = o.y,
        p = o.yAxis.orientation,
        h = t.y.apply(d, { position: c })
      if (qn(o, "discard") && !t.y.isInRange(h)) return null
      var m = [
        { x: s + u, y: h },
        { x: s, y: h }
      ]
      return p === "left" ? m.reverse() : m
    }
    if (n) {
      var b = o.x,
        g = o.xAxis.orientation,
        v = t.x.apply(b, { position: c })
      if (qn(o, "discard") && !t.x.isInRange(v)) return null
      var y = [
        { x: v, y: l + f },
        { x: v, y: l }
      ]
      return g === "top" ? y.reverse() : y
    }
    if (i) {
      var w = o.segment,
        x = w.map(function (S) {
          return t.apply(S, { position: c })
        })
      return qn(o, "discard") &&
        Gre(x, function (S) {
          return !t.isInRange(S)
        })
        ? null
        : x
    }
    return null
  }
function q0(e) {
  var t = e.x,
    n = e.y,
    r = e.segment,
    i = e.xAxis,
    o = e.yAxis,
    a = e.shape,
    s = e.className,
    l = e.alwaysShow,
    u = e.clipPathId
  qd(
    l === void 0,
    'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'
  )
  var f = K0({ x: i.scale, y: o.scale }),
    c = it(t),
    d = it(n),
    p = r && r.length === 2,
    h = Gie(f, c, d, p, e)
  if (!h) return null
  var m = Fie(h, 2),
    b = m[0],
    g = b.x,
    v = b.y,
    y = m[1],
    w = y.x,
    x = y.y,
    S = qn(e, "hidden") ? "url(#".concat(u, ")") : void 0,
    O = fP(fP({ clipPath: S }, he(e, !0)), {}, { x1: g, y1: v, x2: w, y2: x })
  return E.createElement(
    ct,
    { className: Oe("recharts-reference-line", s) },
    Hie(a, O),
    At.renderCallByParent(e, Die({ x1: g, y1: v, x2: w, y2: x }))
  )
}
q0.displayName = "ReferenceLine"
q0.defaultProps = {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  fill: "none",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1,
  position: "middle"
}
function Fl(e) {
  "@babel/helpers - typeof"
  return (
    (Fl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Fl(e)
  )
}
function pg() {
  return (
    (pg = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    pg.apply(this, arguments)
  )
}
function pP(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function hP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? pP(Object(n), !0).forEach(function (r) {
          Kie(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : pP(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Kie(e, t, n) {
  return (
    (t = qie(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function qie(e) {
  var t = Xie(e, "string")
  return Fl(t) === "symbol" ? t : String(t)
}
function Xie(e, t) {
  if (Fl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Fl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var Yie = function (t) {
  var n = t.x,
    r = t.y,
    i = t.xAxis,
    o = t.yAxis,
    a = K0({ x: i.scale, y: o.scale }),
    s = a.apply({ x: n, y: r }, { bandAware: !0 })
  return qn(t, "discard") && !a.isInRange(s) ? null : s
}
function fu(e) {
  var t = e.x,
    n = e.y,
    r = e.r,
    i = e.alwaysShow,
    o = e.clipPathId,
    a = it(t),
    s = it(n)
  if (
    (qd(
      i === void 0,
      'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'
    ),
    !a || !s)
  )
    return null
  var l = Yie(e)
  if (!l) return null
  var u = l.x,
    f = l.y,
    c = e.shape,
    d = e.className,
    p = qn(e, "hidden") ? "url(#".concat(o, ")") : void 0,
    h = hP(hP({ clipPath: p }, he(e, !0)), {}, { cx: u, cy: f })
  return E.createElement(
    ct,
    { className: Oe("recharts-reference-dot", d) },
    fu.renderDot(c, h),
    At.renderCallByParent(e, {
      x: u - r,
      y: f - r,
      width: 2 * r,
      height: 2 * r
    })
  )
}
fu.displayName = "ReferenceDot"
fu.defaultProps = {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#fff",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1
}
fu.renderDot = function (e, t) {
  var n
  return (
    E.isValidElement(e)
      ? (n = E.cloneElement(e, t))
      : ce(e)
        ? (n = e(t))
        : (n = E.createElement(
            Dk,
            pg({}, t, {
              cx: t.cx,
              cy: t.cy,
              className: "recharts-reference-dot-dot"
            })
          )),
    n
  )
}
function Vl(e) {
  "@babel/helpers - typeof"
  return (
    (Vl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Vl(e)
  )
}
function hg() {
  return (
    (hg = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    hg.apply(this, arguments)
  )
}
function mP(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function vP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? mP(Object(n), !0).forEach(function (r) {
          Qie(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : mP(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Qie(e, t, n) {
  return (
    (t = Zie(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Zie(e) {
  var t = Jie(e, "string")
  return Vl(t) === "symbol" ? t : String(t)
}
function Jie(e, t) {
  if (Vl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Vl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var eoe = function (t, n, r, i, o) {
  var a = o.x1,
    s = o.x2,
    l = o.y1,
    u = o.y2,
    f = o.xAxis,
    c = o.yAxis
  if (!f || !c) return null
  var d = K0({ x: f.scale, y: c.scale }),
    p = {
      x: t ? d.x.apply(a, { position: "start" }) : d.x.rangeMin,
      y: r ? d.y.apply(l, { position: "start" }) : d.y.rangeMin
    },
    h = {
      x: n ? d.x.apply(s, { position: "end" }) : d.x.rangeMax,
      y: i ? d.y.apply(u, { position: "end" }) : d.y.rangeMax
    }
  return qn(o, "discard") && (!d.isInRange(p) || !d.isInRange(h))
    ? null
    : zk(p, h)
}
function du(e) {
  var t = e.x1,
    n = e.x2,
    r = e.y1,
    i = e.y2,
    o = e.className,
    a = e.alwaysShow,
    s = e.clipPathId
  qd(
    a === void 0,
    'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'
  )
  var l = it(t),
    u = it(n),
    f = it(r),
    c = it(i),
    d = e.shape
  if (!l && !u && !f && !c && !d) return null
  var p = eoe(l, u, f, c, e)
  if (!p && !d) return null
  var h = qn(e, "hidden") ? "url(#".concat(s, ")") : void 0
  return E.createElement(
    ct,
    { className: Oe("recharts-reference-area", o) },
    du.renderRect(d, vP(vP({ clipPath: h }, he(e, !0)), p)),
    At.renderCallByParent(e, p)
  )
}
du.displayName = "ReferenceArea"
du.defaultProps = {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#ccc",
  fillOpacity: 0.5,
  stroke: "none",
  strokeWidth: 1
}
du.renderRect = function (e, t) {
  var n
  return (
    E.isValidElement(e)
      ? (n = E.cloneElement(e, t))
      : ce(e)
        ? (n = e(t))
        : (n = E.createElement(
            G0,
            hg({}, t, { className: "recharts-reference-area-rect" })
          )),
    n
  )
}
function Wk(e, t, n) {
  if (t < 1) return []
  if (t === 1 && n === void 0) return e
  for (var r = [], i = 0; i < e.length; i += t)
    if (n === void 0 || n(e[i]) === !0) r.push(e[i])
    else return
  return r
}
function toe(e, t, n) {
  var r = { width: e.width + t.width, height: e.height + t.height }
  return Nie(r, n)
}
function noe(e, t, n) {
  var r = n === "width",
    i = e.x,
    o = e.y,
    a = e.width,
    s = e.height
  return t === 1
    ? { start: r ? i : o, end: r ? i + a : o + s }
    : { start: r ? i + a : o + s, end: r ? i : o }
}
function Jf(e, t, n, r, i) {
  if (e * t < e * r || e * t > e * i) return !1
  var o = n()
  return e * (t - (e * o) / 2 - r) >= 0 && e * (t + (e * o) / 2 - i) <= 0
}
function roe(e, t) {
  return Wk(e, t + 1)
}
function ioe(e, t, n, r, i) {
  for (
    var o = (r || []).slice(),
      a = t.start,
      s = t.end,
      l = 0,
      u = 1,
      f = a,
      c = function () {
        var h = r == null ? void 0 : r[l]
        if (h === void 0) return { v: Wk(r, u) }
        var m = l,
          b,
          g = function () {
            return b === void 0 && (b = n(h, m)), b
          },
          v = h.coordinate,
          y = l === 0 || Jf(e, v, g, f, s)
        y || ((l = 0), (f = a), (u += 1)),
          y && ((f = v + e * (g() / 2 + i)), (l += u))
      },
      d;
    u <= o.length;

  )
    if (((d = c()), d)) return d.v
  return []
}
function zl(e) {
  "@babel/helpers - typeof"
  return (
    (zl =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    zl(e)
  )
}
function gP(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Pt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? gP(Object(n), !0).forEach(function (r) {
          ooe(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : gP(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function ooe(e, t, n) {
  return (
    (t = aoe(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function aoe(e) {
  var t = soe(e, "string")
  return zl(t) === "symbol" ? t : String(t)
}
function soe(e, t) {
  if (zl(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (zl(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
function loe(e, t, n, r, i) {
  for (
    var o = (r || []).slice(),
      a = o.length,
      s = t.start,
      l = t.end,
      u = function (d) {
        var p = o[d],
          h,
          m = function () {
            return h === void 0 && (h = n(p, d)), h
          }
        if (d === a - 1) {
          var b = e * (p.coordinate + (e * m()) / 2 - l)
          o[d] = p = Pt(
            Pt({}, p),
            {},
            { tickCoord: b > 0 ? p.coordinate - b * e : p.coordinate }
          )
        } else o[d] = p = Pt(Pt({}, p), {}, { tickCoord: p.coordinate })
        var g = Jf(e, p.tickCoord, m, s, l)
        g &&
          ((l = p.tickCoord - e * (m() / 2 + i)),
          (o[d] = Pt(Pt({}, p), {}, { isShow: !0 })))
      },
      f = a - 1;
    f >= 0;
    f--
  )
    u(f)
  return o
}
function uoe(e, t, n, r, i, o) {
  var a = (r || []).slice(),
    s = a.length,
    l = t.start,
    u = t.end
  if (o) {
    var f = r[s - 1],
      c = n(f, s - 1),
      d = e * (f.coordinate + (e * c) / 2 - u)
    a[s - 1] = f = Pt(
      Pt({}, f),
      {},
      { tickCoord: d > 0 ? f.coordinate - d * e : f.coordinate }
    )
    var p = Jf(
      e,
      f.tickCoord,
      function () {
        return c
      },
      l,
      u
    )
    p &&
      ((u = f.tickCoord - e * (c / 2 + i)),
      (a[s - 1] = Pt(Pt({}, f), {}, { isShow: !0 })))
  }
  for (
    var h = o ? s - 1 : s,
      m = function (v) {
        var y = a[v],
          w,
          x = function () {
            return w === void 0 && (w = n(y, v)), w
          }
        if (v === 0) {
          var S = e * (y.coordinate - (e * x()) / 2 - l)
          a[v] = y = Pt(
            Pt({}, y),
            {},
            { tickCoord: S < 0 ? y.coordinate - S * e : y.coordinate }
          )
        } else a[v] = y = Pt(Pt({}, y), {}, { tickCoord: y.coordinate })
        var O = Jf(e, y.tickCoord, x, l, u)
        O &&
          ((l = y.tickCoord + e * (x() / 2 + i)),
          (a[v] = Pt(Pt({}, y), {}, { isShow: !0 })))
      },
      b = 0;
    b < h;
    b++
  )
    m(b)
  return a
}
function mg(e, t, n) {
  var r = e.tick,
    i = e.ticks,
    o = e.viewBox,
    a = e.minTickGap,
    s = e.orientation,
    l = e.interval,
    u = e.tickFormatter,
    f = e.unit,
    c = e.angle
  if (!i || !i.length || !r) return []
  if (G(l) || si.isSsr) return roe(i, typeof l == "number" && G(l) ? l : 0)
  var d = [],
    p = s === "top" || s === "bottom" ? "width" : "height",
    h =
      f && p === "width"
        ? Is(f, { fontSize: t, letterSpacing: n })
        : { width: 0, height: 0 },
    m = function (y, w) {
      var x = ce(u) ? u(y.value, w) : y.value
      return p === "width"
        ? toe(Is(x, { fontSize: t, letterSpacing: n }), h, c)
        : Is(x, { fontSize: t, letterSpacing: n })[p]
    },
    b = i.length >= 2 ? _n(i[1].coordinate - i[0].coordinate) : 1,
    g = noe(o, b, p)
  return l === "equidistantPreserveStart"
    ? ioe(b, g, m, i, a)
    : (l === "preserveStart" || l === "preserveStartEnd"
        ? (d = uoe(b, g, m, i, a, l === "preserveStartEnd"))
        : (d = loe(b, g, m, i, a)),
      d.filter(function (v) {
        return v.isShow
      }))
}
var coe = ["viewBox"],
  foe = ["viewBox"],
  doe = ["ticks"]
function ba(e) {
  "@babel/helpers - typeof"
  return (
    (ba =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    ba(e)
  )
}
function No() {
  return (
    (No = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    No.apply(this, arguments)
  )
}
function yP(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function Et(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? yP(Object(n), !0).forEach(function (r) {
          X0(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : yP(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Wh(e, t) {
  if (e == null) return {}
  var n = poe(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function poe(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function hoe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function bP(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, Hk(r.key), r)
  }
}
function moe(e, t, n) {
  return (
    t && bP(e.prototype, t),
    n && bP(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function voe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 }
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && vg(e, t)
}
function vg(e, t) {
  return (
    (vg = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r
        }),
    vg(e, t)
  )
}
function goe(e) {
  var t = xoe()
  return function () {
    var r = ed(e),
      i
    if (t) {
      var o = ed(this).constructor
      i = Reflect.construct(r, arguments, o)
    } else i = r.apply(this, arguments)
    return yoe(this, i)
  }
}
function yoe(e, t) {
  if (t && (ba(t) === "object" || typeof t == "function")) return t
  if (t !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return boe(e)
}
function boe(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return e
}
function xoe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function ed(e) {
  return (
    (ed = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n)
        }),
    ed(e)
  )
}
function X0(e, t, n) {
  return (
    (t = Hk(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Hk(e) {
  var t = woe(e, "string")
  return ba(t) === "symbol" ? t : String(t)
}
function woe(e, t) {
  if (ba(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (ba(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var Ls = (function (e) {
  voe(n, e)
  var t = goe(n)
  function n(r) {
    var i
    return (
      hoe(this, n),
      (i = t.call(this, r)),
      (i.state = { fontSize: "", letterSpacing: "" }),
      i
    )
  }
  return (
    moe(
      n,
      [
        {
          key: "shouldComponentUpdate",
          value: function (i, o) {
            var a = i.viewBox,
              s = Wh(i, coe),
              l = this.props,
              u = l.viewBox,
              f = Wh(l, foe)
            return !Ho(a, u) || !Ho(s, f) || !Ho(o, this.state)
          }
        },
        {
          key: "componentDidMount",
          value: function () {
            var i = this.layerReference
            if (i) {
              var o = i.getElementsByClassName(
                "recharts-cartesian-axis-tick-value"
              )[0]
              o &&
                this.setState({
                  fontSize: window.getComputedStyle(o).fontSize,
                  letterSpacing: window.getComputedStyle(o).letterSpacing
                })
            }
          }
        },
        {
          key: "getTickLineCoord",
          value: function (i) {
            var o = this.props,
              a = o.x,
              s = o.y,
              l = o.width,
              u = o.height,
              f = o.orientation,
              c = o.tickSize,
              d = o.mirror,
              p = o.tickMargin,
              h,
              m,
              b,
              g,
              v,
              y,
              w = d ? -1 : 1,
              x = i.tickSize || c,
              S = G(i.tickCoord) ? i.tickCoord : i.coordinate
            switch (f) {
              case "top":
                ;(h = m = i.coordinate),
                  (g = s + +!d * u),
                  (b = g - w * x),
                  (y = b - w * p),
                  (v = S)
                break
              case "left":
                ;(b = g = i.coordinate),
                  (m = a + +!d * l),
                  (h = m - w * x),
                  (v = h - w * p),
                  (y = S)
                break
              case "right":
                ;(b = g = i.coordinate),
                  (m = a + +d * l),
                  (h = m + w * x),
                  (v = h + w * p),
                  (y = S)
                break
              default:
                ;(h = m = i.coordinate),
                  (g = s + +d * u),
                  (b = g + w * x),
                  (y = b + w * p),
                  (v = S)
                break
            }
            return { line: { x1: h, y1: b, x2: m, y2: g }, tick: { x: v, y } }
          }
        },
        {
          key: "getTickTextAnchor",
          value: function () {
            var i = this.props,
              o = i.orientation,
              a = i.mirror,
              s
            switch (o) {
              case "left":
                s = a ? "start" : "end"
                break
              case "right":
                s = a ? "end" : "start"
                break
              default:
                s = "middle"
                break
            }
            return s
          }
        },
        {
          key: "getTickVerticalAnchor",
          value: function () {
            var i = this.props,
              o = i.orientation,
              a = i.mirror,
              s = "end"
            switch (o) {
              case "left":
              case "right":
                s = "middle"
                break
              case "top":
                s = a ? "start" : "end"
                break
              default:
                s = a ? "end" : "start"
                break
            }
            return s
          }
        },
        {
          key: "renderAxisLine",
          value: function () {
            var i = this.props,
              o = i.x,
              a = i.y,
              s = i.width,
              l = i.height,
              u = i.orientation,
              f = i.mirror,
              c = i.axisLine,
              d = Et(Et(Et({}, he(this.props)), he(c)), {}, { fill: "none" })
            if (u === "top" || u === "bottom") {
              var p = +((u === "top" && !f) || (u === "bottom" && f))
              d = Et(
                Et({}, d),
                {},
                { x1: o, y1: a + p * l, x2: o + s, y2: a + p * l }
              )
            } else {
              var h = +((u === "left" && !f) || (u === "right" && f))
              d = Et(
                Et({}, d),
                {},
                { x1: o + h * s, y1: a, x2: o + h * s, y2: a + l }
              )
            }
            return E.createElement(
              "line",
              No({}, d, {
                className: Oe(
                  "recharts-cartesian-axis-line",
                  mn(c, "className")
                )
              })
            )
          }
        },
        {
          key: "renderTicks",
          value: function (i, o, a) {
            var s = this,
              l = this.props,
              u = l.tickLine,
              f = l.stroke,
              c = l.tick,
              d = l.tickFormatter,
              p = l.unit,
              h = mg(Et(Et({}, this.props), {}, { ticks: i }), o, a),
              m = this.getTickTextAnchor(),
              b = this.getTickVerticalAnchor(),
              g = he(this.props),
              v = he(c),
              y = Et(Et({}, g), {}, { fill: "none" }, he(u)),
              w = h.map(function (x, S) {
                var O = s.getTickLineCoord(x),
                  $ = O.line,
                  A = O.tick,
                  C = Et(
                    Et(
                      Et(
                        Et({ textAnchor: m, verticalAnchor: b }, g),
                        {},
                        { stroke: "none", fill: f },
                        v
                      ),
                      A
                    ),
                    {},
                    {
                      index: S,
                      payload: x,
                      visibleTicksCount: h.length,
                      tickFormatter: d
                    }
                  )
                return E.createElement(
                  ct,
                  No(
                    {
                      className: "recharts-cartesian-axis-tick",
                      key: "tick-"
                        .concat(x.value, "-")
                        .concat(x.coordinate, "-")
                        .concat(x.tickCoord)
                    },
                    ff(s.props, x, S)
                  ),
                  u &&
                    E.createElement(
                      "line",
                      No({}, y, $, {
                        className: Oe(
                          "recharts-cartesian-axis-tick-line",
                          mn(u, "className")
                        )
                      })
                    ),
                  c &&
                    n.renderTickItem(
                      c,
                      C,
                      "".concat(ce(d) ? d(x.value, S) : x.value).concat(p || "")
                    )
                )
              })
            return E.createElement(
              "g",
              { className: "recharts-cartesian-axis-ticks" },
              w
            )
          }
        },
        {
          key: "render",
          value: function () {
            var i = this,
              o = this.props,
              a = o.axisLine,
              s = o.width,
              l = o.height,
              u = o.ticksGenerator,
              f = o.className,
              c = o.hide
            if (c) return null
            var d = this.props,
              p = d.ticks,
              h = Wh(d, doe),
              m = p
            return (
              ce(u) && (m = p && p.length > 0 ? u(this.props) : u(h)),
              s <= 0 || l <= 0 || !m || !m.length
                ? null
                : E.createElement(
                    ct,
                    {
                      className: Oe("recharts-cartesian-axis", f),
                      ref: function (g) {
                        i.layerReference = g
                      }
                    },
                    a && this.renderAxisLine(),
                    this.renderTicks(
                      m,
                      this.state.fontSize,
                      this.state.letterSpacing
                    ),
                    At.renderCallByParent(this.props)
                  )
            )
          }
        }
      ],
      [
        {
          key: "renderTickItem",
          value: function (i, o, a) {
            var s
            return (
              E.isValidElement(i)
                ? (s = E.cloneElement(i, o))
                : ce(i)
                  ? (s = i(o))
                  : (s = E.createElement(
                      Cf,
                      No({}, o, {
                        className: "recharts-cartesian-axis-tick-value"
                      }),
                      a
                    )),
              s
            )
          }
        }
      ]
    ),
    n
  )
})(P.Component)
X0(Ls, "displayName", "CartesianAxis")
X0(Ls, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: { x: 0, y: 0, width: 0, height: 0 },
  orientation: "bottom",
  ticks: [],
  stroke: "#666",
  tickLine: !0,
  axisLine: !0,
  tick: !0,
  mirror: !1,
  minTickGap: 5,
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
})
var vp = function () {
  return null
}
vp.displayName = "XAxis"
vp.defaultProps = {
  allowDecimals: !0,
  hide: !1,
  orientation: "bottom",
  width: 0,
  height: 30,
  mirror: !1,
  xAxisId: 0,
  tickCount: 5,
  type: "category",
  padding: { left: 0, right: 0 },
  allowDataOverflow: !1,
  scale: "auto",
  reversed: !1,
  allowDuplicatedCategory: !0
}
var gp = function () {
  return null
}
gp.displayName = "YAxis"
gp.defaultProps = {
  allowDuplicatedCategory: !0,
  allowDecimals: !0,
  hide: !1,
  orientation: "left",
  width: 60,
  height: 0,
  mirror: !1,
  yAxisId: 0,
  tickCount: 5,
  type: "number",
  padding: { top: 0, bottom: 0 },
  allowDataOverflow: !1,
  scale: "auto",
  reversed: !1
}
var Soe = Si,
  Ooe = au,
  Poe = Jd
function $oe(e) {
  return function (t, n, r) {
    var i = Object(t)
    if (!Ooe(t)) {
      var o = Soe(n)
      ;(t = Poe(t)),
        (n = function (s) {
          return o(i[s], s, i)
        })
    }
    var a = e(t, n, r)
    return a > -1 ? i[o ? t[a] : a] : void 0
  }
}
var Aoe = $oe,
  Toe = Nk
function Eoe(e) {
  var t = Toe(e),
    n = t % 1
  return t === t ? (n ? t - n : t) : 0
}
var Coe = Eoe,
  _oe = a_,
  koe = Si,
  Moe = Coe,
  joe = Math.max
function Doe(e, t, n) {
  var r = e == null ? 0 : e.length
  if (!r) return -1
  var i = n == null ? 0 : Moe(n)
  return i < 0 && (i = joe(r + i, 0)), _oe(e, koe(t), i)
}
var Ioe = Doe,
  Noe = Aoe,
  Roe = Ioe,
  Loe = Noe(Roe),
  Boe = Loe
const Foe = Pe(Boe)
var Voe = "Invariant failed"
function zoe(e, t) {
  if (!e) throw new Error(Voe)
}
function Gk(e) {
  var t = e.cx,
    n = e.cy,
    r = e.radius,
    i = e.startAngle,
    o = e.endAngle,
    a = yt(t, n, r, i),
    s = yt(t, n, r, o)
  return { points: [a, s], cx: t, cy: n, radius: r, startAngle: i, endAngle: o }
}
function xP(e) {
  return Goe(e) || Hoe(e) || Woe(e) || Uoe()
}
function Uoe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Woe(e, t) {
  if (e) {
    if (typeof e == "string") return gg(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return gg(e, t)
  }
}
function Hoe(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function Goe(e) {
  if (Array.isArray(e)) return gg(e)
}
function gg(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
var yg = function (t, n, r, i, o) {
    var a = jn(t, q0),
      s = jn(t, fu),
      l = [].concat(xP(a), xP(s)),
      u = jn(t, du),
      f = "".concat(i, "Id"),
      c = i[0],
      d = n
    if (
      (l.length &&
        (d = l.reduce(function (m, b) {
          if (
            b.props[f] === r &&
            qn(b.props, "extendDomain") &&
            G(b.props[c])
          ) {
            var g = b.props[c]
            return [Math.min(m[0], g), Math.max(m[1], g)]
          }
          return m
        }, d)),
      u.length)
    ) {
      var p = "".concat(c, "1"),
        h = "".concat(c, "2")
      d = u.reduce(function (m, b) {
        if (
          b.props[f] === r &&
          qn(b.props, "extendDomain") &&
          G(b.props[p]) &&
          G(b.props[h])
        ) {
          var g = b.props[p],
            v = b.props[h]
          return [Math.min(m[0], g, v), Math.max(m[1], g, v)]
        }
        return m
      }, d)
    }
    return (
      o &&
        o.length &&
        (d = o.reduce(function (m, b) {
          return G(b) ? [Math.min(m[0], b), Math.max(m[1], b)] : m
        }, d)),
      d
    )
  },
  Kk = { exports: {} }
;(function (e) {
  var t = Object.prototype.hasOwnProperty,
    n = "~"
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1))
  function i(l, u, f) {
    ;(this.fn = l), (this.context = u), (this.once = f || !1)
  }
  function o(l, u, f, c, d) {
    if (typeof f != "function")
      throw new TypeError("The listener must be a function")
    var p = new i(f, c || l, d),
      h = n ? n + u : u
    return (
      l._events[h]
        ? l._events[h].fn
          ? (l._events[h] = [l._events[h], p])
          : l._events[h].push(p)
        : ((l._events[h] = p), l._eventsCount++),
      l
    )
  }
  function a(l, u) {
    --l._eventsCount === 0 ? (l._events = new r()) : delete l._events[u]
  }
  function s() {
    ;(this._events = new r()), (this._eventsCount = 0)
  }
  ;(s.prototype.eventNames = function () {
    var u = [],
      f,
      c
    if (this._eventsCount === 0) return u
    for (c in (f = this._events)) t.call(f, c) && u.push(n ? c.slice(1) : c)
    return Object.getOwnPropertySymbols
      ? u.concat(Object.getOwnPropertySymbols(f))
      : u
  }),
    (s.prototype.listeners = function (u) {
      var f = n ? n + u : u,
        c = this._events[f]
      if (!c) return []
      if (c.fn) return [c.fn]
      for (var d = 0, p = c.length, h = new Array(p); d < p; d++) h[d] = c[d].fn
      return h
    }),
    (s.prototype.listenerCount = function (u) {
      var f = n ? n + u : u,
        c = this._events[f]
      return c ? (c.fn ? 1 : c.length) : 0
    }),
    (s.prototype.emit = function (u, f, c, d, p, h) {
      var m = n ? n + u : u
      if (!this._events[m]) return !1
      var b = this._events[m],
        g = arguments.length,
        v,
        y
      if (b.fn) {
        switch ((b.once && this.removeListener(u, b.fn, void 0, !0), g)) {
          case 1:
            return b.fn.call(b.context), !0
          case 2:
            return b.fn.call(b.context, f), !0
          case 3:
            return b.fn.call(b.context, f, c), !0
          case 4:
            return b.fn.call(b.context, f, c, d), !0
          case 5:
            return b.fn.call(b.context, f, c, d, p), !0
          case 6:
            return b.fn.call(b.context, f, c, d, p, h), !0
        }
        for (y = 1, v = new Array(g - 1); y < g; y++) v[y - 1] = arguments[y]
        b.fn.apply(b.context, v)
      } else {
        var w = b.length,
          x
        for (y = 0; y < w; y++)
          switch (
            (b[y].once && this.removeListener(u, b[y].fn, void 0, !0), g)
          ) {
            case 1:
              b[y].fn.call(b[y].context)
              break
            case 2:
              b[y].fn.call(b[y].context, f)
              break
            case 3:
              b[y].fn.call(b[y].context, f, c)
              break
            case 4:
              b[y].fn.call(b[y].context, f, c, d)
              break
            default:
              if (!v)
                for (x = 1, v = new Array(g - 1); x < g; x++)
                  v[x - 1] = arguments[x]
              b[y].fn.apply(b[y].context, v)
          }
      }
      return !0
    }),
    (s.prototype.on = function (u, f, c) {
      return o(this, u, f, c, !1)
    }),
    (s.prototype.once = function (u, f, c) {
      return o(this, u, f, c, !0)
    }),
    (s.prototype.removeListener = function (u, f, c, d) {
      var p = n ? n + u : u
      if (!this._events[p]) return this
      if (!f) return a(this, p), this
      var h = this._events[p]
      if (h.fn)
        h.fn === f && (!d || h.once) && (!c || h.context === c) && a(this, p)
      else {
        for (var m = 0, b = [], g = h.length; m < g; m++)
          (h[m].fn !== f || (d && !h[m].once) || (c && h[m].context !== c)) &&
            b.push(h[m])
        b.length ? (this._events[p] = b.length === 1 ? b[0] : b) : a(this, p)
      }
      return this
    }),
    (s.prototype.removeAllListeners = function (u) {
      var f
      return (
        u
          ? ((f = n ? n + u : u), this._events[f] && a(this, f))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      )
    }),
    (s.prototype.off = s.prototype.removeListener),
    (s.prototype.addListener = s.prototype.on),
    (s.prefixed = n),
    (s.EventEmitter = s),
    (e.exports = s)
})(Kk)
var Koe = Kk.exports
const qoe = Pe(Koe)
var Hh = new qoe(),
  Gh = "recharts.syncMouseEvents"
function Ul(e) {
  "@babel/helpers - typeof"
  return (
    (Ul =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    Ul(e)
  )
}
function Xoe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function wP(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, qk(r.key), r)
  }
}
function Yoe(e, t, n) {
  return (
    t && wP(e.prototype, t),
    n && wP(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function Kh(e, t, n) {
  return (
    (t = qk(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function qk(e) {
  var t = Qoe(e, "string")
  return Ul(t) === "symbol" ? t : String(t)
}
function Qoe(e, t) {
  if (Ul(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (Ul(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var Zoe = (function () {
  function e() {
    Xoe(this, e),
      Kh(this, "activeIndex", 0),
      Kh(this, "coordinateList", []),
      Kh(this, "layout", "horizontal")
  }
  return (
    Yoe(e, [
      {
        key: "setDetails",
        value: function (n) {
          var r = n.coordinateList,
            i = r === void 0 ? [] : r,
            o = n.container,
            a = o === void 0 ? null : o,
            s = n.layout,
            l = s === void 0 ? null : s,
            u = n.offset,
            f = u === void 0 ? null : u,
            c = n.mouseHandlerCallback,
            d = c === void 0 ? null : c
          ;(this.coordinateList = i ?? this.coordinateList),
            (this.container = a ?? this.container),
            (this.layout = l ?? this.layout),
            (this.offset = f ?? this.offset),
            (this.mouseHandlerCallback = d ?? this.mouseHandlerCallback),
            (this.activeIndex = Math.min(
              Math.max(this.activeIndex, 0),
              this.coordinateList.length - 1
            ))
        }
      },
      {
        key: "focus",
        value: function () {
          this.spoofMouse()
        }
      },
      {
        key: "keyboardEvent",
        value: function (n) {
          if (this.coordinateList.length !== 0)
            switch (n.key) {
              case "ArrowRight": {
                if (this.layout !== "horizontal") return
                ;(this.activeIndex = Math.min(
                  this.activeIndex + 1,
                  this.coordinateList.length - 1
                )),
                  this.spoofMouse()
                break
              }
              case "ArrowLeft": {
                if (this.layout !== "horizontal") return
                ;(this.activeIndex = Math.max(this.activeIndex - 1, 0)),
                  this.spoofMouse()
                break
              }
            }
        }
      },
      {
        key: "spoofMouse",
        value: function () {
          var n, r
          if (
            this.layout === "horizontal" &&
            this.coordinateList.length !== 0
          ) {
            var i = this.container.getBoundingClientRect(),
              o = i.x,
              a = i.y,
              s = i.height,
              l = this.coordinateList[this.activeIndex].coordinate,
              u =
                ((n = window) === null || n === void 0 ? void 0 : n.scrollX) ||
                0,
              f =
                ((r = window) === null || r === void 0 ? void 0 : r.scrollY) ||
                0,
              c = o + l + u,
              d = a + this.offset.top + s / 2 + f
            this.mouseHandlerCallback({ pageX: c, pageY: d })
          }
        }
      }
    ]),
    e
  )
})()
function Joe(e, t, n) {
  if (n === "number" && t === !0 && Array.isArray(e)) {
    var r = e == null ? void 0 : e[0],
      i = e == null ? void 0 : e[1]
    if (r && i && G(r) && G(i)) return !0
  }
  return !1
}
function eae(e, t, n) {
  var r, i, o, a
  if (e === "horizontal")
    (r = t.x), (o = r), (i = n.top), (a = n.top + n.height)
  else if (e === "vertical")
    (i = t.y), (a = i), (r = n.left), (o = n.left + n.width)
  else if (t.cx != null && t.cy != null)
    if (e === "centric") {
      var s = t.cx,
        l = t.cy,
        u = t.innerRadius,
        f = t.outerRadius,
        c = t.angle,
        d = yt(s, l, u, c),
        p = yt(s, l, f, c)
      ;(r = d.x), (i = d.y), (o = p.x), (a = p.y)
    } else return Gk(t)
  return [
    { x: r, y: i },
    { x: o, y: a }
  ]
}
function tae(e, t, n, r) {
  var i = r / 2
  return {
    stroke: "none",
    fill: "#ccc",
    x: e === "horizontal" ? t.x - i : n.left + 0.5,
    y: e === "horizontal" ? n.top + 0.5 : t.y - i,
    width: e === "horizontal" ? r : n.width - 1,
    height: e === "horizontal" ? n.height - 1 : r
  }
}
var nae = ["item"],
  rae = [
    "children",
    "className",
    "width",
    "height",
    "style",
    "compact",
    "title",
    "desc"
  ]
function xa(e) {
  "@babel/helpers - typeof"
  return (
    (xa =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (t) {
            return typeof t
          }
        : function (t) {
            return t &&
              typeof Symbol == "function" &&
              t.constructor === Symbol &&
              t !== Symbol.prototype
              ? "symbol"
              : typeof t
          }),
    xa(e)
  )
}
function SP(e, t) {
  return aae(e) || oae(e, t) || Xk(e, t) || iae()
}
function iae() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function oae(e, t) {
  var n =
    e == null
      ? null
      : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"]
  if (n != null) {
    var r,
      i,
      o,
      a,
      s = [],
      l = !0,
      u = !1
    try {
      if (((o = (n = n.call(e)).next), t === 0)) {
        if (Object(n) !== n) return
        l = !1
      } else
        for (
          ;
          !(l = (r = o.call(n)).done) && (s.push(r.value), s.length !== t);
          l = !0
        );
    } catch (f) {
      ;(u = !0), (i = f)
    } finally {
      try {
        if (!l && n.return != null && ((a = n.return()), Object(a) !== a))
          return
      } finally {
        if (u) throw i
      }
    }
    return s
  }
}
function aae(e) {
  if (Array.isArray(e)) return e
}
function Ro() {
  return (
    (Ro = Object.assign
      ? Object.assign.bind()
      : function (e) {
          for (var t = 1; t < arguments.length; t++) {
            var n = arguments[t]
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
          }
          return e
        }),
    Ro.apply(this, arguments)
  )
}
function OP(e, t) {
  if (e == null) return {}
  var n = sae(e, t),
    r,
    i
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e)
    for (i = 0; i < o.length; i++)
      (r = o[i]),
        !(t.indexOf(r) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(e, r) &&
          (n[r] = e[r])
  }
  return n
}
function sae(e, t) {
  if (e == null) return {}
  var n = {},
    r = Object.keys(e),
    i,
    o
  for (o = 0; o < r.length; o++)
    (i = r[o]), !(t.indexOf(i) >= 0) && (n[i] = e[i])
  return n
}
function lae(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function")
}
function PP(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      "value" in r && (r.writable = !0),
      Object.defineProperty(e, Yk(r.key), r)
  }
}
function uae(e, t, n) {
  return (
    t && PP(e.prototype, t),
    n && PP(e, n),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  )
}
function cae(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 }
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && bg(e, t)
}
function bg(e, t) {
  return (
    (bg = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r
        }),
    bg(e, t)
  )
}
function fae(e) {
  var t = pae()
  return function () {
    var r = td(e),
      i
    if (t) {
      var o = td(this).constructor
      i = Reflect.construct(r, arguments, o)
    } else i = r.apply(this, arguments)
    return dae(this, i)
  }
}
function dae(e, t) {
  if (t && (xa(t) === "object" || typeof t == "function")) return t
  if (t !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return oe(e)
}
function oe(e) {
  if (e === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return e
}
function pae() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function td(e) {
  return (
    (td = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (n) {
          return n.__proto__ || Object.getPrototypeOf(n)
        }),
    td(e)
  )
}
function wa(e) {
  return vae(e) || mae(e) || Xk(e) || hae()
}
function hae() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function Xk(e, t) {
  if (e) {
    if (typeof e == "string") return xg(e, t)
    var n = Object.prototype.toString.call(e).slice(8, -1)
    if (
      (n === "Object" && e.constructor && (n = e.constructor.name),
      n === "Map" || n === "Set")
    )
      return Array.from(e)
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return xg(e, t)
  }
}
function mae(e) {
  if (
    (typeof Symbol < "u" && e[Symbol.iterator] != null) ||
    e["@@iterator"] != null
  )
    return Array.from(e)
}
function vae(e) {
  if (Array.isArray(e)) return xg(e)
}
function xg(e, t) {
  ;(t == null || t > e.length) && (t = e.length)
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n]
  return r
}
function $P(e, t) {
  var n = Object.keys(e)
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e)
    t &&
      (r = r.filter(function (i) {
        return Object.getOwnPropertyDescriptor(e, i).enumerable
      })),
      n.push.apply(n, r)
  }
  return n
}
function B(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}
    t % 2
      ? $P(Object(n), !0).forEach(function (r) {
          Y(e, r, n[r])
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
        : $P(Object(n)).forEach(function (r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r))
          })
  }
  return e
}
function Y(e, t, n) {
  return (
    (t = Yk(t)),
    t in e
      ? Object.defineProperty(e, t, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        })
      : (e[t] = n),
    e
  )
}
function Yk(e) {
  var t = gae(e, "string")
  return xa(t) === "symbol" ? t : String(t)
}
function gae(e, t) {
  if (xa(e) !== "object" || e === null) return e
  var n = e[Symbol.toPrimitive]
  if (n !== void 0) {
    var r = n.call(e, t || "default")
    if (xa(r) !== "object") return r
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (t === "string" ? String : Number)(e)
}
var yae = { xAxis: ["bottom", "top"], yAxis: ["left", "right"] },
  bae = { width: "100%", height: "100%" },
  Qk = { x: 0, y: 0 },
  xae = function (t, n) {
    return n === "horizontal"
      ? t.x
      : n === "vertical"
        ? t.y
        : n === "centric"
          ? t.angle
          : t.radius
  },
  wae = function (t, n, r, i) {
    var o = n.find(function (f) {
      return f && f.index === r
    })
    if (o) {
      if (t === "horizontal") return { x: o.coordinate, y: i.y }
      if (t === "vertical") return { x: i.x, y: o.coordinate }
      if (t === "centric") {
        var a = o.coordinate,
          s = i.radius
        return B(B(B({}, i), yt(i.cx, i.cy, s, a)), {}, { angle: a, radius: s })
      }
      var l = o.coordinate,
        u = i.angle
      return B(B(B({}, i), yt(i.cx, i.cy, l, u)), {}, { angle: u, radius: l })
    }
    return Qk
  },
  yp = function (t, n) {
    var r = n.graphicalItems,
      i = n.dataStartIndex,
      o = n.dataEndIndex,
      a = (r ?? []).reduce(function (s, l) {
        var u = l.props.data
        return u && u.length ? [].concat(wa(s), wa(u)) : s
      }, [])
    return a.length > 0
      ? a
      : t && t.length && G(i) && G(o)
        ? t.slice(i, o + 1)
        : []
  }
function Zk(e) {
  return e === "number" ? [0, "auto"] : void 0
}
var Jk = function (t, n, r, i) {
    var o = t.graphicalItems,
      a = t.tooltipAxis,
      s = yp(n, t)
    return r < 0 || !o || !o.length || r >= s.length
      ? null
      : o.reduce(function (l, u) {
          var f,
            c = u.props.hide
          if (c) return l
          var d = (f = u.props.data) !== null && f !== void 0 ? f : n
          d &&
            t.dataStartIndex + t.dataEndIndex !== 0 &&
            (d = d.slice(t.dataStartIndex, t.dataEndIndex + 1))
          var p
          if (a.dataKey && !a.allowDuplicatedCategory) {
            var h = d === void 0 ? s : d
            p = cv(h, a.dataKey, i)
          } else p = (d && d[r]) || s[r]
          return p ? [].concat(wa(l), [_k(u, p)]) : l
        }, [])
  },
  AP = function (t, n, r, i) {
    var o = i || { x: t.chartX, y: t.chartY },
      a = xae(o, r),
      s = t.orderedTooltipTicks,
      l = t.tooltipAxis,
      u = t.tooltipTicks,
      f = Mee(a, s, u, l)
    if (f >= 0 && u) {
      var c = u[f] && u[f].value,
        d = Jk(t, n, f, c),
        p = wae(r, s, f, o)
      return {
        activeTooltipIndex: f,
        activeLabel: c,
        activePayload: d,
        activeCoordinate: p
      }
    }
    return null
  },
  Sae = function (t, n) {
    var r = n.axes,
      i = n.graphicalItems,
      o = n.axisType,
      a = n.axisIdKey,
      s = n.stackGroups,
      l = n.dataStartIndex,
      u = n.dataEndIndex,
      f = t.layout,
      c = t.children,
      d = t.stackOffset,
      p = Ek(f, o)
    return r.reduce(function (h, m) {
      var b,
        g = m.props,
        v = g.type,
        y = g.dataKey,
        w = g.allowDataOverflow,
        x = g.allowDuplicatedCategory,
        S = g.scale,
        O = g.ticks,
        $ = g.includeHidden,
        A = m.props[a]
      if (h[A]) return h
      var C = yp(t.data, {
          graphicalItems: i.filter(function (H) {
            return H.props[a] === A
          }),
          dataStartIndex: l,
          dataEndIndex: u
        }),
        T = C.length,
        _,
        R,
        M
      Joe(m.props.domain, w, v) &&
        ((_ = ng(m.props.domain, null, w)),
        p && (v === "number" || S !== "auto") && (M = Rs(C, y, "category")))
      var D = Zk(v)
      if (!_ || _.length === 0) {
        var N,
          L = (N = m.props.domain) !== null && N !== void 0 ? N : D
        if (y) {
          if (((_ = Rs(C, y, v)), v === "category" && p)) {
            var k = f8(_)
            x && k
              ? ((R = _), (_ = qf(0, T)))
              : x ||
                (_ = AO(L, _, m).reduce(function (H, ee) {
                  return H.indexOf(ee) >= 0 ? H : [].concat(wa(H), [ee])
                }, []))
          } else if (v === "category")
            x
              ? (_ = _.filter(function (H) {
                  return H !== "" && !xe(H)
                }))
              : (_ = AO(L, _, m).reduce(function (H, ee) {
                  return H.indexOf(ee) >= 0 || ee === "" || xe(ee)
                    ? H
                    : [].concat(wa(H), [ee])
                }, []))
          else if (v === "number") {
            var I = Ree(
              C,
              i.filter(function (H) {
                return H.props[a] === A && ($ || !H.props.hide)
              }),
              y,
              o,
              f
            )
            I && (_ = I)
          }
          p && (v === "number" || S !== "auto") && (M = Rs(C, y, "category"))
        } else
          p
            ? (_ = qf(0, T))
            : s && s[A] && s[A].hasStack && v === "number"
              ? (_ = d === "expand" ? [0, 1] : Ck(s[A].stackGroups, l, u))
              : (_ = Tk(
                  C,
                  i.filter(function (H) {
                    return H.props[a] === A && ($ || !H.props.hide)
                  }),
                  v,
                  f,
                  !0
                ))
        if (v === "number") (_ = yg(c, _, A, o, O)), L && (_ = ng(L, _, w))
        else if (v === "category" && L) {
          var V = L,
            U = _.every(function (H) {
              return V.indexOf(H) >= 0
            })
          U && (_ = V)
        }
      }
      return B(
        B({}, h),
        {},
        Y(
          {},
          A,
          B(
            B({}, m.props),
            {},
            {
              axisType: o,
              domain: _,
              categoricalDomain: M,
              duplicateDomain: R,
              originalDomain:
                (b = m.props.domain) !== null && b !== void 0 ? b : D,
              isCategorical: p,
              layout: f
            }
          )
        )
      )
    }, {})
  },
  Oae = function (t, n) {
    var r = n.graphicalItems,
      i = n.Axis,
      o = n.axisType,
      a = n.axisIdKey,
      s = n.stackGroups,
      l = n.dataStartIndex,
      u = n.dataEndIndex,
      f = t.layout,
      c = t.children,
      d = yp(t.data, { graphicalItems: r, dataStartIndex: l, dataEndIndex: u }),
      p = d.length,
      h = Ek(f, o),
      m = -1
    return r.reduce(function (b, g) {
      var v = g.props[a],
        y = Zk("number")
      if (!b[v]) {
        m++
        var w
        return (
          h
            ? (w = qf(0, p))
            : s && s[v] && s[v].hasStack
              ? ((w = Ck(s[v].stackGroups, l, u)), (w = yg(c, w, v, o)))
              : ((w = ng(
                  y,
                  Tk(
                    d,
                    r.filter(function (x) {
                      return x.props[a] === v && !x.props.hide
                    }),
                    "number",
                    f
                  ),
                  i.defaultProps.allowDataOverflow
                )),
                (w = yg(c, w, v, o))),
          B(
            B({}, b),
            {},
            Y(
              {},
              v,
              B(
                B({ axisType: o }, i.defaultProps),
                {},
                {
                  hide: !0,
                  orientation: mn(yae, "".concat(o, ".").concat(m % 2), null),
                  domain: w,
                  originalDomain: y,
                  isCategorical: h,
                  layout: f
                }
              )
            )
          )
        )
      }
      return b
    }, {})
  },
  Pae = function (t, n) {
    var r = n.axisType,
      i = r === void 0 ? "xAxis" : r,
      o = n.AxisComp,
      a = n.graphicalItems,
      s = n.stackGroups,
      l = n.dataStartIndex,
      u = n.dataEndIndex,
      f = t.children,
      c = "".concat(i, "Id"),
      d = jn(f, o),
      p = {}
    return (
      d && d.length
        ? (p = Sae(t, {
            axes: d,
            graphicalItems: a,
            axisType: i,
            axisIdKey: c,
            stackGroups: s,
            dataStartIndex: l,
            dataEndIndex: u
          }))
        : a &&
          a.length &&
          (p = Oae(t, {
            Axis: o,
            graphicalItems: a,
            axisType: i,
            axisIdKey: c,
            stackGroups: s,
            dataStartIndex: l,
            dataEndIndex: u
          })),
      p
    )
  },
  $ae = function (t) {
    var n = Fr(t),
      r = Vr(n, !1, !0)
    return {
      tooltipTicks: r,
      orderedTooltipTicks: g0(r, function (i) {
        return i.coordinate
      }),
      tooltipAxis: n,
      tooltipAxisBandSize: zf(n, r)
    }
  },
  TP = function (t) {
    var n = t.children,
      r = t.defaultShowTooltip,
      i = ur(n, Nl),
      o = 0,
      a = 0
    return (
      t.data && t.data.length !== 0 && (a = t.data.length - 1),
      i &&
        i.props &&
        (i.props.startIndex >= 0 && (o = i.props.startIndex),
        i.props.endIndex >= 0 && (a = i.props.endIndex)),
      {
        chartX: 0,
        chartY: 0,
        dataStartIndex: o,
        dataEndIndex: a,
        activeTooltipIndex: -1,
        isTooltipActive: !!r
      }
    )
  },
  Aae = function (t) {
    return !t || !t.length
      ? !1
      : t.some(function (n) {
          var r = ai(n && n.type)
          return r && r.indexOf("Bar") >= 0
        })
  },
  EP = function (t) {
    return t === "horizontal"
      ? { numericAxisName: "yAxis", cateAxisName: "xAxis" }
      : t === "vertical"
        ? { numericAxisName: "xAxis", cateAxisName: "yAxis" }
        : t === "centric"
          ? { numericAxisName: "radiusAxis", cateAxisName: "angleAxis" }
          : { numericAxisName: "angleAxis", cateAxisName: "radiusAxis" }
  },
  Tae = function (t, n) {
    var r = t.props,
      i = t.graphicalItems,
      o = t.xAxisMap,
      a = o === void 0 ? {} : o,
      s = t.yAxisMap,
      l = s === void 0 ? {} : s,
      u = r.width,
      f = r.height,
      c = r.children,
      d = r.margin || {},
      p = ur(c, Nl),
      h = ur(c, ll),
      m = Object.keys(l).reduce(
        function (x, S) {
          var O = l[S],
            $ = O.orientation
          return !O.mirror && !O.hide
            ? B(B({}, x), {}, Y({}, $, x[$] + O.width))
            : x
        },
        { left: d.left || 0, right: d.right || 0 }
      ),
      b = Object.keys(a).reduce(
        function (x, S) {
          var O = a[S],
            $ = O.orientation
          return !O.mirror && !O.hide
            ? B(B({}, x), {}, Y({}, $, mn(x, "".concat($)) + O.height))
            : x
        },
        { top: d.top || 0, bottom: d.bottom || 0 }
      ),
      g = B(B({}, b), m),
      v = g.bottom
    p && (g.bottom += p.props.height || Nl.defaultProps.height),
      h && n && (g = Iee(g, i, r, n))
    var y = u - g.left - g.right,
      w = f - g.top - g.bottom
    return B(
      B({ brushBottom: v }, g),
      {},
      { width: Math.max(y, 0), height: Math.max(w, 0) }
    )
  },
  Eae = function (t) {
    var n,
      r = t.chartName,
      i = t.GraphicalChild,
      o = t.defaultTooltipEventType,
      a = o === void 0 ? "axis" : o,
      s = t.validateTooltipEventTypes,
      l = s === void 0 ? ["axis"] : s,
      u = t.axisComponents,
      f = t.legendContent,
      c = t.formatAxisMap,
      d = t.defaultProps,
      p = function (b, g) {
        var v = g.graphicalItems,
          y = g.stackGroups,
          w = g.offset,
          x = g.updateId,
          S = g.dataStartIndex,
          O = g.dataEndIndex,
          $ = b.barSize,
          A = b.layout,
          C = b.barGap,
          T = b.barCategoryGap,
          _ = b.maxBarSize,
          R = EP(A),
          M = R.numericAxisName,
          D = R.cateAxisName,
          N = Aae(v),
          L = N && jee({ barSize: $, stackGroups: y }),
          k = []
        return (
          v.forEach(function (I, V) {
            var U = yp(b.data, {
                graphicalItems: [I],
                dataStartIndex: S,
                dataEndIndex: O
              }),
              H = I.props,
              ee = H.dataKey,
              X = H.maxBarSize,
              de = I.props["".concat(M, "Id")],
              ue = I.props["".concat(D, "Id")],
              We = {},
              Qe = u.reduce(function (Ze, Rn) {
                var co,
                  jr = g["".concat(Rn.axisType, "Map")],
                  hu = I.props["".concat(Rn.axisType, "Id")]
                ;(jr && jr[hu]) || Rn.axisType === "zAxis" || zoe(!1)
                var mu = jr[hu]
                return B(
                  B({}, Ze),
                  {},
                  ((co = {}),
                  Y(co, Rn.axisType, mu),
                  Y(co, "".concat(Rn.axisType, "Ticks"), Vr(mu)),
                  co)
                )
              }, We),
              W = Qe[D],
              Q = Qe["".concat(D, "Ticks")],
              Z = y && y[de] && y[de].hasStack && Xee(I, y[de].stackGroups),
              F = ai(I.type).indexOf("Bar") >= 0,
              me = zf(W, Q),
              ae = []
            if (F) {
              var ve,
                je,
                Ke = xe(X) ? _ : X,
                It =
                  (ve =
                    (je = zf(W, Q, !0)) !== null && je !== void 0 ? je : Ke) !==
                    null && ve !== void 0
                    ? ve
                    : 0
              ;(ae = Dee({
                barGap: C,
                barCategoryGap: T,
                bandSize: It !== me ? It : me,
                sizeList: L[ue],
                maxBarSize: Ke
              })),
                It !== me &&
                  (ae = ae.map(function (Ze) {
                    return B(
                      B({}, Ze),
                      {},
                      {
                        position: B(
                          B({}, Ze.position),
                          {},
                          { offset: Ze.position.offset - It / 2 }
                        )
                      }
                    )
                  }))
            }
            var er = I && I.type && I.type.getComposedData
            if (er) {
              var wn
              k.push({
                props: B(
                  B(
                    {},
                    er(
                      B(
                        B({}, Qe),
                        {},
                        {
                          displayedData: U,
                          props: b,
                          dataKey: ee,
                          item: I,
                          bandSize: me,
                          barPosition: ae,
                          offset: w,
                          stackedData: Z,
                          layout: A,
                          dataStartIndex: S,
                          dataEndIndex: O
                        }
                      )
                    )
                  ),
                  {},
                  ((wn = { key: I.key || "item-".concat(V) }),
                  Y(wn, M, Qe[M]),
                  Y(wn, D, Qe[D]),
                  Y(wn, "animationId", x),
                  wn)
                ),
                childIndex: S8(I, b.children),
                item: I
              })
            }
          }),
          k
        )
      },
      h = function (b, g) {
        var v = b.props,
          y = b.dataStartIndex,
          w = b.dataEndIndex,
          x = b.updateId
        if (!tw({ props: v })) return null
        var S = v.children,
          O = v.layout,
          $ = v.stackOffset,
          A = v.data,
          C = v.reverseStackOrder,
          T = EP(O),
          _ = T.numericAxisName,
          R = T.cateAxisName,
          M = jn(S, i),
          D = Gee(A, M, "".concat(_, "Id"), "".concat(R, "Id"), $, C),
          N = u.reduce(function (U, H) {
            var ee = "".concat(H.axisType, "Map")
            return B(
              B({}, U),
              {},
              Y(
                {},
                ee,
                Pae(
                  v,
                  B(
                    B({}, H),
                    {},
                    {
                      graphicalItems: M,
                      stackGroups: H.axisType === _ && D,
                      dataStartIndex: y,
                      dataEndIndex: w
                    }
                  )
                )
              )
            )
          }, {}),
          L = Tae(
            B(B({}, N), {}, { props: v, graphicalItems: M }),
            g == null ? void 0 : g.legendBBox
          )
        Object.keys(N).forEach(function (U) {
          N[U] = c(v, N[U], L, U.replace("Map", ""), r)
        })
        var k = N["".concat(R, "Map")],
          I = $ae(k),
          V = p(
            v,
            B(
              B({}, N),
              {},
              {
                dataStartIndex: y,
                dataEndIndex: w,
                updateId: x,
                graphicalItems: M,
                stackGroups: D,
                offset: L
              }
            )
          )
        return B(
          B(
            {
              formattedGraphicalItems: V,
              graphicalItems: M,
              offset: L,
              stackGroups: D
            },
            I
          ),
          N
        )
      }
    return (
      (n = (function (m) {
        cae(g, m)
        var b = fae(g)
        function g(v) {
          var y, w, x
          return (
            lae(this, g),
            (x = b.call(this, v)),
            Y(oe(x), "eventEmitterSymbol", Symbol("rechartsEventEmitter")),
            Y(oe(x), "accessibilityManager", new Zoe()),
            Y(oe(x), "handleLegendBBoxUpdate", function (S) {
              if (S) {
                var O = x.state,
                  $ = O.dataStartIndex,
                  A = O.dataEndIndex,
                  C = O.updateId
                x.setState(
                  B(
                    { legendBBox: S },
                    h(
                      {
                        props: x.props,
                        dataStartIndex: $,
                        dataEndIndex: A,
                        updateId: C
                      },
                      B(B({}, x.state), {}, { legendBBox: S })
                    )
                  )
                )
              }
            }),
            Y(oe(x), "handleReceiveSyncEvent", function (S, O, $) {
              if (x.props.syncId === S) {
                if (
                  $ === x.eventEmitterSymbol &&
                  typeof x.props.syncMethod != "function"
                )
                  return
                x.applySyncEvent(O)
              }
            }),
            Y(oe(x), "handleBrushChange", function (S) {
              var O = S.startIndex,
                $ = S.endIndex
              if (O !== x.state.dataStartIndex || $ !== x.state.dataEndIndex) {
                var A = x.state.updateId
                x.setState(function () {
                  return B(
                    { dataStartIndex: O, dataEndIndex: $ },
                    h(
                      {
                        props: x.props,
                        dataStartIndex: O,
                        dataEndIndex: $,
                        updateId: A
                      },
                      x.state
                    )
                  )
                }),
                  x.triggerSyncEvent({ dataStartIndex: O, dataEndIndex: $ })
              }
            }),
            Y(oe(x), "handleMouseEnter", function (S) {
              var O = x.getMouseInfo(S)
              if (O) {
                var $ = B(B({}, O), {}, { isTooltipActive: !0 })
                x.setState($), x.triggerSyncEvent($)
                var A = x.props.onMouseEnter
                ce(A) && A($, S)
              }
            }),
            Y(oe(x), "triggeredAfterMouseMove", function (S) {
              var O = x.getMouseInfo(S),
                $ = O
                  ? B(B({}, O), {}, { isTooltipActive: !0 })
                  : { isTooltipActive: !1 }
              x.setState($), x.triggerSyncEvent($)
              var A = x.props.onMouseMove
              ce(A) && A($, S)
            }),
            Y(oe(x), "handleItemMouseEnter", function (S) {
              x.setState(function () {
                return {
                  isTooltipActive: !0,
                  activeItem: S,
                  activePayload: S.tooltipPayload,
                  activeCoordinate: S.tooltipPosition || { x: S.cx, y: S.cy }
                }
              })
            }),
            Y(oe(x), "handleItemMouseLeave", function () {
              x.setState(function () {
                return { isTooltipActive: !1 }
              })
            }),
            Y(oe(x), "handleMouseMove", function (S) {
              S.persist(), x.throttleTriggeredAfterMouseMove(S)
            }),
            Y(oe(x), "handleMouseLeave", function (S) {
              var O = { isTooltipActive: !1 }
              x.setState(O), x.triggerSyncEvent(O)
              var $ = x.props.onMouseLeave
              ce($) && $(O, S)
            }),
            Y(oe(x), "handleOuterEvent", function (S) {
              var O = w8(S),
                $ = mn(x.props, "".concat(O))
              if (O && ce($)) {
                var A, C
                ;/.*touch.*/i.test(O)
                  ? (C = x.getMouseInfo(S.changedTouches[0]))
                  : (C = x.getMouseInfo(S)),
                  $((A = C) !== null && A !== void 0 ? A : {}, S)
              }
            }),
            Y(oe(x), "handleClick", function (S) {
              var O = x.getMouseInfo(S)
              if (O) {
                var $ = B(B({}, O), {}, { isTooltipActive: !0 })
                x.setState($), x.triggerSyncEvent($)
                var A = x.props.onClick
                ce(A) && A($, S)
              }
            }),
            Y(oe(x), "handleMouseDown", function (S) {
              var O = x.props.onMouseDown
              if (ce(O)) {
                var $ = x.getMouseInfo(S)
                O($, S)
              }
            }),
            Y(oe(x), "handleMouseUp", function (S) {
              var O = x.props.onMouseUp
              if (ce(O)) {
                var $ = x.getMouseInfo(S)
                O($, S)
              }
            }),
            Y(oe(x), "handleTouchMove", function (S) {
              S.changedTouches != null &&
                S.changedTouches.length > 0 &&
                x.throttleTriggeredAfterMouseMove(S.changedTouches[0])
            }),
            Y(oe(x), "handleTouchStart", function (S) {
              S.changedTouches != null &&
                S.changedTouches.length > 0 &&
                x.handleMouseDown(S.changedTouches[0])
            }),
            Y(oe(x), "handleTouchEnd", function (S) {
              S.changedTouches != null &&
                S.changedTouches.length > 0 &&
                x.handleMouseUp(S.changedTouches[0])
            }),
            Y(oe(x), "triggerSyncEvent", function (S) {
              x.props.syncId !== void 0 &&
                Hh.emit(Gh, x.props.syncId, S, x.eventEmitterSymbol)
            }),
            Y(oe(x), "applySyncEvent", function (S) {
              var O = x.props,
                $ = O.layout,
                A = O.syncMethod,
                C = x.state.updateId,
                T = S.dataStartIndex,
                _ = S.dataEndIndex
              if (S.dataStartIndex !== void 0 || S.dataEndIndex !== void 0)
                x.setState(
                  B(
                    { dataStartIndex: T, dataEndIndex: _ },
                    h(
                      {
                        props: x.props,
                        dataStartIndex: T,
                        dataEndIndex: _,
                        updateId: C
                      },
                      x.state
                    )
                  )
                )
              else if (S.activeTooltipIndex !== void 0) {
                var R = S.chartX,
                  M = S.chartY,
                  D = S.activeTooltipIndex,
                  N = x.state,
                  L = N.offset,
                  k = N.tooltipTicks
                if (!L) return
                if (typeof A == "function") D = A(k, S)
                else if (A === "value") {
                  D = -1
                  for (var I = 0; I < k.length; I++)
                    if (k[I].value === S.activeLabel) {
                      D = I
                      break
                    }
                }
                var V = B(B({}, L), {}, { x: L.left, y: L.top }),
                  U = Math.min(R, V.x + V.width),
                  H = Math.min(M, V.y + V.height),
                  ee = k[D] && k[D].value,
                  X = Jk(x.state, x.props.data, D),
                  de = k[D]
                    ? {
                        x: $ === "horizontal" ? k[D].coordinate : U,
                        y: $ === "horizontal" ? H : k[D].coordinate
                      }
                    : Qk
                x.setState(
                  B(
                    B({}, S),
                    {},
                    {
                      activeLabel: ee,
                      activeCoordinate: de,
                      activePayload: X,
                      activeTooltipIndex: D
                    }
                  )
                )
              } else x.setState(S)
            }),
            Y(oe(x), "verticalCoordinatesGenerator", function (S, O) {
              var $ = S.xAxis,
                A = S.width,
                C = S.height,
                T = S.offset
              return wO(
                mg(
                  B(
                    B(B({}, Ls.defaultProps), $),
                    {},
                    {
                      ticks: Vr($, !0),
                      viewBox: { x: 0, y: 0, width: A, height: C }
                    }
                  )
                ),
                T.left,
                T.left + T.width,
                O
              )
            }),
            Y(oe(x), "horizontalCoordinatesGenerator", function (S, O) {
              var $ = S.yAxis,
                A = S.width,
                C = S.height,
                T = S.offset
              return wO(
                mg(
                  B(
                    B(B({}, Ls.defaultProps), $),
                    {},
                    {
                      ticks: Vr($, !0),
                      viewBox: { x: 0, y: 0, width: A, height: C }
                    }
                  )
                ),
                T.top,
                T.top + T.height,
                O
              )
            }),
            Y(oe(x), "axesTicksGenerator", function (S) {
              return Vr(S, !0)
            }),
            Y(oe(x), "renderCursor", function (S) {
              var O,
                $ = x.state,
                A = $.isTooltipActive,
                C = $.activeCoordinate,
                T = $.activePayload,
                _ = $.offset,
                R = $.activeTooltipIndex,
                M = $.tooltipAxisBandSize,
                D = x.getTooltipEventType(),
                N = (O = S.props.active) !== null && O !== void 0 ? O : A
              if (
                !S ||
                !S.props.cursor ||
                !N ||
                !C ||
                (r !== "ScatterChart" && D !== "axis")
              )
                return null
              var L = x.props.layout,
                k,
                I = BO
              if (r === "ScatterChart") (k = C), (I = vne)
              else if (r === "BarChart") (k = tae(L, C, _, M)), (I = G0)
              else if (L === "radial") {
                var V = Gk(C),
                  U = V.cx,
                  H = V.cy,
                  ee = V.radius,
                  X = V.startAngle,
                  de = V.endAngle
                ;(k = {
                  cx: U,
                  cy: H,
                  startAngle: X,
                  endAngle: de,
                  innerRadius: ee,
                  outerRadius: ee
                }),
                  (I = jk)
              } else (k = { points: eae(L, C, _) }), (I = BO)
              var ue = S.key || "_recharts-cursor",
                We = B(
                  B(
                    B(B({ stroke: "#ccc", pointerEvents: "none" }, _), k),
                    he(S.props.cursor)
                  ),
                  {},
                  {
                    payload: T,
                    payloadIndex: R,
                    key: ue,
                    className: "recharts-tooltip-cursor"
                  }
                )
              return P.isValidElement(S.props.cursor)
                ? P.cloneElement(S.props.cursor, We)
                : P.createElement(I, We)
            }),
            Y(oe(x), "renderPolarAxis", function (S, O, $) {
              var A = mn(S, "type.axisType"),
                C = mn(x.state, "".concat(A, "Map")),
                T = C && C[S.props["".concat(A, "Id")]]
              return P.cloneElement(
                S,
                B(
                  B({}, T),
                  {},
                  {
                    className: A,
                    key: S.key || "".concat(O, "-").concat($),
                    ticks: Vr(T, !0)
                  }
                )
              )
            }),
            Y(oe(x), "renderXAxis", function (S, O, $) {
              var A = x.state.xAxisMap,
                C = A[S.props.xAxisId]
              return x.renderAxis(C, S, O, $)
            }),
            Y(oe(x), "renderYAxis", function (S, O, $) {
              var A = x.state.yAxisMap,
                C = A[S.props.yAxisId]
              return x.renderAxis(C, S, O, $)
            }),
            Y(oe(x), "renderGrid", function (S) {
              var O = x.state,
                $ = O.xAxisMap,
                A = O.yAxisMap,
                C = O.offset,
                T = x.props,
                _ = T.width,
                R = T.height,
                M = Fr($),
                D = Foe(A, function (k) {
                  return Bk(k.domain, Number.isFinite)
                }),
                N = D || Fr(A),
                L = S.props || {}
              return P.cloneElement(S, {
                key: S.key || "grid",
                x: G(L.x) ? L.x : C.left,
                y: G(L.y) ? L.y : C.top,
                width: G(L.width) ? L.width : C.width,
                height: G(L.height) ? L.height : C.height,
                xAxis: M,
                yAxis: N,
                offset: C,
                chartWidth: _,
                chartHeight: R,
                verticalCoordinatesGenerator:
                  L.verticalCoordinatesGenerator ||
                  x.verticalCoordinatesGenerator,
                horizontalCoordinatesGenerator:
                  L.horizontalCoordinatesGenerator ||
                  x.horizontalCoordinatesGenerator
              })
            }),
            Y(oe(x), "renderPolarGrid", function (S) {
              var O = S.props,
                $ = O.radialLines,
                A = O.polarAngles,
                C = O.polarRadius,
                T = x.state,
                _ = T.radiusAxisMap,
                R = T.angleAxisMap,
                M = Fr(_),
                D = Fr(R),
                N = D.cx,
                L = D.cy,
                k = D.innerRadius,
                I = D.outerRadius
              return P.cloneElement(S, {
                polarAngles: Array.isArray(A)
                  ? A
                  : Vr(D, !0).map(function (V) {
                      return V.coordinate
                    }),
                polarRadius: Array.isArray(C)
                  ? C
                  : Vr(M, !0).map(function (V) {
                      return V.coordinate
                    }),
                cx: N,
                cy: L,
                innerRadius: k,
                outerRadius: I,
                key: S.key || "polar-grid",
                radialLines: $
              })
            }),
            Y(oe(x), "renderLegend", function () {
              var S = x.state.formattedGraphicalItems,
                O = x.props,
                $ = O.children,
                A = O.width,
                C = O.height,
                T = x.props.margin || {},
                _ = A - (T.left || 0) - (T.right || 0),
                R = $k({
                  children: $,
                  formattedGraphicalItems: S,
                  legendWidth: _,
                  legendContent: f
                })
              if (!R) return null
              var M = R.item,
                D = OP(R, nae)
              return P.cloneElement(
                M,
                B(
                  B({}, D),
                  {},
                  {
                    chartWidth: A,
                    chartHeight: C,
                    margin: T,
                    onBBoxUpdate: x.handleLegendBBoxUpdate
                  }
                )
              )
            }),
            Y(oe(x), "renderTooltip", function () {
              var S,
                O = x.props.children,
                $ = ur(O, Vi)
              if (!$) return null
              var A = x.state,
                C = A.isTooltipActive,
                T = A.activeCoordinate,
                _ = A.activePayload,
                R = A.activeLabel,
                M = A.offset,
                D = (S = $.props.active) !== null && S !== void 0 ? S : C
              return P.cloneElement($, {
                viewBox: B(B({}, M), {}, { x: M.left, y: M.top }),
                active: D,
                label: R,
                payload: D ? _ : [],
                coordinate: T
              })
            }),
            Y(oe(x), "renderBrush", function (S) {
              var O = x.props,
                $ = O.margin,
                A = O.data,
                C = x.state,
                T = C.offset,
                _ = C.dataStartIndex,
                R = C.dataEndIndex,
                M = C.updateId
              return P.cloneElement(S, {
                key: S.key || "_recharts-brush",
                onChange: nc(x.handleBrushChange, S.props.onChange),
                data: A,
                x: G(S.props.x) ? S.props.x : T.left,
                y: G(S.props.y)
                  ? S.props.y
                  : T.top + T.height + T.brushBottom - ($.bottom || 0),
                width: G(S.props.width) ? S.props.width : T.width,
                startIndex: _,
                endIndex: R,
                updateId: "brush-".concat(M)
              })
            }),
            Y(oe(x), "renderReferenceElement", function (S, O, $) {
              if (!S) return null
              var A = oe(x),
                C = A.clipPathId,
                T = x.state,
                _ = T.xAxisMap,
                R = T.yAxisMap,
                M = T.offset,
                D = S.props,
                N = D.xAxisId,
                L = D.yAxisId
              return P.cloneElement(S, {
                key: S.key || "".concat(O, "-").concat($),
                xAxis: _[N],
                yAxis: R[L],
                viewBox: {
                  x: M.left,
                  y: M.top,
                  width: M.width,
                  height: M.height
                },
                clipPathId: C
              })
            }),
            Y(oe(x), "renderActivePoints", function (S) {
              var O = S.item,
                $ = S.activePoint,
                A = S.basePoint,
                C = S.childIndex,
                T = S.isRange,
                _ = [],
                R = O.props.key,
                M = O.item.props,
                D = M.activeDot,
                N = M.dataKey,
                L = B(
                  B(
                    {
                      index: C,
                      dataKey: N,
                      cx: $.x,
                      cy: $.y,
                      r: 4,
                      fill: H0(O.item),
                      strokeWidth: 2,
                      stroke: "#fff",
                      payload: $.payload,
                      value: $.value,
                      key: "".concat(R, "-activePoint-").concat(C)
                    },
                    he(D)
                  ),
                  cf(D)
                )
              return (
                _.push(g.renderActiveDot(D, L)),
                A
                  ? _.push(
                      g.renderActiveDot(
                        D,
                        B(
                          B({}, L),
                          {},
                          {
                            cx: A.x,
                            cy: A.y,
                            key: "".concat(R, "-basePoint-").concat(C)
                          }
                        )
                      )
                    )
                  : T && _.push(null),
                _
              )
            }),
            Y(oe(x), "renderGraphicChild", function (S, O, $) {
              var A = x.filterFormatItem(S, O, $)
              if (!A) return null
              var C = x.getTooltipEventType(),
                T = x.state,
                _ = T.isTooltipActive,
                R = T.tooltipAxis,
                M = T.activeTooltipIndex,
                D = T.activeLabel,
                N = x.props.children,
                L = ur(N, Vi),
                k = A.props,
                I = k.points,
                V = k.isRange,
                U = k.baseLine,
                H = A.item.props,
                ee = H.activeDot,
                X = H.hide,
                de = H.activeBar,
                ue = H.activeShape,
                We = !!(!X && _ && L && (ee || de || ue)),
                Qe = {}
              C !== "axis" && L && L.props.trigger === "click"
                ? (Qe = {
                    onClick: nc(x.handleItemMouseEnter, S.props.onClick)
                  })
                : C !== "axis" &&
                  (Qe = {
                    onMouseLeave: nc(
                      x.handleItemMouseLeave,
                      S.props.onMouseLeave
                    ),
                    onMouseEnter: nc(
                      x.handleItemMouseEnter,
                      S.props.onMouseEnter
                    )
                  })
              var W = P.cloneElement(S, B(B({}, A.props), Qe))
              function Q(Rn) {
                return typeof R.dataKey == "function"
                  ? R.dataKey(Rn.payload)
                  : null
              }
              if (We)
                if (M >= 0) {
                  var Z, F
                  if (R.dataKey && !R.allowDuplicatedCategory) {
                    var me =
                      typeof R.dataKey == "function"
                        ? Q
                        : "payload.".concat(R.dataKey.toString())
                    ;(Z = cv(I, me, D)), (F = V && U && cv(U, me, D))
                  } else (Z = I == null ? void 0 : I[M]), (F = V && U && U[M])
                  if (ue || de) {
                    var ae =
                      S.props.activeIndex !== void 0 ? S.props.activeIndex : M
                    return [
                      P.cloneElement(
                        S,
                        B(B(B({}, A.props), Qe), {}, { activeIndex: ae })
                      ),
                      null,
                      null
                    ]
                  }
                  if (!xe(Z))
                    return [W].concat(
                      wa(
                        x.renderActivePoints({
                          item: A,
                          activePoint: Z,
                          basePoint: F,
                          childIndex: M,
                          isRange: V
                        })
                      )
                    )
                } else {
                  var ve,
                    je =
                      (ve = x.getItemByXY(x.state.activeCoordinate)) !== null &&
                      ve !== void 0
                        ? ve
                        : { graphicalItem: W },
                    Ke = je.graphicalItem,
                    It = Ke.item,
                    er = It === void 0 ? S : It,
                    wn = Ke.childIndex,
                    Ze = B(B(B({}, A.props), Qe), {}, { activeIndex: wn })
                  return [P.cloneElement(er, Ze), null, null]
                }
              return V ? [W, null, null] : [W, null]
            }),
            Y(oe(x), "renderCustomized", function (S, O, $) {
              return P.cloneElement(
                S,
                B(
                  B({ key: "recharts-customized-".concat($) }, x.props),
                  x.state
                )
              )
            }),
            Y(oe(x), "renderMap", {
              CartesianGrid: { handler: x.renderGrid, once: !0 },
              ReferenceArea: { handler: x.renderReferenceElement },
              ReferenceLine: { handler: x.renderReferenceElement },
              ReferenceDot: { handler: x.renderReferenceElement },
              XAxis: { handler: x.renderXAxis },
              YAxis: { handler: x.renderYAxis },
              Brush: { handler: x.renderBrush, once: !0 },
              Bar: { handler: x.renderGraphicChild },
              Line: { handler: x.renderGraphicChild },
              Area: { handler: x.renderGraphicChild },
              Radar: { handler: x.renderGraphicChild },
              RadialBar: { handler: x.renderGraphicChild },
              Scatter: { handler: x.renderGraphicChild },
              Pie: { handler: x.renderGraphicChild },
              Funnel: { handler: x.renderGraphicChild },
              Tooltip: { handler: x.renderCursor, once: !0 },
              PolarGrid: { handler: x.renderPolarGrid, once: !0 },
              PolarAngleAxis: { handler: x.renderPolarAxis },
              PolarRadiusAxis: { handler: x.renderPolarAxis },
              Customized: { handler: x.renderCustomized }
            }),
            (x.clipPathId = "".concat(
              (y = v.id) !== null && y !== void 0 ? y : Kd("recharts"),
              "-clip"
            )),
            (x.throttleTriggeredAfterMouseMove = aY(
              x.triggeredAfterMouseMove,
              (w = v.throttleDelay) !== null && w !== void 0 ? w : 1e3 / 60
            )),
            (x.state = {}),
            x
          )
        }
        return (
          uae(g, [
            {
              key: "componentDidMount",
              value: function () {
                var y, w
                this.addListener(),
                  this.accessibilityManager.setDetails({
                    container: this.container,
                    offset: {
                      left:
                        (y = this.props.margin.left) !== null && y !== void 0
                          ? y
                          : 0,
                      top:
                        (w = this.props.margin.top) !== null && w !== void 0
                          ? w
                          : 0
                    },
                    coordinateList: this.state.tooltipTicks,
                    mouseHandlerCallback: this.triggeredAfterMouseMove,
                    layout: this.props.layout
                  })
              }
            },
            {
              key: "getSnapshotBeforeUpdate",
              value: function (y, w) {
                if (!this.props.accessibilityLayer) return null
                if (
                  (this.state.tooltipTicks !== w.tooltipTicks &&
                    this.accessibilityManager.setDetails({
                      coordinateList: this.state.tooltipTicks
                    }),
                  this.props.layout !== y.layout &&
                    this.accessibilityManager.setDetails({
                      layout: this.props.layout
                    }),
                  this.props.margin !== y.margin)
                ) {
                  var x, S
                  this.accessibilityManager.setDetails({
                    offset: {
                      left:
                        (x = this.props.margin.left) !== null && x !== void 0
                          ? x
                          : 0,
                      top:
                        (S = this.props.margin.top) !== null && S !== void 0
                          ? S
                          : 0
                    }
                  })
                }
                return null
              }
            },
            { key: "componentDidUpdate", value: function () {} },
            {
              key: "componentWillUnmount",
              value: function () {
                this.removeListener(),
                  this.throttleTriggeredAfterMouseMove.cancel()
              }
            },
            {
              key: "getTooltipEventType",
              value: function () {
                var y = ur(this.props.children, Vi)
                if (y && typeof y.props.shared == "boolean") {
                  var w = y.props.shared ? "axis" : "item"
                  return l.indexOf(w) >= 0 ? w : a
                }
                return a
              }
            },
            {
              key: "getMouseInfo",
              value: function (y) {
                if (!this.container) return null
                var w = this.container,
                  x = w.getBoundingClientRect(),
                  S = pY(x),
                  O = {
                    chartX: Math.round(y.pageX - S.left),
                    chartY: Math.round(y.pageY - S.top)
                  },
                  $ = x.width / w.offsetWidth || 1,
                  A = this.inRange(O.chartX, O.chartY, $)
                if (!A) return null
                var C = this.state,
                  T = C.xAxisMap,
                  _ = C.yAxisMap,
                  R = this.getTooltipEventType()
                if (R !== "axis" && T && _) {
                  var M = Fr(T).scale,
                    D = Fr(_).scale,
                    N = M && M.invert ? M.invert(O.chartX) : null,
                    L = D && D.invert ? D.invert(O.chartY) : null
                  return B(B({}, O), {}, { xValue: N, yValue: L })
                }
                var k = AP(this.state, this.props.data, this.props.layout, A)
                return k ? B(B({}, O), k) : null
              }
            },
            {
              key: "inRange",
              value: function (y, w) {
                var x =
                    arguments.length > 2 && arguments[2] !== void 0
                      ? arguments[2]
                      : 1,
                  S = this.props.layout,
                  O = y / x,
                  $ = w / x
                if (S === "horizontal" || S === "vertical") {
                  var A = this.state.offset,
                    C =
                      O >= A.left &&
                      O <= A.left + A.width &&
                      $ >= A.top &&
                      $ <= A.top + A.height
                  return C ? { x: O, y: $ } : null
                }
                var T = this.state,
                  _ = T.angleAxisMap,
                  R = T.radiusAxisMap
                if (_ && R) {
                  var M = Fr(_)
                  return CO({ x: O, y: $ }, M)
                }
                return null
              }
            },
            {
              key: "parseEventsOfWrapper",
              value: function () {
                var y = this.props.children,
                  w = this.getTooltipEventType(),
                  x = ur(y, Vi),
                  S = {}
                x &&
                  w === "axis" &&
                  (x.props.trigger === "click"
                    ? (S = { onClick: this.handleClick })
                    : (S = {
                        onMouseEnter: this.handleMouseEnter,
                        onMouseMove: this.handleMouseMove,
                        onMouseLeave: this.handleMouseLeave,
                        onTouchMove: this.handleTouchMove,
                        onTouchStart: this.handleTouchStart,
                        onTouchEnd: this.handleTouchEnd
                      }))
                var O = cf(this.props, this.handleOuterEvent)
                return B(B({}, O), S)
              }
            },
            {
              key: "addListener",
              value: function () {
                Hh.on(Gh, this.handleReceiveSyncEvent)
              }
            },
            {
              key: "removeListener",
              value: function () {
                Hh.removeListener(Gh, this.handleReceiveSyncEvent)
              }
            },
            {
              key: "filterFormatItem",
              value: function (y, w, x) {
                for (
                  var S = this.state.formattedGraphicalItems,
                    O = 0,
                    $ = S.length;
                  O < $;
                  O++
                ) {
                  var A = S[O]
                  if (
                    A.item === y ||
                    A.props.key === y.key ||
                    (w === ai(A.item.type) && x === A.childIndex)
                  )
                    return A
                }
                return null
              }
            },
            {
              key: "renderAxis",
              value: function (y, w, x, S) {
                var O = this.props,
                  $ = O.width,
                  A = O.height
                return E.createElement(
                  Ls,
                  Ro({}, y, {
                    className: Oe(
                      "recharts-".concat(y.axisType, " ").concat(y.axisType),
                      y.className
                    ),
                    key: w.key || "".concat(x, "-").concat(S),
                    viewBox: { x: 0, y: 0, width: $, height: A },
                    ticksGenerator: this.axesTicksGenerator
                  })
                )
              }
            },
            {
              key: "renderClipPath",
              value: function () {
                var y = this.clipPathId,
                  w = this.state.offset,
                  x = w.left,
                  S = w.top,
                  O = w.height,
                  $ = w.width
                return E.createElement(
                  "defs",
                  null,
                  E.createElement(
                    "clipPath",
                    { id: y },
                    E.createElement("rect", { x, y: S, height: O, width: $ })
                  )
                )
              }
            },
            {
              key: "getXScales",
              value: function () {
                var y = this.state.xAxisMap
                return y
                  ? Object.entries(y).reduce(function (w, x) {
                      var S = SP(x, 2),
                        O = S[0],
                        $ = S[1]
                      return B(B({}, w), {}, Y({}, O, $.scale))
                    }, {})
                  : null
              }
            },
            {
              key: "getYScales",
              value: function () {
                var y = this.state.yAxisMap
                return y
                  ? Object.entries(y).reduce(function (w, x) {
                      var S = SP(x, 2),
                        O = S[0],
                        $ = S[1]
                      return B(B({}, w), {}, Y({}, O, $.scale))
                    }, {})
                  : null
              }
            },
            {
              key: "getXScaleByAxisId",
              value: function (y) {
                var w
                return (w = this.state.xAxisMap) === null ||
                  w === void 0 ||
                  (w = w[y]) === null ||
                  w === void 0
                  ? void 0
                  : w.scale
              }
            },
            {
              key: "getYScaleByAxisId",
              value: function (y) {
                var w
                return (w = this.state.yAxisMap) === null ||
                  w === void 0 ||
                  (w = w[y]) === null ||
                  w === void 0
                  ? void 0
                  : w.scale
              }
            },
            {
              key: "getItemByXY",
              value: function (y) {
                var w = this.state,
                  x = w.formattedGraphicalItems,
                  S = w.activeItem
                if (x && x.length)
                  for (var O = 0, $ = x.length; O < $; O++) {
                    var A = x[O],
                      C = A.props,
                      T = A.item,
                      _ = ai(T.type)
                    if (_ === "Bar") {
                      var R = (C.data || []).find(function (L) {
                        return ane(y, L)
                      })
                      if (R) return { graphicalItem: A, payload: R }
                    } else if (_ === "RadialBar") {
                      var M = (C.data || []).find(function (L) {
                        return CO(y, L)
                      })
                      if (M) return { graphicalItem: A, payload: M }
                    } else if (pp(A, S) || hp(A, S) || Dl(A, S)) {
                      var D = ure({
                          graphicalItem: A,
                          activeTooltipItem: S,
                          itemData: T.props.data
                        }),
                        N =
                          T.props.activeIndex === void 0
                            ? D
                            : T.props.activeIndex
                      return {
                        graphicalItem: B(B({}, A), {}, { childIndex: N }),
                        payload: Dl(A, S) ? T.props.data[D] : A.props.data[D]
                      }
                    }
                  }
                return null
              }
            },
            {
              key: "render",
              value: function () {
                var y = this
                if (!tw(this)) return null
                var w = this.props,
                  x = w.children,
                  S = w.className,
                  O = w.width,
                  $ = w.height,
                  A = w.style,
                  C = w.compact,
                  T = w.title,
                  _ = w.desc,
                  R = OP(w, rae),
                  M = he(R)
                if (C)
                  return E.createElement(
                    pv,
                    Ro({}, M, { width: O, height: $, title: T, desc: _ }),
                    this.renderClipPath(),
                    rw(x, this.renderMap)
                  )
                if (this.props.accessibilityLayer) {
                  var D, N
                  ;(M.tabIndex =
                    (D = this.props.tabIndex) !== null && D !== void 0 ? D : 0),
                    (M.role =
                      (N = this.props.role) !== null && N !== void 0
                        ? N
                        : "img"),
                    (M.onKeyDown = function (k) {
                      y.accessibilityManager.keyboardEvent(k)
                    }),
                    (M.onFocus = function () {
                      y.accessibilityManager.focus()
                    })
                }
                var L = this.parseEventsOfWrapper()
                return E.createElement(
                  "div",
                  Ro(
                    {
                      className: Oe("recharts-wrapper", S),
                      style: B(
                        {
                          position: "relative",
                          cursor: "default",
                          width: O,
                          height: $
                        },
                        A
                      )
                    },
                    L,
                    {
                      ref: function (I) {
                        y.container = I
                      },
                      role: "region"
                    }
                  ),
                  E.createElement(
                    pv,
                    Ro({}, M, {
                      width: O,
                      height: $,
                      title: T,
                      desc: _,
                      style: bae
                    }),
                    this.renderClipPath(),
                    rw(x, this.renderMap)
                  ),
                  this.renderLegend(),
                  this.renderTooltip()
                )
              }
            }
          ]),
          g
        )
      })(P.Component)),
      Y(n, "displayName", r),
      Y(
        n,
        "defaultProps",
        B(
          {
            layout: "horizontal",
            stackOffset: "none",
            barCategoryGap: "10%",
            barGap: 4,
            margin: { top: 5, right: 5, bottom: 5, left: 5 },
            reverseStackOrder: !1,
            syncMethod: "index"
          },
          d
        )
      ),
      Y(n, "getDerivedStateFromProps", function (m, b) {
        var g = m.dataKey,
          v = m.data,
          y = m.children,
          w = m.width,
          x = m.height,
          S = m.layout,
          O = m.stackOffset,
          $ = m.margin
        if (b.updateId === void 0) {
          var A = TP(m)
          return B(
            B(
              B({}, A),
              {},
              { updateId: 0 },
              h(B(B({ props: m }, A), {}, { updateId: 0 }), b)
            ),
            {},
            {
              prevDataKey: g,
              prevData: v,
              prevWidth: w,
              prevHeight: x,
              prevLayout: S,
              prevStackOffset: O,
              prevMargin: $,
              prevChildren: y
            }
          )
        }
        if (
          g !== b.prevDataKey ||
          v !== b.prevData ||
          w !== b.prevWidth ||
          x !== b.prevHeight ||
          S !== b.prevLayout ||
          O !== b.prevStackOffset ||
          !Ho($, b.prevMargin)
        ) {
          var C = TP(m),
            T = {
              chartX: b.chartX,
              chartY: b.chartY,
              isTooltipActive: b.isTooltipActive
            },
            _ = B(B({}, AP(b, v, S)), {}, { updateId: b.updateId + 1 }),
            R = B(B(B({}, C), T), _)
          return B(
            B(B({}, R), h(B({ props: m }, R), b)),
            {},
            {
              prevDataKey: g,
              prevData: v,
              prevWidth: w,
              prevHeight: x,
              prevLayout: S,
              prevStackOffset: O,
              prevMargin: $,
              prevChildren: y
            }
          )
        }
        if (!yC(y, b.prevChildren)) {
          var M = !xe(v),
            D = M ? b.updateId : b.updateId + 1
          return B(
            B(
              { updateId: D },
              h(B(B({ props: m }, b), {}, { updateId: D }), b)
            ),
            {},
            { prevChildren: y }
          )
        }
        return null
      }),
      Y(n, "renderActiveDot", function (m, b) {
        var g
        return (
          P.isValidElement(m)
            ? (g = P.cloneElement(m, b))
            : ce(m)
              ? (g = m(b))
              : (g = E.createElement(Dk, b)),
          E.createElement(
            ct,
            { className: "recharts-active-dot", key: b.key },
            g
          )
        )
      }),
      n
    )
  },
  Cae = Eae({
    chartName: "BarChart",
    GraphicalChild: Va,
    defaultTooltipEventType: "axis",
    validateTooltipEventTypes: ["axis", "item"],
    axisComponents: [
      { axisType: "xAxis", AxisComp: vp },
      { axisType: "yAxis", AxisComp: gp }
    ],
    formatAxisMap: jie
  })
const Y0 = ({ header: e, content: t, className: n, children: r, id: i }) =>
    j.jsxs("section", {
      id: i,
      className: ot(
        "mt-[100px] flex flex-col rounded-md border-2 border-b-4 p-6 md:mx-6 md:flex-row md:p-7 lg:p-8",
        n
      ),
      children: [
        j.jsxs("div", {
          className: "text-start",
          children: [
            j.jsx("h3", { className: "text-xl font-semibold", children: e }),
            j.jsx("div", {
              className: "text-muted-foreground mt-4",
              children: t
            })
          ]
        }),
        r
      ]
    }),
  _ae = () =>
    j.jsx(Y0, {
      className: "",
      header: "Ultra small bundle size",
      content: j.jsxs("p", {
        children: [
          j.jsx("span", {
            className: "text-foreground font-semibold",
            children: "TableX"
          }),
          ", thanks to",
          " ",
          j.jsx("a", {
            className: "text-white underline",
            href: "https://tauri.app/",
            target: "_blank",
            rel: "noreferrer",
            children: "tauri"
          }),
          ", produces a very small bundle size (~ 10 MB) compared to the alternatives."
        ]
      }),
      children: j.jsx("div", {
        className:
          "mt-4 flex h-full w-full items-center justify-center md:mt-0",
        children: j.jsx(kae, {})
      })
    }),
  kae = () => {
    const e = [
      { app: "TableX", size: 10 },
      { app: "PhpAdmin", size: 13 },
      { app: "TablePlus", size: 50 },
      { app: "PgAdmin4", size: 120 }
    ]
    return j.jsxs(Cae, {
      data: e,
      width: 400,
      height: 250,
      layout: "horizontal",
      children: [
        j.jsx(vp, { dataKey: "app", className: "text-sm " }),
        j.jsx(gp, {}),
        j.jsx(Vi, {
          wrapperClassName: "rounded-md text-muted-foreground",
          contentStyle: { background: "hsl(var(--background))" }
        }),
        j.jsx(Va, { dataKey: "size", fill: "white" })
      ]
    })
  },
  ps = ({ title: e, downloadLink: t }) =>
    j.jsxs("div", {
      className:
        "mt-6 flex w-full items-center justify-between gap-x-10 rounded-md border border-b-2 p-4 transition hover:-translate-y-2 hover:shadow-md hover:shadow-white md:mt-8 lg:mt-10",
      children: [
        j.jsx("h5", { children: e }),
        j.jsx("a", { className: Cd(), href: t, children: "Download" })
      ]
    })
function Mae(e) {
  const t = e + "CollectionProvider",
    [n, r] = Ta(t),
    [i, o] = n(t, { collectionRef: { current: null }, itemMap: new Map() }),
    a = (p) => {
      const { scope: h, children: m } = p,
        b = E.useRef(null),
        g = E.useRef(new Map()).current
      return E.createElement(i, { scope: h, itemMap: g, collectionRef: b }, m)
    },
    s = e + "CollectionSlot",
    l = E.forwardRef((p, h) => {
      const { scope: m, children: b } = p,
        g = o(s, m),
        v = Jt(h, g.collectionRef)
      return E.createElement(ia, { ref: v }, b)
    }),
    u = e + "CollectionItemSlot",
    f = "data-radix-collection-item",
    c = E.forwardRef((p, h) => {
      const { scope: m, children: b, ...g } = p,
        v = E.useRef(null),
        y = Jt(h, v),
        w = o(u, m)
      return (
        E.useEffect(
          () => (
            w.itemMap.set(v, { ref: v, ...g }), () => void w.itemMap.delete(v)
          )
        ),
        E.createElement(ia, { [f]: "", ref: y }, b)
      )
    })
  function d(p) {
    const h = o(e + "CollectionConsumer", p)
    return E.useCallback(() => {
      const b = h.collectionRef.current
      if (!b) return []
      const g = Array.from(b.querySelectorAll(`[${f}]`))
      return Array.from(h.itemMap.values()).sort(
        (w, x) => g.indexOf(w.ref.current) - g.indexOf(x.ref.current)
      )
    }, [h.collectionRef, h.itemMap])
  }
  return [{ Provider: a, Slot: l, ItemSlot: c }, d, r]
}
const jae = P.createContext(void 0)
function eM(e) {
  const t = P.useContext(jae)
  return e || t || "ltr"
}
const qh = "rovingFocusGroup.onEntryFocus",
  Dae = { bubbles: !1, cancelable: !0 },
  Q0 = "RovingFocusGroup",
  [wg, tM, Iae] = Mae(Q0),
  [Nae, nM] = Ta(Q0, [Iae]),
  [Rae, Lae] = Nae(Q0),
  Bae = P.forwardRef((e, t) =>
    P.createElement(
      wg.Provider,
      { scope: e.__scopeRovingFocusGroup },
      P.createElement(
        wg.Slot,
        { scope: e.__scopeRovingFocusGroup },
        P.createElement(Fae, se({}, e, { ref: t }))
      )
    )
  ),
  Fae = P.forwardRef((e, t) => {
    const {
        __scopeRovingFocusGroup: n,
        orientation: r,
        loop: i = !1,
        dir: o,
        currentTabStopId: a,
        defaultCurrentTabStopId: s,
        onCurrentTabStopIdChange: l,
        onEntryFocus: u,
        ...f
      } = e,
      c = P.useRef(null),
      d = Jt(t, c),
      p = eM(o),
      [h = null, m] = _d({ prop: a, defaultProp: s, onChange: l }),
      [b, g] = P.useState(!1),
      v = wr(u),
      y = tM(n),
      w = P.useRef(!1),
      [x, S] = P.useState(0)
    return (
      P.useEffect(() => {
        const O = c.current
        if (O)
          return O.addEventListener(qh, v), () => O.removeEventListener(qh, v)
      }, [v]),
      P.createElement(
        Rae,
        {
          scope: n,
          orientation: r,
          dir: p,
          loop: i,
          currentTabStopId: h,
          onItemFocus: P.useCallback((O) => m(O), [m]),
          onItemShiftTab: P.useCallback(() => g(!0), []),
          onFocusableItemAdd: P.useCallback(() => S((O) => O + 1), []),
          onFocusableItemRemove: P.useCallback(() => S((O) => O - 1), [])
        },
        P.createElement(
          dt.div,
          se({ tabIndex: b || x === 0 ? -1 : 0, "data-orientation": r }, f, {
            ref: d,
            style: { outline: "none", ...e.style },
            onMouseDown: Be(e.onMouseDown, () => {
              w.current = !0
            }),
            onFocus: Be(e.onFocus, (O) => {
              const $ = !w.current
              if (O.target === O.currentTarget && $ && !b) {
                const A = new CustomEvent(qh, Dae)
                if ((O.currentTarget.dispatchEvent(A), !A.defaultPrevented)) {
                  const C = y().filter((D) => D.focusable),
                    T = C.find((D) => D.active),
                    _ = C.find((D) => D.id === h),
                    M = [T, _, ...C].filter(Boolean).map((D) => D.ref.current)
                  rM(M)
                }
              }
              w.current = !1
            }),
            onBlur: Be(e.onBlur, () => g(!1))
          })
        )
      )
    )
  }),
  Vae = "RovingFocusGroupItem",
  zae = P.forwardRef((e, t) => {
    const {
        __scopeRovingFocusGroup: n,
        focusable: r = !0,
        active: i = !1,
        tabStopId: o,
        ...a
      } = e,
      s = Wo(),
      l = o || s,
      u = Lae(Vae, n),
      f = u.currentTabStopId === l,
      c = tM(n),
      { onFocusableItemAdd: d, onFocusableItemRemove: p } = u
    return (
      P.useEffect(() => {
        if (r) return d(), () => p()
      }, [r, d, p]),
      P.createElement(
        wg.ItemSlot,
        { scope: n, id: l, focusable: r, active: i },
        P.createElement(
          dt.span,
          se({ tabIndex: f ? 0 : -1, "data-orientation": u.orientation }, a, {
            ref: t,
            onMouseDown: Be(e.onMouseDown, (h) => {
              r ? u.onItemFocus(l) : h.preventDefault()
            }),
            onFocus: Be(e.onFocus, () => u.onItemFocus(l)),
            onKeyDown: Be(e.onKeyDown, (h) => {
              if (h.key === "Tab" && h.shiftKey) {
                u.onItemShiftTab()
                return
              }
              if (h.target !== h.currentTarget) return
              const m = Hae(h, u.orientation, u.dir)
              if (m !== void 0) {
                h.preventDefault()
                let g = c()
                  .filter((v) => v.focusable)
                  .map((v) => v.ref.current)
                if (m === "last") g.reverse()
                else if (m === "prev" || m === "next") {
                  m === "prev" && g.reverse()
                  const v = g.indexOf(h.currentTarget)
                  g = u.loop ? Gae(g, v + 1) : g.slice(v + 1)
                }
                setTimeout(() => rM(g))
              }
            })
          })
        )
      )
    )
  }),
  Uae = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  }
function Wae(e, t) {
  return t !== "rtl"
    ? e
    : e === "ArrowLeft"
      ? "ArrowRight"
      : e === "ArrowRight"
        ? "ArrowLeft"
        : e
}
function Hae(e, t, n) {
  const r = Wae(e.key, n)
  if (
    !(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) &&
    !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r))
  )
    return Uae[r]
}
function rM(e) {
  const t = document.activeElement
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return
}
function Gae(e, t) {
  return e.map((n, r) => e[(t + r) % e.length])
}
const Kae = Bae,
  qae = zae,
  iM = "Tabs",
  [Xae, Dle] = Ta(iM, [nM]),
  oM = nM(),
  [Yae, Z0] = Xae(iM),
  Qae = P.forwardRef((e, t) => {
    const {
        __scopeTabs: n,
        value: r,
        onValueChange: i,
        defaultValue: o,
        orientation: a = "horizontal",
        dir: s,
        activationMode: l = "automatic",
        ...u
      } = e,
      f = eM(s),
      [c, d] = _d({ prop: r, onChange: i, defaultProp: o })
    return P.createElement(
      Yae,
      {
        scope: n,
        baseId: Wo(),
        value: c,
        onValueChange: d,
        orientation: a,
        dir: f,
        activationMode: l
      },
      P.createElement(
        dt.div,
        se({ dir: f, "data-orientation": a }, u, { ref: t })
      )
    )
  }),
  Zae = "TabsList",
  Jae = P.forwardRef((e, t) => {
    const { __scopeTabs: n, loop: r = !0, ...i } = e,
      o = Z0(Zae, n),
      a = oM(n)
    return P.createElement(
      Kae,
      se({ asChild: !0 }, a, {
        orientation: o.orientation,
        dir: o.dir,
        loop: r
      }),
      P.createElement(
        dt.div,
        se({ role: "tablist", "aria-orientation": o.orientation }, i, {
          ref: t
        })
      )
    )
  }),
  ese = "TabsTrigger",
  tse = P.forwardRef((e, t) => {
    const { __scopeTabs: n, value: r, disabled: i = !1, ...o } = e,
      a = Z0(ese, n),
      s = oM(n),
      l = aM(a.baseId, r),
      u = sM(a.baseId, r),
      f = r === a.value
    return P.createElement(
      qae,
      se({ asChild: !0 }, s, { focusable: !i, active: f }),
      P.createElement(
        dt.button,
        se(
          {
            type: "button",
            role: "tab",
            "aria-selected": f,
            "aria-controls": u,
            "data-state": f ? "active" : "inactive",
            "data-disabled": i ? "" : void 0,
            disabled: i,
            id: l
          },
          o,
          {
            ref: t,
            onMouseDown: Be(e.onMouseDown, (c) => {
              !i && c.button === 0 && c.ctrlKey === !1
                ? a.onValueChange(r)
                : c.preventDefault()
            }),
            onKeyDown: Be(e.onKeyDown, (c) => {
              ;[" ", "Enter"].includes(c.key) && a.onValueChange(r)
            }),
            onFocus: Be(e.onFocus, () => {
              const c = a.activationMode !== "manual"
              !f && !i && c && a.onValueChange(r)
            })
          }
        )
      )
    )
  }),
  nse = "TabsContent",
  rse = P.forwardRef((e, t) => {
    const { __scopeTabs: n, value: r, forceMount: i, children: o, ...a } = e,
      s = Z0(nse, n),
      l = aM(s.baseId, r),
      u = sM(s.baseId, r),
      f = r === s.value,
      c = P.useRef(f)
    return (
      P.useEffect(() => {
        const d = requestAnimationFrame(() => (c.current = !1))
        return () => cancelAnimationFrame(d)
      }, []),
      P.createElement(Ea, { present: i || f }, ({ present: d }) =>
        P.createElement(
          dt.div,
          se(
            {
              "data-state": f ? "active" : "inactive",
              "data-orientation": s.orientation,
              role: "tabpanel",
              "aria-labelledby": l,
              hidden: !d,
              id: u,
              tabIndex: 0
            },
            a,
            {
              ref: t,
              style: {
                ...e.style,
                animationDuration: c.current ? "0s" : void 0
              }
            }
          ),
          d && o
        )
      )
    )
  })
function aM(e, t) {
  return `${e}-trigger-${t}`
}
function sM(e, t) {
  return `${e}-content-${t}`
}
const ise = Qae,
  lM = Jae,
  uM = tse,
  cM = rse,
  ose = ise,
  fM = P.forwardRef(({ className: e, ...t }, n) =>
    j.jsx(lM, {
      ref: n,
      className: ot(
        "bg-muted text-muted-foreground inline-flex h-10 items-center justify-center rounded-md p-1",
        e
      ),
      ...t
    })
  )
fM.displayName = lM.displayName
const $c = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx(uM, {
    ref: n,
    className: ot(
      "ring-offset-background focus-visible:ring-ring data-[state=active]:bg-background data-[state=active]:text-foreground inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm",
      e
    ),
    ...t
  })
)
$c.displayName = uM.displayName
const Ac = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx(cM, {
    ref: n,
    className: ot(
      "ring-offset-background focus-visible:ring-ring mt-2 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2",
      e
    ),
    ...t
  })
)
Ac.displayName = cM.displayName
const oc = "0.1.0",
  ase = () =>
    j.jsxs("section", {
      className: `mt-[100px] w-full space-y-7 md:space-y-9 lg:space-y-11
    `,
      children: [
        j.jsx("h3", {
          className:
            "text-center text-2xl font-bold underline underline-offset-4 md:text-3xl",
          id: "download",
          children: "Download"
        }),
        j.jsxs(ose, {
          defaultValue: "windows",
          className: "flex w-full flex-col items-center justify-center",
          children: [
            j.jsxs(fM, {
              className: "space-x-2",
              children: [
                j.jsxs($c, {
                  value: "windows",
                  children: [
                    j.jsx("img", {
                      src: "/icons/windows.svg",
                      alt: "windows",
                      className: "mr-2 h-4 w-4"
                    }),
                    "Windows"
                  ]
                }),
                j.jsx($c, { value: "macos", children: "macOS" }),
                j.jsxs($c, {
                  value: "linux",
                  children: [
                    j.jsx("img", {
                      src: "/icons/linux.svg",
                      alt: "linux",
                      className: "mr-2 h-4 w-4"
                    }),
                    "Linux"
                  ]
                })
              ]
            }),
            j.jsxs(Ac, {
              value: "windows",
              className: "w-2/3",
              children: [
                j.jsx(ps, {
                  title: "exe installer",
                  downloadLink: `https://github.com/kareemmahlees/tablex/releases/download/latest/TableX_${oc}_x64-setup.exe`
                }),
                j.jsx(ps, {
                  title: "msi installer",
                  downloadLink: `https://github.com/kareemmahlees/tablex/releases/download/latest/TableX_${oc}_x64_en-US.msi`
                })
              ]
            }),
            j.jsx(Ac, {
              value: "macos",
              className: "w-2/3",
              children: j.jsx(ps, {
                title: ".dmg",
                downloadLink: `https://github.com/kareemmahlees/tablex/releases/download/latest/TableX_${oc}_x64.dmg
`
              })
            }),
            j.jsxs(Ac, {
              value: "linux",
              className: "w-2/3",
              children: [
                j.jsx(ps, {
                  title: ".deb",
                  downloadLink: `https://github.com/kareemmahlees/tablex/releases/download/latest/table-x_${oc}_amd64.deb`
                }),
                j.jsx(ps, {
                  title: ".tar.gz",
                  downloadLink:
                    "https://github.com/kareemmahlees/tablex/releases/download/latest/TableX_x64.app.tar.gz"
                })
              ]
            })
          ]
        })
      ]
    }),
  dM = P.forwardRef(({ className: e, ...t }, n) =>
    j.jsx("div", {
      className: "relative w-full overflow-auto",
      children: j.jsx("table", {
        ref: n,
        className: ot("w-full caption-bottom text-sm", e),
        ...t
      })
    })
  )
dM.displayName = "Table"
const pM = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx("thead", { ref: n, className: ot("[&_tr]:border-b", e), ...t })
)
pM.displayName = "TableHeader"
const hM = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx("tbody", {
    ref: n,
    className: ot("[&_tr:last-child]:border-0", e),
    ...t
  })
)
hM.displayName = "TableBody"
const sse = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx("tfoot", {
    ref: n,
    className: ot("bg-muted/50 border-t font-medium [&>tr]:last:border-b-0", e),
    ...t
  })
)
sse.displayName = "TableFooter"
const Sg = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx("tr", {
    ref: n,
    className: ot(
      "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
      e
    ),
    ...t
  })
)
Sg.displayName = "TableRow"
const Og = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx("th", {
    ref: n,
    className: ot(
      "text-muted-foreground h-12 px-4 text-left align-middle font-medium [&:has([role=checkbox])]:pr-0",
      e
    ),
    ...t
  })
)
Og.displayName = "TableHead"
const Pg = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx("td", {
    ref: n,
    className: ot("p-4 align-middle [&:has([role=checkbox])]:pr-0", e),
    ...t
  })
)
Pg.displayName = "TableCell"
const mM = P.forwardRef(({ className: e, ...t }, n) =>
  j.jsx("caption", {
    ref: n,
    className: ot("text-muted-foreground mt-4 text-sm", e),
    ...t
  })
)
mM.displayName = "TableCaption"
const lse = () =>
    j.jsx(Y0, {
      className: "md:flex-col",
      header: "Keyboard shortcuts everywhere",
      content: j.jsxs("div", {
        children: [
          j.jsx("p", {
            children: "If you Love to use your keyboard very often, We Got you."
          }),
          j.jsx("br", {}),
          j.jsx("span", {
            className: "text-foreground font-semibold",
            children: "TableX"
          }),
          " is designed to be keyboard friendly from the start, while we don't have that much of shortcuts available right now, but more and more will be added soon."
        ]
      }),
      children: j.jsx(use, {})
    }),
  use = () => {
    const e = [
      {
        shortcut: j.jsxs("div", {
          children: [
            j.jsx("kbd", { children: "Ctrl" }),
            " + ",
            j.jsx("kbd", { children: "k" })
          ]
        }),
        description: "open command palette"
      },
      {
        shortcut: j.jsxs("div", {
          children: [
            j.jsx("kbd", { children: "Ctrl" }),
            " + ",
            j.jsx("kbd", { children: "s" })
          ]
        }),
        description: "focus search input"
      },
      {
        shortcut: j.jsxs("div", {
          children: [
            j.jsx("kbd", { children: "Ctrl" }),
            " + ",
            j.jsx("kbd", { children: "a" })
          ]
        }),
        description: "select or deselect all"
      },
      {
        shortcut: j.jsxs("div", {
          children: [
            j.jsx("kbd", { children: "Ctrl" }),
            " + ",
            j.jsx("kbd", { children: "c" })
          ]
        }),
        description: "copy selected rows into clipboard"
      },
      {
        shortcut: j.jsx("kbd", { children: "Delete" }),
        description: "delete selected rows"
      }
    ]
    return j.jsx("div", {
      className: "mt-4",
      children: j.jsxs(dM, {
        children: [
          j.jsx(mM, { children: "Available Keyboard shortcuts" }),
          j.jsx(pM, {
            children: j.jsxs(Sg, {
              children: [
                j.jsx(Og, { className: "", children: "Shortcut" }),
                j.jsx(Og, { className: "", children: "Description" })
              ]
            })
          }),
          j.jsx(hM, {
            children: e.map(({ shortcut: t, description: n }, r) =>
              j.jsxs(
                Sg,
                {
                  children: [
                    j.jsx(Pg, {
                      className: "whitespace-nowrap font-medium",
                      children: t
                    }),
                    j.jsx(Pg, { className: "font-medium", children: n })
                  ]
                },
                r
              )
            )
          })
        ]
      })
    })
  },
  cse = ["top", "right", "bottom", "left"],
  hi = Math.min,
  Gt = Math.max,
  nd = Math.round,
  ac = Math.floor,
  mi = (e) => ({ x: e, y: e }),
  fse = { left: "right", right: "left", bottom: "top", top: "bottom" },
  dse = { start: "end", end: "start" }
function $g(e, t, n) {
  return Gt(e, hi(t, n))
}
function $r(e, t) {
  return typeof e == "function" ? e(t) : e
}
function Ar(e) {
  return e.split("-")[0]
}
function za(e) {
  return e.split("-")[1]
}
function J0(e) {
  return e === "x" ? "y" : "x"
}
function eb(e) {
  return e === "y" ? "height" : "width"
}
function Ua(e) {
  return ["top", "bottom"].includes(Ar(e)) ? "y" : "x"
}
function tb(e) {
  return J0(Ua(e))
}
function pse(e, t, n) {
  n === void 0 && (n = !1)
  const r = za(e),
    i = tb(e),
    o = eb(i)
  let a =
    i === "x"
      ? r === (n ? "end" : "start")
        ? "right"
        : "left"
      : r === "start"
        ? "bottom"
        : "top"
  return t.reference[o] > t.floating[o] && (a = rd(a)), [a, rd(a)]
}
function hse(e) {
  const t = rd(e)
  return [Ag(e), t, Ag(t)]
}
function Ag(e) {
  return e.replace(/start|end/g, (t) => dse[t])
}
function mse(e, t, n) {
  const r = ["left", "right"],
    i = ["right", "left"],
    o = ["top", "bottom"],
    a = ["bottom", "top"]
  switch (e) {
    case "top":
    case "bottom":
      return n ? (t ? i : r) : t ? r : i
    case "left":
    case "right":
      return t ? o : a
    default:
      return []
  }
}
function vse(e, t, n, r) {
  const i = za(e)
  let o = mse(Ar(e), n === "start", r)
  return (
    i && ((o = o.map((a) => a + "-" + i)), t && (o = o.concat(o.map(Ag)))), o
  )
}
function rd(e) {
  return e.replace(/left|right|bottom|top/g, (t) => fse[t])
}
function gse(e) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...e }
}
function vM(e) {
  return typeof e != "number"
    ? gse(e)
    : { top: e, right: e, bottom: e, left: e }
}
function id(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  }
}
function CP(e, t, n) {
  let { reference: r, floating: i } = e
  const o = Ua(t),
    a = tb(t),
    s = eb(a),
    l = Ar(t),
    u = o === "y",
    f = r.x + r.width / 2 - i.width / 2,
    c = r.y + r.height / 2 - i.height / 2,
    d = r[s] / 2 - i[s] / 2
  let p
  switch (l) {
    case "top":
      p = { x: f, y: r.y - i.height }
      break
    case "bottom":
      p = { x: f, y: r.y + r.height }
      break
    case "right":
      p = { x: r.x + r.width, y: c }
      break
    case "left":
      p = { x: r.x - i.width, y: c }
      break
    default:
      p = { x: r.x, y: r.y }
  }
  switch (za(t)) {
    case "start":
      p[a] -= d * (n && u ? -1 : 1)
      break
    case "end":
      p[a] += d * (n && u ? -1 : 1)
      break
  }
  return p
}
const yse = async (e, t, n) => {
  const {
      placement: r = "bottom",
      strategy: i = "absolute",
      middleware: o = [],
      platform: a
    } = n,
    s = o.filter(Boolean),
    l = await (a.isRTL == null ? void 0 : a.isRTL(t))
  let u = await a.getElementRects({ reference: e, floating: t, strategy: i }),
    { x: f, y: c } = CP(u, r, l),
    d = r,
    p = {},
    h = 0
  for (let m = 0; m < s.length; m++) {
    const { name: b, fn: g } = s[m],
      {
        x: v,
        y,
        data: w,
        reset: x
      } = await g({
        x: f,
        y: c,
        initialPlacement: r,
        placement: d,
        strategy: i,
        middlewareData: p,
        rects: u,
        platform: a,
        elements: { reference: e, floating: t }
      })
    if (
      ((f = v ?? f),
      (c = y ?? c),
      (p = { ...p, [b]: { ...p[b], ...w } }),
      x && h <= 50)
    ) {
      h++,
        typeof x == "object" &&
          (x.placement && (d = x.placement),
          x.rects &&
            (u =
              x.rects === !0
                ? await a.getElementRects({
                    reference: e,
                    floating: t,
                    strategy: i
                  })
                : x.rects),
          ({ x: f, y: c } = CP(u, d, l))),
        (m = -1)
      continue
    }
  }
  return { x: f, y: c, placement: d, strategy: i, middlewareData: p }
}
async function Wl(e, t) {
  var n
  t === void 0 && (t = {})
  const { x: r, y: i, platform: o, rects: a, elements: s, strategy: l } = e,
    {
      boundary: u = "clippingAncestors",
      rootBoundary: f = "viewport",
      elementContext: c = "floating",
      altBoundary: d = !1,
      padding: p = 0
    } = $r(t, e),
    h = vM(p),
    b = s[d ? (c === "floating" ? "reference" : "floating") : c],
    g = id(
      await o.getClippingRect({
        element:
          (n = await (o.isElement == null ? void 0 : o.isElement(b))) == null ||
          n
            ? b
            : b.contextElement ||
              (await (o.getDocumentElement == null
                ? void 0
                : o.getDocumentElement(s.floating))),
        boundary: u,
        rootBoundary: f,
        strategy: l
      })
    ),
    v = c === "floating" ? { ...a.floating, x: r, y: i } : a.reference,
    y = await (o.getOffsetParent == null
      ? void 0
      : o.getOffsetParent(s.floating)),
    w = (await (o.isElement == null ? void 0 : o.isElement(y)))
      ? (await (o.getScale == null ? void 0 : o.getScale(y))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    x = id(
      o.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await o.convertOffsetParentRelativeRectToViewportRelativeRect({
            rect: v,
            offsetParent: y,
            strategy: l
          })
        : v
    )
  return {
    top: (g.top - x.top + h.top) / w.y,
    bottom: (x.bottom - g.bottom + h.bottom) / w.y,
    left: (g.left - x.left + h.left) / w.x,
    right: (x.right - g.right + h.right) / w.x
  }
}
const _P = (e) => ({
    name: "arrow",
    options: e,
    async fn(t) {
      const {
          x: n,
          y: r,
          placement: i,
          rects: o,
          platform: a,
          elements: s,
          middlewareData: l
        } = t,
        { element: u, padding: f = 0 } = $r(e, t) || {}
      if (u == null) return {}
      const c = vM(f),
        d = { x: n, y: r },
        p = tb(i),
        h = eb(p),
        m = await a.getDimensions(u),
        b = p === "y",
        g = b ? "top" : "left",
        v = b ? "bottom" : "right",
        y = b ? "clientHeight" : "clientWidth",
        w = o.reference[h] + o.reference[p] - d[p] - o.floating[h],
        x = d[p] - o.reference[p],
        S = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(u))
      let O = S ? S[y] : 0
      ;(!O || !(await (a.isElement == null ? void 0 : a.isElement(S)))) &&
        (O = s.floating[y] || o.floating[h])
      const $ = w / 2 - x / 2,
        A = O / 2 - m[h] / 2 - 1,
        C = hi(c[g], A),
        T = hi(c[v], A),
        _ = C,
        R = O - m[h] - T,
        M = O / 2 - m[h] / 2 + $,
        D = $g(_, M, R),
        N =
          !l.arrow &&
          za(i) != null &&
          M != D &&
          o.reference[h] / 2 - (M < _ ? C : T) - m[h] / 2 < 0,
        L = N ? (M < _ ? M - _ : M - R) : 0
      return {
        [p]: d[p] + L,
        data: {
          [p]: D,
          centerOffset: M - D - L,
          ...(N && { alignmentOffset: L })
        },
        reset: N
      }
    }
  }),
  bse = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: "flip",
        options: e,
        async fn(t) {
          var n, r
          const {
              placement: i,
              middlewareData: o,
              rects: a,
              initialPlacement: s,
              platform: l,
              elements: u
            } = t,
            {
              mainAxis: f = !0,
              crossAxis: c = !0,
              fallbackPlacements: d,
              fallbackStrategy: p = "bestFit",
              fallbackAxisSideDirection: h = "none",
              flipAlignment: m = !0,
              ...b
            } = $r(e, t)
          if ((n = o.arrow) != null && n.alignmentOffset) return {}
          const g = Ar(i),
            v = Ar(s) === s,
            y = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)),
            w = d || (v || !m ? [rd(s)] : hse(s))
          !d && h !== "none" && w.push(...vse(s, m, h, y))
          const x = [s, ...w],
            S = await Wl(t, b),
            O = []
          let $ = ((r = o.flip) == null ? void 0 : r.overflows) || []
          if ((f && O.push(S[g]), c)) {
            const _ = pse(i, a, y)
            O.push(S[_[0]], S[_[1]])
          }
          if (
            (($ = [...$, { placement: i, overflows: O }]),
            !O.every((_) => _ <= 0))
          ) {
            var A, C
            const _ = (((A = o.flip) == null ? void 0 : A.index) || 0) + 1,
              R = x[_]
            if (R)
              return {
                data: { index: _, overflows: $ },
                reset: { placement: R }
              }
            let M =
              (C = $.filter((D) => D.overflows[0] <= 0).sort(
                (D, N) => D.overflows[1] - N.overflows[1]
              )[0]) == null
                ? void 0
                : C.placement
            if (!M)
              switch (p) {
                case "bestFit": {
                  var T
                  const D =
                    (T = $.map((N) => [
                      N.placement,
                      N.overflows
                        .filter((L) => L > 0)
                        .reduce((L, k) => L + k, 0)
                    ]).sort((N, L) => N[1] - L[1])[0]) == null
                      ? void 0
                      : T[0]
                  D && (M = D)
                  break
                }
                case "initialPlacement":
                  M = s
                  break
              }
            if (i !== M) return { reset: { placement: M } }
          }
          return {}
        }
      }
    )
  }
function kP(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  }
}
function MP(e) {
  return cse.some((t) => e[t] >= 0)
}
const xse = function (e) {
  return (
    e === void 0 && (e = {}),
    {
      name: "hide",
      options: e,
      async fn(t) {
        const { rects: n } = t,
          { strategy: r = "referenceHidden", ...i } = $r(e, t)
        switch (r) {
          case "referenceHidden": {
            const o = await Wl(t, { ...i, elementContext: "reference" }),
              a = kP(o, n.reference)
            return {
              data: { referenceHiddenOffsets: a, referenceHidden: MP(a) }
            }
          }
          case "escaped": {
            const o = await Wl(t, { ...i, altBoundary: !0 }),
              a = kP(o, n.floating)
            return { data: { escapedOffsets: a, escaped: MP(a) } }
          }
          default:
            return {}
        }
      }
    }
  )
}
async function wse(e, t) {
  const { placement: n, platform: r, elements: i } = e,
    o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)),
    a = Ar(n),
    s = za(n),
    l = Ua(n) === "y",
    u = ["left", "top"].includes(a) ? -1 : 1,
    f = o && l ? -1 : 1,
    c = $r(t, e)
  let {
    mainAxis: d,
    crossAxis: p,
    alignmentAxis: h
  } = typeof c == "number"
    ? { mainAxis: c, crossAxis: 0, alignmentAxis: null }
    : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...c }
  return (
    s && typeof h == "number" && (p = s === "end" ? h * -1 : h),
    l ? { x: p * f, y: d * u } : { x: d * u, y: p * f }
  )
}
const Sse = function (e) {
    return (
      e === void 0 && (e = 0),
      {
        name: "offset",
        options: e,
        async fn(t) {
          var n, r
          const { x: i, y: o, placement: a, middlewareData: s } = t,
            l = await wse(t, e)
          return a === ((n = s.offset) == null ? void 0 : n.placement) &&
            (r = s.arrow) != null &&
            r.alignmentOffset
            ? {}
            : { x: i + l.x, y: o + l.y, data: { ...l, placement: a } }
        }
      }
    )
  },
  Ose = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: "shift",
        options: e,
        async fn(t) {
          const { x: n, y: r, placement: i } = t,
            {
              mainAxis: o = !0,
              crossAxis: a = !1,
              limiter: s = {
                fn: (b) => {
                  let { x: g, y: v } = b
                  return { x: g, y: v }
                }
              },
              ...l
            } = $r(e, t),
            u = { x: n, y: r },
            f = await Wl(t, l),
            c = Ua(Ar(i)),
            d = J0(c)
          let p = u[d],
            h = u[c]
          if (o) {
            const b = d === "y" ? "top" : "left",
              g = d === "y" ? "bottom" : "right",
              v = p + f[b],
              y = p - f[g]
            p = $g(v, p, y)
          }
          if (a) {
            const b = c === "y" ? "top" : "left",
              g = c === "y" ? "bottom" : "right",
              v = h + f[b],
              y = h - f[g]
            h = $g(v, h, y)
          }
          const m = s.fn({ ...t, [d]: p, [c]: h })
          return { ...m, data: { x: m.x - n, y: m.y - r } }
        }
      }
    )
  },
  Pse = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        options: e,
        fn(t) {
          const { x: n, y: r, placement: i, rects: o, middlewareData: a } = t,
            { offset: s = 0, mainAxis: l = !0, crossAxis: u = !0 } = $r(e, t),
            f = { x: n, y: r },
            c = Ua(i),
            d = J0(c)
          let p = f[d],
            h = f[c]
          const m = $r(s, t),
            b =
              typeof m == "number"
                ? { mainAxis: m, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...m }
          if (l) {
            const y = d === "y" ? "height" : "width",
              w = o.reference[d] - o.floating[y] + b.mainAxis,
              x = o.reference[d] + o.reference[y] - b.mainAxis
            p < w ? (p = w) : p > x && (p = x)
          }
          if (u) {
            var g, v
            const y = d === "y" ? "width" : "height",
              w = ["top", "left"].includes(Ar(i)),
              x =
                o.reference[c] -
                o.floating[y] +
                ((w && ((g = a.offset) == null ? void 0 : g[c])) || 0) +
                (w ? 0 : b.crossAxis),
              S =
                o.reference[c] +
                o.reference[y] +
                (w ? 0 : ((v = a.offset) == null ? void 0 : v[c]) || 0) -
                (w ? b.crossAxis : 0)
            h < x ? (h = x) : h > S && (h = S)
          }
          return { [d]: p, [c]: h }
        }
      }
    )
  },
  $se = function (e) {
    return (
      e === void 0 && (e = {}),
      {
        name: "size",
        options: e,
        async fn(t) {
          const { placement: n, rects: r, platform: i, elements: o } = t,
            { apply: a = () => {}, ...s } = $r(e, t),
            l = await Wl(t, s),
            u = Ar(n),
            f = za(n),
            c = Ua(n) === "y",
            { width: d, height: p } = r.floating
          let h, m
          u === "top" || u === "bottom"
            ? ((h = u),
              (m =
                f ===
                ((await (i.isRTL == null ? void 0 : i.isRTL(o.floating)))
                  ? "start"
                  : "end")
                  ? "left"
                  : "right"))
            : ((m = u), (h = f === "end" ? "top" : "bottom"))
          const b = p - l[h],
            g = d - l[m],
            v = !t.middlewareData.shift
          let y = b,
            w = g
          if (c) {
            const S = d - l.left - l.right
            w = f || v ? hi(g, S) : S
          } else {
            const S = p - l.top - l.bottom
            y = f || v ? hi(b, S) : S
          }
          if (v && !f) {
            const S = Gt(l.left, 0),
              O = Gt(l.right, 0),
              $ = Gt(l.top, 0),
              A = Gt(l.bottom, 0)
            c
              ? (w = d - 2 * (S !== 0 || O !== 0 ? S + O : Gt(l.left, l.right)))
              : (y = p - 2 * ($ !== 0 || A !== 0 ? $ + A : Gt(l.top, l.bottom)))
          }
          await a({ ...t, availableWidth: w, availableHeight: y })
          const x = await i.getDimensions(o.floating)
          return d !== x.width || p !== x.height ? { reset: { rects: !0 } } : {}
        }
      }
    )
  }
function vi(e) {
  return gM(e) ? (e.nodeName || "").toLowerCase() : "#document"
}
function Yt(e) {
  var t
  return (
    (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) ||
    window
  )
}
function Mr(e) {
  var t
  return (t = (gM(e) ? e.ownerDocument : e.document) || window.document) == null
    ? void 0
    : t.documentElement
}
function gM(e) {
  return e instanceof Node || e instanceof Yt(e).Node
}
function Tr(e) {
  return e instanceof Element || e instanceof Yt(e).Element
}
function Qn(e) {
  return e instanceof HTMLElement || e instanceof Yt(e).HTMLElement
}
function jP(e) {
  return typeof ShadowRoot > "u"
    ? !1
    : e instanceof ShadowRoot || e instanceof Yt(e).ShadowRoot
}
function pu(e) {
  const { overflow: t, overflowX: n, overflowY: r, display: i } = bn(e)
  return (
    /auto|scroll|overlay|hidden|clip/.test(t + r + n) &&
    !["inline", "contents"].includes(i)
  )
}
function Ase(e) {
  return ["table", "td", "th"].includes(vi(e))
}
function nb(e) {
  const t = rb(),
    n = bn(e)
  return (
    n.transform !== "none" ||
    n.perspective !== "none" ||
    (n.containerType ? n.containerType !== "normal" : !1) ||
    (!t && (n.backdropFilter ? n.backdropFilter !== "none" : !1)) ||
    (!t && (n.filter ? n.filter !== "none" : !1)) ||
    ["transform", "perspective", "filter"].some((r) =>
      (n.willChange || "").includes(r)
    ) ||
    ["paint", "layout", "strict", "content"].some((r) =>
      (n.contain || "").includes(r)
    )
  )
}
function Tse(e) {
  let t = Sa(e)
  for (; Qn(t) && !bp(t); ) {
    if (nb(t)) return t
    t = Sa(t)
  }
  return null
}
function rb() {
  return typeof CSS > "u" || !CSS.supports
    ? !1
    : CSS.supports("-webkit-backdrop-filter", "none")
}
function bp(e) {
  return ["html", "body", "#document"].includes(vi(e))
}
function bn(e) {
  return Yt(e).getComputedStyle(e)
}
function xp(e) {
  return Tr(e)
    ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop }
    : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset }
}
function Sa(e) {
  if (vi(e) === "html") return e
  const t = e.assignedSlot || e.parentNode || (jP(e) && e.host) || Mr(e)
  return jP(t) ? t.host : t
}
function yM(e) {
  const t = Sa(e)
  return bp(t)
    ? e.ownerDocument
      ? e.ownerDocument.body
      : e.body
    : Qn(t) && pu(t)
      ? t
      : yM(t)
}
function Hl(e, t, n) {
  var r
  t === void 0 && (t = []), n === void 0 && (n = !0)
  const i = yM(e),
    o = i === ((r = e.ownerDocument) == null ? void 0 : r.body),
    a = Yt(i)
  return o
    ? t.concat(
        a,
        a.visualViewport || [],
        pu(i) ? i : [],
        a.frameElement && n ? Hl(a.frameElement) : []
      )
    : t.concat(i, Hl(i, [], n))
}
function bM(e) {
  const t = bn(e)
  let n = parseFloat(t.width) || 0,
    r = parseFloat(t.height) || 0
  const i = Qn(e),
    o = i ? e.offsetWidth : n,
    a = i ? e.offsetHeight : r,
    s = nd(n) !== o || nd(r) !== a
  return s && ((n = o), (r = a)), { width: n, height: r, $: s }
}
function ib(e) {
  return Tr(e) ? e : e.contextElement
}
function qo(e) {
  const t = ib(e)
  if (!Qn(t)) return mi(1)
  const n = t.getBoundingClientRect(),
    { width: r, height: i, $: o } = bM(t)
  let a = (o ? nd(n.width) : n.width) / r,
    s = (o ? nd(n.height) : n.height) / i
  return (
    (!a || !Number.isFinite(a)) && (a = 1),
    (!s || !Number.isFinite(s)) && (s = 1),
    { x: a, y: s }
  )
}
const Ese = mi(0)
function xM(e) {
  const t = Yt(e)
  return !rb() || !t.visualViewport
    ? Ese
    : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop }
}
function Cse(e, t, n) {
  return t === void 0 && (t = !1), !n || (t && n !== Yt(e)) ? !1 : t
}
function no(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1)
  const i = e.getBoundingClientRect(),
    o = ib(e)
  let a = mi(1)
  t && (r ? Tr(r) && (a = qo(r)) : (a = qo(e)))
  const s = Cse(o, n, r) ? xM(o) : mi(0)
  let l = (i.left + s.x) / a.x,
    u = (i.top + s.y) / a.y,
    f = i.width / a.x,
    c = i.height / a.y
  if (o) {
    const d = Yt(o),
      p = r && Tr(r) ? Yt(r) : r
    let h = d.frameElement
    for (; h && r && p !== d; ) {
      const m = qo(h),
        b = h.getBoundingClientRect(),
        g = bn(h),
        v = b.left + (h.clientLeft + parseFloat(g.paddingLeft)) * m.x,
        y = b.top + (h.clientTop + parseFloat(g.paddingTop)) * m.y
      ;(l *= m.x),
        (u *= m.y),
        (f *= m.x),
        (c *= m.y),
        (l += v),
        (u += y),
        (h = Yt(h).frameElement)
    }
  }
  return id({ width: f, height: c, x: l, y: u })
}
function _se(e) {
  let { rect: t, offsetParent: n, strategy: r } = e
  const i = Qn(n),
    o = Mr(n)
  if (n === o) return t
  let a = { scrollLeft: 0, scrollTop: 0 },
    s = mi(1)
  const l = mi(0)
  if (
    (i || (!i && r !== "fixed")) &&
    ((vi(n) !== "body" || pu(o)) && (a = xp(n)), Qn(n))
  ) {
    const u = no(n)
    ;(s = qo(n)), (l.x = u.x + n.clientLeft), (l.y = u.y + n.clientTop)
  }
  return {
    width: t.width * s.x,
    height: t.height * s.y,
    x: t.x * s.x - a.scrollLeft * s.x + l.x,
    y: t.y * s.y - a.scrollTop * s.y + l.y
  }
}
function kse(e) {
  return Array.from(e.getClientRects())
}
function wM(e) {
  return no(Mr(e)).left + xp(e).scrollLeft
}
function Mse(e) {
  const t = Mr(e),
    n = xp(e),
    r = e.ownerDocument.body,
    i = Gt(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth),
    o = Gt(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight)
  let a = -n.scrollLeft + wM(e)
  const s = -n.scrollTop
  return (
    bn(r).direction === "rtl" && (a += Gt(t.clientWidth, r.clientWidth) - i),
    { width: i, height: o, x: a, y: s }
  )
}
function jse(e, t) {
  const n = Yt(e),
    r = Mr(e),
    i = n.visualViewport
  let o = r.clientWidth,
    a = r.clientHeight,
    s = 0,
    l = 0
  if (i) {
    ;(o = i.width), (a = i.height)
    const u = rb()
    ;(!u || (u && t === "fixed")) && ((s = i.offsetLeft), (l = i.offsetTop))
  }
  return { width: o, height: a, x: s, y: l }
}
function Dse(e, t) {
  const n = no(e, !0, t === "fixed"),
    r = n.top + e.clientTop,
    i = n.left + e.clientLeft,
    o = Qn(e) ? qo(e) : mi(1),
    a = e.clientWidth * o.x,
    s = e.clientHeight * o.y,
    l = i * o.x,
    u = r * o.y
  return { width: a, height: s, x: l, y: u }
}
function DP(e, t, n) {
  let r
  if (t === "viewport") r = jse(e, n)
  else if (t === "document") r = Mse(Mr(e))
  else if (Tr(t)) r = Dse(t, n)
  else {
    const i = xM(e)
    r = { ...t, x: t.x - i.x, y: t.y - i.y }
  }
  return id(r)
}
function SM(e, t) {
  const n = Sa(e)
  return n === t || !Tr(n) || bp(n)
    ? !1
    : bn(n).position === "fixed" || SM(n, t)
}
function Ise(e, t) {
  const n = t.get(e)
  if (n) return n
  let r = Hl(e, [], !1).filter((s) => Tr(s) && vi(s) !== "body"),
    i = null
  const o = bn(e).position === "fixed"
  let a = o ? Sa(e) : e
  for (; Tr(a) && !bp(a); ) {
    const s = bn(a),
      l = nb(a)
    !l && s.position === "fixed" && (i = null),
      (
        o
          ? !l && !i
          : (!l &&
              s.position === "static" &&
              !!i &&
              ["absolute", "fixed"].includes(i.position)) ||
            (pu(a) && !l && SM(e, a))
      )
        ? (r = r.filter((f) => f !== a))
        : (i = s),
      (a = Sa(a))
  }
  return t.set(e, r), r
}
function Nse(e) {
  let { element: t, boundary: n, rootBoundary: r, strategy: i } = e
  const a = [
      ...(n === "clippingAncestors" ? Ise(t, this._c) : [].concat(n)),
      r
    ],
    s = a[0],
    l = a.reduce(
      (u, f) => {
        const c = DP(t, f, i)
        return (
          (u.top = Gt(c.top, u.top)),
          (u.right = hi(c.right, u.right)),
          (u.bottom = hi(c.bottom, u.bottom)),
          (u.left = Gt(c.left, u.left)),
          u
        )
      },
      DP(t, s, i)
    )
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  }
}
function Rse(e) {
  return bM(e)
}
function Lse(e, t, n) {
  const r = Qn(t),
    i = Mr(t),
    o = n === "fixed",
    a = no(e, !0, o, t)
  let s = { scrollLeft: 0, scrollTop: 0 }
  const l = mi(0)
  if (r || (!r && !o))
    if (((vi(t) !== "body" || pu(i)) && (s = xp(t)), r)) {
      const u = no(t, !0, o, t)
      ;(l.x = u.x + t.clientLeft), (l.y = u.y + t.clientTop)
    } else i && (l.x = wM(i))
  return {
    x: a.left + s.scrollLeft - l.x,
    y: a.top + s.scrollTop - l.y,
    width: a.width,
    height: a.height
  }
}
function IP(e, t) {
  return !Qn(e) || bn(e).position === "fixed" ? null : t ? t(e) : e.offsetParent
}
function OM(e, t) {
  const n = Yt(e)
  if (!Qn(e)) return n
  let r = IP(e, t)
  for (; r && Ase(r) && bn(r).position === "static"; ) r = IP(r, t)
  return r &&
    (vi(r) === "html" ||
      (vi(r) === "body" && bn(r).position === "static" && !nb(r)))
    ? n
    : r || Tse(e) || n
}
const Bse = async function (e) {
  let { reference: t, floating: n, strategy: r } = e
  const i = this.getOffsetParent || OM,
    o = this.getDimensions
  return {
    reference: Lse(t, await i(n), r),
    floating: { x: 0, y: 0, ...(await o(n)) }
  }
}
function Fse(e) {
  return bn(e).direction === "rtl"
}
const Vse = {
  convertOffsetParentRelativeRectToViewportRelativeRect: _se,
  getDocumentElement: Mr,
  getClippingRect: Nse,
  getOffsetParent: OM,
  getElementRects: Bse,
  getClientRects: kse,
  getDimensions: Rse,
  getScale: qo,
  isElement: Tr,
  isRTL: Fse
}
function zse(e, t) {
  let n = null,
    r
  const i = Mr(e)
  function o() {
    clearTimeout(r), n && n.disconnect(), (n = null)
  }
  function a(s, l) {
    s === void 0 && (s = !1), l === void 0 && (l = 1), o()
    const { left: u, top: f, width: c, height: d } = e.getBoundingClientRect()
    if ((s || t(), !c || !d)) return
    const p = ac(f),
      h = ac(i.clientWidth - (u + c)),
      m = ac(i.clientHeight - (f + d)),
      b = ac(u),
      v = {
        rootMargin: -p + "px " + -h + "px " + -m + "px " + -b + "px",
        threshold: Gt(0, hi(1, l)) || 1
      }
    let y = !0
    function w(x) {
      const S = x[0].intersectionRatio
      if (S !== l) {
        if (!y) return a()
        S
          ? a(!1, S)
          : (r = setTimeout(() => {
              a(!1, 1e-7)
            }, 100))
      }
      y = !1
    }
    try {
      n = new IntersectionObserver(w, { ...v, root: i.ownerDocument })
    } catch {
      n = new IntersectionObserver(w, v)
    }
    n.observe(e)
  }
  return a(!0), o
}
function Use(e, t, n, r) {
  r === void 0 && (r = {})
  const {
      ancestorScroll: i = !0,
      ancestorResize: o = !0,
      elementResize: a = typeof ResizeObserver == "function",
      layoutShift: s = typeof IntersectionObserver == "function",
      animationFrame: l = !1
    } = r,
    u = ib(e),
    f = i || o ? [...(u ? Hl(u) : []), ...Hl(t)] : []
  f.forEach((g) => {
    i && g.addEventListener("scroll", n, { passive: !0 }),
      o && g.addEventListener("resize", n)
  })
  const c = u && s ? zse(u, n) : null
  let d = -1,
    p = null
  a &&
    ((p = new ResizeObserver((g) => {
      let [v] = g
      v &&
        v.target === u &&
        p &&
        (p.unobserve(t),
        cancelAnimationFrame(d),
        (d = requestAnimationFrame(() => {
          p && p.observe(t)
        }))),
        n()
    })),
    u && !l && p.observe(u),
    p.observe(t))
  let h,
    m = l ? no(e) : null
  l && b()
  function b() {
    const g = no(e)
    m &&
      (g.x !== m.x ||
        g.y !== m.y ||
        g.width !== m.width ||
        g.height !== m.height) &&
      n(),
      (m = g),
      (h = requestAnimationFrame(b))
  }
  return (
    n(),
    () => {
      f.forEach((g) => {
        i && g.removeEventListener("scroll", n),
          o && g.removeEventListener("resize", n)
      }),
        c && c(),
        p && p.disconnect(),
        (p = null),
        l && cancelAnimationFrame(h)
    }
  )
}
const Wse = (e, t, n) => {
    const r = new Map(),
      i = { platform: Vse, ...n },
      o = { ...i.platform, _c: r }
    return yse(e, t, { ...i, platform: o })
  },
  Hse = (e) => {
    function t(n) {
      return {}.hasOwnProperty.call(n, "current")
    }
    return {
      name: "arrow",
      options: e,
      fn(n) {
        const { element: r, padding: i } = typeof e == "function" ? e(n) : e
        return r && t(r)
          ? r.current != null
            ? _P({ element: r.current, padding: i }).fn(n)
            : {}
          : r
            ? _P({ element: r, padding: i }).fn(n)
            : {}
      }
    }
  }
var Tc = typeof document < "u" ? P.useLayoutEffect : P.useEffect
function od(e, t) {
  if (e === t) return !0
  if (typeof e != typeof t) return !1
  if (typeof e == "function" && e.toString() === t.toString()) return !0
  let n, r, i
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (((n = e.length), n != t.length)) return !1
      for (r = n; r-- !== 0; ) if (!od(e[r], t[r])) return !1
      return !0
    }
    if (((i = Object.keys(e)), (n = i.length), n !== Object.keys(t).length))
      return !1
    for (r = n; r-- !== 0; ) if (!{}.hasOwnProperty.call(t, i[r])) return !1
    for (r = n; r-- !== 0; ) {
      const o = i[r]
      if (!(o === "_owner" && e.$$typeof) && !od(e[o], t[o])) return !1
    }
    return !0
  }
  return e !== e && t !== t
}
function PM(e) {
  return typeof window > "u"
    ? 1
    : (e.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function NP(e, t) {
  const n = PM(e)
  return Math.round(t * n) / n
}
function RP(e) {
  const t = P.useRef(e)
  return (
    Tc(() => {
      t.current = e
    }),
    t
  )
}
function Gse(e) {
  e === void 0 && (e = {})
  const {
      placement: t = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: i,
      elements: { reference: o, floating: a } = {},
      transform: s = !0,
      whileElementsMounted: l,
      open: u
    } = e,
    [f, c] = P.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1
    }),
    [d, p] = P.useState(r)
  od(d, r) || p(r)
  const [h, m] = P.useState(null),
    [b, g] = P.useState(null),
    v = P.useCallback(
      (N) => {
        N != S.current && ((S.current = N), m(N))
      },
      [m]
    ),
    y = P.useCallback(
      (N) => {
        N !== O.current && ((O.current = N), g(N))
      },
      [g]
    ),
    w = o || h,
    x = a || b,
    S = P.useRef(null),
    O = P.useRef(null),
    $ = P.useRef(f),
    A = RP(l),
    C = RP(i),
    T = P.useCallback(() => {
      if (!S.current || !O.current) return
      const N = { placement: t, strategy: n, middleware: d }
      C.current && (N.platform = C.current),
        Wse(S.current, O.current, N).then((L) => {
          const k = { ...L, isPositioned: !0 }
          _.current &&
            !od($.current, k) &&
            (($.current = k),
            Zl.flushSync(() => {
              c(k)
            }))
        })
    }, [d, t, n, C])
  Tc(() => {
    u === !1 &&
      $.current.isPositioned &&
      (($.current.isPositioned = !1), c((N) => ({ ...N, isPositioned: !1 })))
  }, [u])
  const _ = P.useRef(!1)
  Tc(
    () => (
      (_.current = !0),
      () => {
        _.current = !1
      }
    ),
    []
  ),
    Tc(() => {
      if ((w && (S.current = w), x && (O.current = x), w && x)) {
        if (A.current) return A.current(w, x, T)
        T()
      }
    }, [w, x, T, A])
  const R = P.useMemo(
      () => ({ reference: S, floating: O, setReference: v, setFloating: y }),
      [v, y]
    ),
    M = P.useMemo(() => ({ reference: w, floating: x }), [w, x]),
    D = P.useMemo(() => {
      const N = { position: n, left: 0, top: 0 }
      if (!M.floating) return N
      const L = NP(M.floating, f.x),
        k = NP(M.floating, f.y)
      return s
        ? {
            ...N,
            transform: "translate(" + L + "px, " + k + "px)",
            ...(PM(M.floating) >= 1.5 && { willChange: "transform" })
          }
        : { position: n, left: L, top: k }
    }, [n, s, M.floating, f.x, f.y])
  return P.useMemo(
    () => ({ ...f, update: T, refs: R, elements: M, floatingStyles: D }),
    [f, T, R, M, D]
  )
}
function Kse(e) {
  const [t, n] = P.useState(void 0)
  return (
    oa(() => {
      if (e) {
        n({ width: e.offsetWidth, height: e.offsetHeight })
        const r = new ResizeObserver((i) => {
          if (!Array.isArray(i) || !i.length) return
          const o = i[0]
          let a, s
          if ("borderBoxSize" in o) {
            const l = o.borderBoxSize,
              u = Array.isArray(l) ? l[0] : l
            ;(a = u.inlineSize), (s = u.blockSize)
          } else (a = e.offsetWidth), (s = e.offsetHeight)
          n({ width: a, height: s })
        })
        return r.observe(e, { box: "border-box" }), () => r.unobserve(e)
      } else n(void 0)
    }, [e]),
    t
  )
}
const $M = "Popper",
  [AM, TM] = Ta($M),
  [qse, EM] = AM($M),
  Xse = (e) => {
    const { __scopePopper: t, children: n } = e,
      [r, i] = P.useState(null)
    return P.createElement(qse, { scope: t, anchor: r, onAnchorChange: i }, n)
  },
  Yse = "PopperAnchor",
  Qse = P.forwardRef((e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e,
      o = EM(Yse, n),
      a = P.useRef(null),
      s = Jt(t, a)
    return (
      P.useEffect(() => {
        o.onAnchorChange((r == null ? void 0 : r.current) || a.current)
      }),
      r ? null : P.createElement(dt.div, se({}, i, { ref: s }))
    )
  }),
  CM = "PopperContent",
  [Zse, Ile] = AM(CM),
  Jse = P.forwardRef((e, t) => {
    var n, r, i, o, a, s, l, u
    const {
        __scopePopper: f,
        side: c = "bottom",
        sideOffset: d = 0,
        align: p = "center",
        alignOffset: h = 0,
        arrowPadding: m = 0,
        avoidCollisions: b = !0,
        collisionBoundary: g = [],
        collisionPadding: v = 0,
        sticky: y = "partial",
        hideWhenDetached: w = !1,
        updatePositionStrategy: x = "optimized",
        onPlaced: S,
        ...O
      } = e,
      $ = EM(CM, f),
      [A, C] = P.useState(null),
      T = Jt(t, (ve) => C(ve)),
      [_, R] = P.useState(null),
      M = Kse(_),
      D = (n = M == null ? void 0 : M.width) !== null && n !== void 0 ? n : 0,
      N = (r = M == null ? void 0 : M.height) !== null && r !== void 0 ? r : 0,
      L = c + (p !== "center" ? "-" + p : ""),
      k =
        typeof v == "number"
          ? v
          : { top: 0, right: 0, bottom: 0, left: 0, ...v },
      I = Array.isArray(g) ? g : [g],
      V = I.length > 0,
      U = { padding: k, boundary: I.filter(ele), altBoundary: V },
      {
        refs: H,
        floatingStyles: ee,
        placement: X,
        isPositioned: de,
        middlewareData: ue
      } = Gse({
        strategy: "fixed",
        placement: L,
        whileElementsMounted: (...ve) =>
          Use(...ve, { animationFrame: x === "always" }),
        elements: { reference: $.anchor },
        middleware: [
          Sse({ mainAxis: d + N, alignmentAxis: h }),
          b &&
            Ose({
              mainAxis: !0,
              crossAxis: !1,
              limiter: y === "partial" ? Pse() : void 0,
              ...U
            }),
          b && bse({ ...U }),
          $se({
            ...U,
            apply: ({
              elements: ve,
              rects: je,
              availableWidth: Ke,
              availableHeight: It
            }) => {
              const { width: er, height: wn } = je.reference,
                Ze = ve.floating.style
              Ze.setProperty("--radix-popper-available-width", `${Ke}px`),
                Ze.setProperty("--radix-popper-available-height", `${It}px`),
                Ze.setProperty("--radix-popper-anchor-width", `${er}px`),
                Ze.setProperty("--radix-popper-anchor-height", `${wn}px`)
            }
          }),
          _ && Hse({ element: _, padding: m }),
          tle({ arrowWidth: D, arrowHeight: N }),
          w && xse({ strategy: "referenceHidden", ...U })
        ]
      }),
      [We, Qe] = _M(X),
      W = wr(S)
    oa(() => {
      de && (W == null || W())
    }, [de, W])
    const Q = (i = ue.arrow) === null || i === void 0 ? void 0 : i.x,
      Z = (o = ue.arrow) === null || o === void 0 ? void 0 : o.y,
      F =
        ((a = ue.arrow) === null || a === void 0 ? void 0 : a.centerOffset) !==
        0,
      [me, ae] = P.useState()
    return (
      oa(() => {
        A && ae(window.getComputedStyle(A).zIndex)
      }, [A]),
      P.createElement(
        "div",
        {
          ref: H.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...ee,
            transform: de ? ee.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: me,
            "--radix-popper-transform-origin": [
              (s = ue.transformOrigin) === null || s === void 0 ? void 0 : s.x,
              (l = ue.transformOrigin) === null || l === void 0 ? void 0 : l.y
            ].join(" ")
          },
          dir: e.dir
        },
        P.createElement(
          Zse,
          {
            scope: f,
            placedSide: We,
            onArrowChange: R,
            arrowX: Q,
            arrowY: Z,
            shouldHideArrow: F
          },
          P.createElement(
            dt.div,
            se({ "data-side": We, "data-align": Qe }, O, {
              ref: T,
              style: {
                ...O.style,
                animation: de ? void 0 : "none",
                opacity:
                  (u = ue.hide) !== null && u !== void 0 && u.referenceHidden
                    ? 0
                    : void 0
              }
            })
          )
        )
      )
    )
  })
function ele(e) {
  return e !== null
}
const tle = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var n, r, i, o, a
    const { placement: s, rects: l, middlewareData: u } = t,
      c =
        ((n = u.arrow) === null || n === void 0 ? void 0 : n.centerOffset) !==
        0,
      d = c ? 0 : e.arrowWidth,
      p = c ? 0 : e.arrowHeight,
      [h, m] = _M(s),
      b = { start: "0%", center: "50%", end: "100%" }[m],
      g =
        ((r = (i = u.arrow) === null || i === void 0 ? void 0 : i.x) !== null &&
        r !== void 0
          ? r
          : 0) +
        d / 2,
      v =
        ((o = (a = u.arrow) === null || a === void 0 ? void 0 : a.y) !== null &&
        o !== void 0
          ? o
          : 0) +
        p / 2
    let y = "",
      w = ""
    return (
      h === "bottom"
        ? ((y = c ? b : `${g}px`), (w = `${-p}px`))
        : h === "top"
          ? ((y = c ? b : `${g}px`), (w = `${l.floating.height + p}px`))
          : h === "right"
            ? ((y = `${-p}px`), (w = c ? b : `${v}px`))
            : h === "left" &&
              ((y = `${l.floating.width + p}px`), (w = c ? b : `${v}px`)),
      { data: { x: y, y: w } }
    )
  }
})
function _M(e) {
  const [t, n = "center"] = e.split("-")
  return [t, n]
}
const nle = Xse,
  rle = Qse,
  ile = Jse,
  ole = P.forwardRef((e, t) =>
    P.createElement(
      dt.span,
      se({}, e, {
        ref: t,
        style: {
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...e.style
        }
      })
    )
  ),
  ale = ole,
  [wp, Nle] = Ta("Tooltip", [TM]),
  ob = TM(),
  sle = "TooltipProvider",
  lle = 700,
  Tg = "tooltip.open",
  [ule, ab] = wp(sle),
  cle = (e) => {
    const {
        __scopeTooltip: t,
        delayDuration: n = lle,
        skipDelayDuration: r = 300,
        disableHoverableContent: i = !1,
        children: o
      } = e,
      [a, s] = P.useState(!0),
      l = P.useRef(!1),
      u = P.useRef(0)
    return (
      P.useEffect(() => {
        const f = u.current
        return () => window.clearTimeout(f)
      }, []),
      P.createElement(
        ule,
        {
          scope: t,
          isOpenDelayed: a,
          delayDuration: n,
          onOpen: P.useCallback(() => {
            window.clearTimeout(u.current), s(!1)
          }, []),
          onClose: P.useCallback(() => {
            window.clearTimeout(u.current),
              (u.current = window.setTimeout(() => s(!0), r))
          }, [r]),
          isPointerInTransitRef: l,
          onPointerInTransitChange: P.useCallback((f) => {
            l.current = f
          }, []),
          disableHoverableContent: i
        },
        o
      )
    )
  },
  sb = "Tooltip",
  [fle, Sp] = wp(sb),
  dle = (e) => {
    const {
        __scopeTooltip: t,
        children: n,
        open: r,
        defaultOpen: i = !1,
        onOpenChange: o,
        disableHoverableContent: a,
        delayDuration: s
      } = e,
      l = ab(sb, e.__scopeTooltip),
      u = ob(t),
      [f, c] = P.useState(null),
      d = Wo(),
      p = P.useRef(0),
      h = a ?? l.disableHoverableContent,
      m = s ?? l.delayDuration,
      b = P.useRef(!1),
      [g = !1, v] = _d({
        prop: r,
        defaultProp: i,
        onChange: (O) => {
          O
            ? (l.onOpen(), document.dispatchEvent(new CustomEvent(Tg)))
            : l.onClose(),
            o == null || o(O)
        }
      }),
      y = P.useMemo(
        () => (g ? (b.current ? "delayed-open" : "instant-open") : "closed"),
        [g]
      ),
      w = P.useCallback(() => {
        window.clearTimeout(p.current), (b.current = !1), v(!0)
      }, [v]),
      x = P.useCallback(() => {
        window.clearTimeout(p.current), v(!1)
      }, [v]),
      S = P.useCallback(() => {
        window.clearTimeout(p.current),
          (p.current = window.setTimeout(() => {
            ;(b.current = !0), v(!0)
          }, m))
      }, [m, v])
    return (
      P.useEffect(() => () => window.clearTimeout(p.current), []),
      P.createElement(
        nle,
        u,
        P.createElement(
          fle,
          {
            scope: t,
            contentId: d,
            open: g,
            stateAttribute: y,
            trigger: f,
            onTriggerChange: c,
            onTriggerEnter: P.useCallback(() => {
              l.isOpenDelayed ? S() : w()
            }, [l.isOpenDelayed, S, w]),
            onTriggerLeave: P.useCallback(() => {
              h ? x() : window.clearTimeout(p.current)
            }, [x, h]),
            onOpen: w,
            onClose: x,
            disableHoverableContent: h
          },
          n
        )
      )
    )
  },
  LP = "TooltipTrigger",
  ple = P.forwardRef((e, t) => {
    const { __scopeTooltip: n, ...r } = e,
      i = Sp(LP, n),
      o = ab(LP, n),
      a = ob(n),
      s = P.useRef(null),
      l = Jt(t, s, i.onTriggerChange),
      u = P.useRef(!1),
      f = P.useRef(!1),
      c = P.useCallback(() => (u.current = !1), [])
    return (
      P.useEffect(
        () => () => document.removeEventListener("pointerup", c),
        [c]
      ),
      P.createElement(
        rle,
        se({ asChild: !0 }, a),
        P.createElement(
          dt.button,
          se(
            {
              "aria-describedby": i.open ? i.contentId : void 0,
              "data-state": i.stateAttribute
            },
            r,
            {
              ref: l,
              onPointerMove: Be(e.onPointerMove, (d) => {
                d.pointerType !== "touch" &&
                  !f.current &&
                  !o.isPointerInTransitRef.current &&
                  (i.onTriggerEnter(), (f.current = !0))
              }),
              onPointerLeave: Be(e.onPointerLeave, () => {
                i.onTriggerLeave(), (f.current = !1)
              }),
              onPointerDown: Be(e.onPointerDown, () => {
                ;(u.current = !0),
                  document.addEventListener("pointerup", c, { once: !0 })
              }),
              onFocus: Be(e.onFocus, () => {
                u.current || i.onOpen()
              }),
              onBlur: Be(e.onBlur, i.onClose),
              onClick: Be(e.onClick, i.onClose)
            }
          )
        )
      )
    )
  }),
  hle = "TooltipPortal",
  [Rle, mle] = wp(hle, { forceMount: void 0 }),
  Gl = "TooltipContent",
  vle = P.forwardRef((e, t) => {
    const n = mle(Gl, e.__scopeTooltip),
      { forceMount: r = n.forceMount, side: i = "top", ...o } = e,
      a = Sp(Gl, e.__scopeTooltip)
    return P.createElement(
      Ea,
      { present: r || a.open },
      a.disableHoverableContent
        ? P.createElement(kM, se({ side: i }, o, { ref: t }))
        : P.createElement(gle, se({ side: i }, o, { ref: t }))
    )
  }),
  gle = P.forwardRef((e, t) => {
    const n = Sp(Gl, e.__scopeTooltip),
      r = ab(Gl, e.__scopeTooltip),
      i = P.useRef(null),
      o = Jt(t, i),
      [a, s] = P.useState(null),
      { trigger: l, onClose: u } = n,
      f = i.current,
      { onPointerInTransitChange: c } = r,
      d = P.useCallback(() => {
        s(null), c(!1)
      }, [c]),
      p = P.useCallback(
        (h, m) => {
          const b = h.currentTarget,
            g = { x: h.clientX, y: h.clientY },
            v = ble(g, b.getBoundingClientRect()),
            y = xle(g, v),
            w = wle(m.getBoundingClientRect()),
            x = Ole([...y, ...w])
          s(x), c(!0)
        },
        [c]
      )
    return (
      P.useEffect(() => () => d(), [d]),
      P.useEffect(() => {
        if (l && f) {
          const h = (b) => p(b, f),
            m = (b) => p(b, l)
          return (
            l.addEventListener("pointerleave", h),
            f.addEventListener("pointerleave", m),
            () => {
              l.removeEventListener("pointerleave", h),
                f.removeEventListener("pointerleave", m)
            }
          )
        }
      }, [l, f, p, d]),
      P.useEffect(() => {
        if (a) {
          const h = (m) => {
            const b = m.target,
              g = { x: m.clientX, y: m.clientY },
              v =
                (l == null ? void 0 : l.contains(b)) ||
                (f == null ? void 0 : f.contains(b)),
              y = !Sle(g, a)
            v ? d() : y && (d(), u())
          }
          return (
            document.addEventListener("pointermove", h),
            () => document.removeEventListener("pointermove", h)
          )
        }
      }, [l, f, a, u, d]),
      P.createElement(kM, se({}, e, { ref: o }))
    )
  }),
  [yle, Lle] = wp(sb, { isInside: !1 }),
  kM = P.forwardRef((e, t) => {
    const {
        __scopeTooltip: n,
        children: r,
        "aria-label": i,
        onEscapeKeyDown: o,
        onPointerDownOutside: a,
        ...s
      } = e,
      l = Sp(Gl, n),
      u = ob(n),
      { onClose: f } = l
    return (
      P.useEffect(
        () => (
          document.addEventListener(Tg, f),
          () => document.removeEventListener(Tg, f)
        ),
        [f]
      ),
      P.useEffect(() => {
        if (l.trigger) {
          const c = (d) => {
            const p = d.target
            p != null && p.contains(l.trigger) && f()
          }
          return (
            window.addEventListener("scroll", c, { capture: !0 }),
            () => window.removeEventListener("scroll", c, { capture: !0 })
          )
        }
      }, [l.trigger, f]),
      P.createElement(
        EE,
        {
          asChild: !0,
          disableOutsidePointerEvents: !1,
          onEscapeKeyDown: o,
          onPointerDownOutside: a,
          onFocusOutside: (c) => c.preventDefault(),
          onDismiss: f
        },
        P.createElement(
          ile,
          se({ "data-state": l.stateAttribute }, u, s, {
            ref: t,
            style: {
              ...s.style,
              "--radix-tooltip-content-transform-origin":
                "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width":
                "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height":
                "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width":
                "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height":
                "var(--radix-popper-anchor-height)"
            }
          }),
          P.createElement(AE, null, r),
          P.createElement(
            yle,
            { scope: n, isInside: !0 },
            P.createElement(ale, { id: l.contentId, role: "tooltip" }, i || r)
          )
        )
      )
    )
  })
function ble(e, t) {
  const n = Math.abs(t.top - e.y),
    r = Math.abs(t.bottom - e.y),
    i = Math.abs(t.right - e.x),
    o = Math.abs(t.left - e.x)
  switch (Math.min(n, r, i, o)) {
    case o:
      return "left"
    case i:
      return "right"
    case n:
      return "top"
    case r:
      return "bottom"
    default:
      throw new Error("unreachable")
  }
}
function xle(e, t, n = 5) {
  const r = []
  switch (t) {
    case "top":
      r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n })
      break
    case "bottom":
      r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n })
      break
    case "left":
      r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n })
      break
    case "right":
      r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n })
      break
  }
  return r
}
function wle(e) {
  const { top: t, right: n, bottom: r, left: i } = e
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: r },
    { x: i, y: r }
  ]
}
function Sle(e, t) {
  const { x: n, y: r } = e
  let i = !1
  for (let o = 0, a = t.length - 1; o < t.length; a = o++) {
    const s = t[o].x,
      l = t[o].y,
      u = t[a].x,
      f = t[a].y
    l > r != f > r && n < ((u - s) * (r - l)) / (f - l) + s && (i = !i)
  }
  return i
}
function Ole(e) {
  const t = e.slice()
  return (
    t.sort((n, r) =>
      n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0
    ),
    Ple(t)
  )
}
function Ple(e) {
  if (e.length <= 1) return e.slice()
  const t = []
  for (let r = 0; r < e.length; r++) {
    const i = e[r]
    for (; t.length >= 2; ) {
      const o = t[t.length - 1],
        a = t[t.length - 2]
      if ((o.x - a.x) * (i.y - a.y) >= (o.y - a.y) * (i.x - a.x)) t.pop()
      else break
    }
    t.push(i)
  }
  t.pop()
  const n = []
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r]
    for (; n.length >= 2; ) {
      const o = n[n.length - 1],
        a = n[n.length - 2]
      if ((o.x - a.x) * (i.y - a.y) >= (o.y - a.y) * (i.x - a.x)) n.pop()
      else break
    }
    n.push(i)
  }
  return (
    n.pop(),
    t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y
      ? t
      : t.concat(n)
  )
}
const $le = cle,
  Ale = dle,
  Tle = ple,
  MM = vle,
  Ele = $le,
  Xh = Ale,
  Yh = Tle,
  Ec = P.forwardRef(({ className: e, sideOffset: t = 4, ...n }, r) =>
    j.jsx(MM, {
      ref: r,
      sideOffset: t,
      className: ot(
        "bg-popover text-popover-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 overflow-hidden rounded-md border px-3 py-1.5 text-sm shadow-md",
        e
      ),
      ...n
    })
  )
Ec.displayName = MM.displayName
const Cle = () =>
    j.jsx(Y0, {
      id: "tools",
      header: "Built with the tools you love",
      content: j.jsxs("p", {
        children: [
          j.jsx("span", {
            className: "text-foreground font-semibold",
            children: "TableX"
          }),
          " utilizes modern tooling to provide a delightful developer experience and an Immersive user experience."
        ]
      }),
      children: j.jsx(_le, {})
    }),
  _le = () => {
    const e = [
      { src: "/icons/rust.svg", alt: "rust", content: "Rust" },
      { src: "/icons/tauri.svg", alt: "tauri", content: "Tauri" },
      { src: "/icons/tailwind.svg", alt: "tailwind", content: "Tailwind" },
      { src: "/icons/vercel.svg", alt: "vercel", content: "Vercel" }
    ]
    return j.jsx(Ele, {
      children: j.jsxs("div", {
        className: "mx-auto mt-7  grid w-full grid-cols-3 gap-5 md:gap-y-8",
        children: [
          j.jsxs(Xh, {
            children: [
              j.jsx(Yh, {
                asChild: !0,
                children: j.jsx("img", {
                  src: "/icons/next.svg",
                  alt: "nextjs",
                  className: "h-10 w-10 justify-self-center invert"
                })
              }),
              j.jsx(Ec, { children: "Nextjs" })
            ]
          }),
          e.map(({ src: t, alt: n, content: r }, i) =>
            j.jsxs(
              Xh,
              {
                children: [
                  j.jsx(Yh, {
                    asChild: !0,
                    children: j.jsx("img", {
                      src: t,
                      alt: n,
                      className: "h-10 w-10 justify-self-center"
                    })
                  }),
                  j.jsx(Ec, { children: r })
                ]
              },
              i
            )
          ),
          j.jsxs(Xh, {
            children: [
              j.jsx(Yh, {
                asChild: !0,
                children: j.jsx("img", {
                  src: "/icons/shadcn.svg",
                  alt: "shadcn",
                  className: "h-8 w-8 justify-self-center"
                })
              }),
              j.jsx(Ec, { children: "Nextjs" })
            ]
          })
        ]
      })
    })
  }
function kle() {
  return j.jsxs(EB, {
    defaultTheme: "dark",
    storageKey: "vite-ui-theme",
    children: [
      j.jsx(mB, {}),
      j.jsx($B, {}),
      j.jsxs("main", {
        className: "font-[Rubik] ",
        children: [
          j.jsx(lB, {}),
          j.jsxs(lD, {
            children: [
              j.jsx(n3, {}),
              j.jsx(Cle, {}),
              j.jsx(_ae, {}),
              j.jsx(lse, {}),
              j.jsx(ase, {})
            ]
          })
        ]
      })
    ]
  })
}
Qh.createRoot(document.getElementById("root")).render(
  j.jsx(E.StrictMode, { children: j.jsx(kle, {}) })
)
